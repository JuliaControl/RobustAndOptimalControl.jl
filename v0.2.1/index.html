<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · RobustAndOptimalControl Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>RobustAndOptimalControl Documentation</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Named-systems"><span>Named systems</span></a></li><li class="toplevel"><a class="tocitem" href="#Connecting-systems-together"><span>Connecting systems together</span></a></li><li class="toplevel"><a class="tocitem" href="#Model-augmentation"><span>Model augmentation</span></a></li><li class="toplevel"><a class="tocitem" href="#H_\\infty-and-H_2-design"><span><span>$H_\infty$</span> and <span>$H_2$</span> design</span></a></li><li class="toplevel"><a class="tocitem" href="#LQG-design"><span>LQG design</span></a></li><li class="toplevel"><a class="tocitem" href="#Structured-singular-value-and-diskmargin"><span>Structured singular value and diskmargin</span></a></li><li class="toplevel"><a class="tocitem" href="#Closed-loop-analysis"><span>Closed-loop analysis</span></a></li><li class="toplevel"><a class="tocitem" href="#Exported-functions-and-types"><span>Exported functions and types</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="uncertainty/">Uncertainty modeling</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RobustAndOptimalControl.jl"><a class="docs-heading-anchor" href="#RobustAndOptimalControl.jl">RobustAndOptimalControl.jl</a><a id="RobustAndOptimalControl.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RobustAndOptimalControl.jl" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="language-julia hljs">pkg&gt; add RobustAndOptimalControl</code></pre><h1 id="Named-systems"><a class="docs-heading-anchor" href="#Named-systems">Named systems</a><a id="Named-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Named-systems" title="Permalink"></a></h1><p>See <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/examples/complicated_feedback.jl">complicated-feedback example</a></p><ul><li><a href="#RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T"><code>named_ss</code></a></li></ul><h1 id="Connecting-systems-together"><a class="docs-heading-anchor" href="#Connecting-systems-together">Connecting systems together</a><a id="Connecting-systems-together-1"></a><a class="docs-heading-anchor-permalink" href="#Connecting-systems-together" title="Permalink"></a></h1><p>See <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/examples/complicated_feedback.jl">complicated-feedback example</a></p><ul><li><a href="#RobustAndOptimalControl.connect-Tuple{Any}"><code>connect</code></a></li></ul><p>The following complicated feedback interconnection</p><pre><code class="nohighlight hljs">                 yF
              ┌────────────────────────────────┐
              │                                │
    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐
uF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP
────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►
    │       │    │       │   ┌──►         │         │       │    │
    └───────┘    └───────┘   │  └─────────┘         └───────┘    │
                             │                                   │
                             └───────────────────────────────────┘</code></pre><p>can be created by</p><pre><code class="language-julia hljs">F = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)
R = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)
C = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)
P = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)

addP = sumblock(&quot;uP = yF + yC&quot;) # Sum node before P
addC = sumblock(&quot;uC = yR - yP&quot;) # Sum node before C (drawn as two arrows into C in the diagram)

connections = [
    :yP =&gt; :yP # Output to input
    :uP =&gt; :uP # addP&#39;s output is called the same as P&#39;s input
    :yC =&gt; :yC
    :yF =&gt; :yF
    :yF =&gt; :uR
    :uC =&gt; :uC
    :yR =&gt; :yR
]
w1 = [:uF] # External inputs

G = connect([F, R, C, P, addP, addC], connections; w1)</code></pre><p>If an external input is to be connected to multiple points, use a <code>splitter</code> to split up the signal into a set of unique names which are then used in the connections.</p><h1 id="Model-augmentation"><a class="docs-heading-anchor" href="#Model-augmentation">Model augmentation</a><a id="Model-augmentation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-augmentation" title="Permalink"></a></h1><p>TODO.</p><p>Add disturbance and performance models to your system model.</p><ul><li><a href="#RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>add_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}"><code>add_measurement_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_input_differentiator"><code>add_input_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_output_differentiator"><code>add_output_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_input_integrator"><code>add_input_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_output_integrator"><code>add_output_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>add_low_frequency_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}"><code>add_resonant_disturbance</code></a></li></ul><h1 id="H_\\infty-and-H_2-design"><a class="docs-heading-anchor" href="#H_\\infty-and-H_2-design"><span>$H_\infty$</span> and <span>$H_2$</span> design</a><a id="H_\\infty-and-H_2-design-1"></a><a class="docs-heading-anchor-permalink" href="#H_\\infty-and-H_2-design" title="Permalink"></a></h1><p>TODO Examples are available in the <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/tree/master/examples">example folder</a>.</p><ul><li><a href="#RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}"><code>hinfsynthesize</code></a></li><li><a href="#RobustAndOptimalControl.h2synthesize"><code>h2synthesize</code></a></li><li><a href="#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a></li></ul><h1 id="LQG-design"><a class="docs-heading-anchor" href="#LQG-design">LQG design</a><a id="LQG-design-1"></a><a class="docs-heading-anchor-permalink" href="#LQG-design" title="Permalink"></a></h1><p>TODO</p><ul><li><a href="#RobustAndOptimalControl.LQGProblem"><code>LQGProblem</code></a></li></ul><h1 id="Structured-singular-value-and-diskmargin"><a class="docs-heading-anchor" href="#Structured-singular-value-and-diskmargin">Structured singular value and diskmargin</a><a id="Structured-singular-value-and-diskmargin-1"></a><a class="docs-heading-anchor-permalink" href="#Structured-singular-value-and-diskmargin" title="Permalink"></a></h1><ul><li><a href="#RobustAndOptimalControl.structured_singular_value-Tuple{UncertainSS, AbstractVector}"><code>structured_singular_value</code></a>. Note, this only handles diagonal complex perturbations at the moment.</li><li><a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}"><code>loop_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin"><code>sim_diskmargin</code></a></li></ul><h1 id="Closed-loop-analysis"><a class="docs-heading-anchor" href="#Closed-loop-analysis">Closed-loop analysis</a><a id="Closed-loop-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Closed-loop-analysis" title="Permalink"></a></h1><ul><li><a href="#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a></li><li><a href="@ref"><code>G_CS</code></a></li><li><a href="@ref"><code>G_PS</code></a></li><li><a href="@ref"><code>gangoffour</code></a></li></ul><h1 id="Exported-functions-and-types"><a class="docs-heading-anchor" href="#Exported-functions-and-types">Exported functions and types</a><a id="Exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#RobustAndOptimalControl.Disk"><code>RobustAndOptimalControl.Disk</code></a></li><li><a href="#RobustAndOptimalControl.Diskmargin"><code>RobustAndOptimalControl.Diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.LQGProblem"><code>RobustAndOptimalControl.LQGProblem</code></a></li><li><a href="#RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.LQGProblem</code></a></li><li><a href="#RobustAndOptimalControl.NamedStateSpace"><code>RobustAndOptimalControl.NamedStateSpace</code></a></li><li><a href="#RobustAndOptimalControl.UncertainSS"><code>RobustAndOptimalControl.UncertainSS</code></a></li><li><a href="#RobustAndOptimalControl.δ"><code>RobustAndOptimalControl.δ</code></a></li><li><a href="#ControlSystems.ss"><code>ControlSystems.ss</code></a></li><li><a href="#RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_input_differentiator"><code>RobustAndOptimalControl.add_input_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_input_integrator"><code>RobustAndOptimalControl.add_input_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_measurement_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_output_differentiator"><code>RobustAndOptimalControl.add_output_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_output_integrator"><code>RobustAndOptimalControl.add_output_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}"><code>RobustAndOptimalControl.add_resonant_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.bilinearc2d-Tuple{ControlSystems.StateSpace{ControlSystems.Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a></li><li><a href="#RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{ControlSystems.Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a></li><li><a href="#RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a></li><li><a href="#RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilineard2c</code></a></li><li><a href="#RobustAndOptimalControl.bilineard2c-Tuple{ControlSystems.StateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a></li><li><a href="#RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a></li><li><a href="#RobustAndOptimalControl.broken_feedback-Tuple{ControlSystems.LTISystem, Any}"><code>RobustAndOptimalControl.broken_feedback</code></a></li><li><a href="#RobustAndOptimalControl.closedloop"><code>RobustAndOptimalControl.closedloop</code></a></li><li><a href="#RobustAndOptimalControl.comp_sensitivity-Tuple"><code>RobustAndOptimalControl.comp_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.connect-Tuple{Any}"><code>RobustAndOptimalControl.connect</code></a></li><li><a href="#RobustAndOptimalControl.controller_reduction"><code>RobustAndOptimalControl.controller_reduction</code></a></li><li><a href="#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Any, AbstractVector, Vararg{Any}}"><code>RobustAndOptimalControl.diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractArray}"><code>RobustAndOptimalControl.diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.diskmargin"><code>RobustAndOptimalControl.diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}"><code>RobustAndOptimalControl.expand_symbol</code></a></li><li><a href="#RobustAndOptimalControl.extended_controller"><code>RobustAndOptimalControl.extended_controller</code></a></li><li><a href="#RobustAndOptimalControl.extended_controller-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.extended_controller</code></a></li><li><a href="#RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any, F}} where {N, F}"><code>RobustAndOptimalControl.find_lft</code></a></li><li><a href="#RobustAndOptimalControl.frequency_weighted_reduction-NTuple{4, Any}"><code>RobustAndOptimalControl.frequency_weighted_reduction</code></a></li><li><a href="#RobustAndOptimalControl.glover_mcfarlane"><code>RobustAndOptimalControl.glover_mcfarlane</code></a></li><li><a href="#RobustAndOptimalControl.h2synthesize"><code>RobustAndOptimalControl.h2synthesize</code></a></li><li><a href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>RobustAndOptimalControl.hanus</code></a></li><li><a href="#RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfassumptions</code></a></li><li><a href="#RobustAndOptimalControl.hinfpartition-NTuple{4, Any}"><code>RobustAndOptimalControl.hinfpartition</code></a></li><li><a href="#RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, ControlSystems.LTISystem, ControlSystems.LTISystem}"><code>RobustAndOptimalControl.hinfsignals</code></a></li><li><a href="#RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfsynthesize</code></a></li><li><a href="#RobustAndOptimalControl.hsvd-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}}"><code>RobustAndOptimalControl.hsvd</code></a></li><li><a href="#RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.input_comp_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.input_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}"><code>RobustAndOptimalControl.measure</code></a></li><li><a href="#RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.named_ss</code></a></li><li><a href="#RobustAndOptimalControl.noise_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.noise_mapping</code></a></li><li><a href="#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.output_comp_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.output_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.partition</code></a></li><li><a href="#RobustAndOptimalControl.performance_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.performance_mapping</code></a></li><li><a href="#RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}"><code>RobustAndOptimalControl.robstab</code></a></li><li><a href="#RobustAndOptimalControl.sensitivity-Tuple"><code>RobustAndOptimalControl.sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractVector}"><code>RobustAndOptimalControl.sim_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.specificationplot"><code>RobustAndOptimalControl.specificationplot</code></a></li><li><a href="#RobustAndOptimalControl.structured_singular_value-Tuple{UncertainSS, AbstractVector}"><code>RobustAndOptimalControl.structured_singular_value</code></a></li><li><a href="#RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.structured_singular_value</code></a></li><li><a href="#RobustAndOptimalControl.sumblock-Tuple{String}"><code>RobustAndOptimalControl.sumblock</code></a></li><li><a href="#RobustAndOptimalControl.system_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.system_mapping</code></a></li><li><a href="#RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.δc"><code>RobustAndOptimalControl.δc</code></a></li><li><a href="#RobustAndOptimalControl.δr"><code>RobustAndOptimalControl.δr</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.Disk" href="#RobustAndOptimalControl.Disk"><code>RobustAndOptimalControl.Disk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Disk</code></pre><p>Represents a perturbation disc in the complex plane. <code>Disk(0.5, 2)</code> represents all perturbations in the circle centered at 1.25 with radius 0.75, or in other words, a gain margin of 2 and a pahse margin of 36.9 degrees.</p><p>A disk can be converted to a Nyquist exclusion disk by <code>nyquist(disk)</code> and plotted using <code>plot(disk)</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>γmin</code>: Lower intercept</li><li><code>γmax</code>: Upper intercept</li><li><code>c</code>: Center</li><li><code>r</code>: Radius</li><li><code>ϕm</code>: Angle of tangent line through origin.</li></ul><p>If γmax &lt; γmin the disk is inverted. See <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a> for disk margin computations. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/diskmargin.jl#L69-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.Diskmargin" href="#RobustAndOptimalControl.Diskmargin"><code>RobustAndOptimalControl.Diskmargin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Diskmargin</code></pre><p>The notation follows &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet</p><p><strong>Fields:</strong></p><p><code>α</code>: The disk margin <code>ω0</code>: The worst-case frequency <code>f0</code>: The destabilizing perturbation <code>f0</code> is a complex number with simultaneous gain and phase variation. This critical perturbation causes an instability with closed-loop pole on the imaginary axis at the critical frequency ω0  <code>δ0</code>: The uncertain element generating f0. <code>γmin</code>: The lower real-axis intercept of the disk (classical lower gain margin). <code>γmax</code>: The upper real-axis intercept of the disk (classical upper gain margin). <code>ϕm</code>: is the classical phase margin. <code>σ</code>: The skew parameter that was used to calculate the margin</p><p>The &quot;disk&quot; margin becomes a half plane for <code>α = 2</code> and an inverted circle for <code>α &gt; 2</code>. In this case, the upper gain margin is infinite. See the paper for more details, in particular figure 6.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/diskmargin.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.LQGProblem" href="#RobustAndOptimalControl.LQGProblem"><code>RobustAndOptimalControl.LQGProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">G = LQG(sys::AbstractStateSpace, Q1, Q2, R1, R2; qQ=0, qR=0, M = I, N = I)</code></pre><p>Return an LQG object that describes the closed control loop around the process <code>sys=ss(A,B,C,D)</code> where the controller is of LQG-type. The controller is specified by weight matrices <code>Q1,Q2</code> that penalizes state deviations and control signal variance respectively, and covariance matrices <code>R1,R2</code> which specify state drift and measurement covariance respectively.</p><p><code>qQ</code> and <code>qR</code> can be set to incorporate loop transfer recovery, i.e.,</p><pre><code class="language-julia hljs">L = lqr(A, B, Q1+qQ*C&#39;C, Q2)
K = kalman(A, C, R1+qR*B*B&#39;, R2)</code></pre><p>Increasing <code>qQ</code> will add more cost in output direction, e.g., encouraging the use of cheap control, while increasing <code>qR</code> adds fictious dynamics noise, makes the observer faster in the direction we control.</p><p><code>M</code> is a matrix that defines the controlled variables <code>z</code>, i.e., the variables for which you provide reference signals. If no <code>M</code> is provided, the default is to consider all state variables of the system as controlled. The definitions of <code>z</code> and <code>y</code> are given below</p><pre><code class="nohighlight hljs">y = C*x
z = M*x</code></pre><p><code>size(M, 1)</code> determines the size of the <code>Q1</code> matrix you need to supply.</p><p><code>N</code> is a matrix that defines how the dynamics noise <code>v</code> enters the system, i.e. If no <code>N</code> is provided, the default is to consider all state variables being affected by independent noise components. The definition of <code>v</code> is given below</p><pre><code class="nohighlight hljs">x′ = A*x + B*u + N*v</code></pre><p><code>size(N, 2)</code> determines the size of the <code>R1</code> matrix you need to supply.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">s = tf(&quot;s&quot;)
P = [1/(s+1) 2/(s+2); 1/(s+3) 1/(s-1)]
sys = ss(P)
eye(n) = Matrix{Float64}(I,n,n) # For convinience

qQ = 1
qR = 1
Q1 = 10eye(4)
Q2 = 1eye(2)
R1 = 1eye(6)
R2 = 1eye(2)

G = LQG(sys, Q1, Q2, R1, R2, qQ=qQ, qR=qR)

Gcl = G.cl
T = G.T
S = G.S
sigmaplot([S,T],exp10.(range(-3, stop=3, length=1000)))
stepplot(Gcl)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L5-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.LQGProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LQGProblem(P::ExtendedStateSpace)</code></pre><p>If only an <code>ExtendedStateSpace</code> system is provided, the system <code>P</code> is assumed to correspond to the H₂ optimal control problem with</p><pre><code class="nohighlight hljs">C1&#39;C1    = Q1
D12&#39;D12  = Q2

B1*B1&#39;   = R1
D21*D21&#39; = R2</code></pre><p>and an <code>LQGProblem</code> with the above covariance matrices is returned. The system description in the returned LQGProblem will have <code>B1 = C1 = I</code>. See Ch. 13 in Robust and optimal control for reference. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L94-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.NamedStateSpace" href="#RobustAndOptimalControl.NamedStateSpace"><code>RobustAndOptimalControl.NamedStateSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>See <code>named_ss</code> for a convenient constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/named_systems2.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.UncertainSS" href="#RobustAndOptimalControl.UncertainSS"><code>RobustAndOptimalControl.UncertainSS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UncertainSS{TE} &lt;: AbstractStateSpace{TE}</code></pre><p>Represents LFT_u(M, Diagonal(Δ))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/uncertainty_interface.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.δ" href="#RobustAndOptimalControl.δ"><code>RobustAndOptimalControl.δ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">δ(N=32)</code></pre><p>Create an uncertain element of <code>N</code> uniformly distributed samples ∈ [-1, 1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/find_lft.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.ss" href="#ControlSystems.ss"><code>ControlSystems.ss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ss(A, B1, B2, C1, C2, D11, D12, D21, D22 [, Ts])
ss(A, B1, B2, C1, C2; D11, D12, D21, D22 [, Ts])</code></pre><p>Create <a href="@ref"><code>ExtendedStateSpace</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/ExtendedStateSpace.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}" href="#RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_disturbance(sys::StateSpace, Ad::Matrix, Cd::Matrix)</code></pre><p>See CCS pp. 144</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: System to augment</li><li><code>Ad</code>: The dynamics of the disturbance</li><li><code>Cd</code>: How the disturbance states affect the states of <code>sys</code>. This matrix has the shape (sys.nx, size(Ad, 1))</li></ul><p>See also <a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>add_low_frequency_disturbance</code></a>, <a href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}"><code>add_resonant_disturbance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/model_augmentation.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_input_differentiator" href="#RobustAndOptimalControl.add_input_differentiator"><code>RobustAndOptimalControl.add_input_differentiator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_input_differentiator(sys::StateSpace, ui = 1:sys.nu; goodwin=false)</code></pre><p>Augment the output of <code>sys</code> with the difference <code>u(k+1)-u(k)</code></p><p><strong>Arguments:</strong></p><ul><li><code>ui</code>: An index or vector of indices indicating which inputs to differentiate.</li><li><code>goodwin</code>: If true, the difference operator will use the Goodwin δ operator, i.e., <code>(u(k+1)-u(k)) / sys.Ts</code>.</li></ul><p>The augmented system will have the matrices</p><pre><code class="nohighlight hljs">[A 0; 0 0]  [B; I]  [C 0; 0 -I]  [D; I]</code></pre><p>with <code>length(ui)</code> added states and outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/model_augmentation.jl#L177-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_input_integrator" href="#RobustAndOptimalControl.add_input_integrator"><code>RobustAndOptimalControl.add_input_integrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_input_integrator(sys::StateSpace, ui = 1, ϵ = 0)</code></pre><p>Augment the output of <code>sys</code> with the integral of input at index <code>ui</code>, i.e.,  <code>y_aug = [y; ∫u[ui]]</code> See also <a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>add_low_frequency_disturbance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/model_augmentation.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}" href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_low_frequency_disturbance(sys::StateSpace, Ai::Integer; ϵ = 0)</code></pre><p>A disturbance affecting only state <code>Ai</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/model_augmentation.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace}" href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_low_frequency_disturbance(sys::StateSpace; ϵ = 0, measurement = false)</code></pre><p>Augment <code>sys</code> with a low-frequency (integrating if <code>ϵ=0</code>) disturbance model. If an integrating input disturbance is used together with an observer, the controller will have integral action.</p><p><strong>Arguments:</strong></p><ul><li><code>ϵ</code>: Move the integrator pole <code>ϵ</code> into the stable region.</li><li><code>measurement</code>: If true, the disturbance is a measurement disturbance, otherwise it&#39;s an input diturbance. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/model_augmentation.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}" href="#RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_measurement_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_measurement_disturbance(sys::StateSpace{Continuous}, Ad::Matrix, Cd::Matrix)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/model_augmentation.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_output_differentiator" href="#RobustAndOptimalControl.add_output_differentiator"><code>RobustAndOptimalControl.add_output_differentiator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_differentiator(sys::StateSpace{&lt;:Discrete})</code></pre><p>Augment the output of <code>sys</code> with the numerical difference (discrete-time derivative) of output, i.e., <code>y_aug = [y; (y-y_prev)/sys.Ts]</code> To add both an integrator and a differentiator to a SISO system, use</p><pre><code class="language-julia hljs">Gd = add_output_integrator(add_output_differentiator(G), 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/model_augmentation.jl#L102-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_output_integrator" href="#RobustAndOptimalControl.add_output_integrator"><code>RobustAndOptimalControl.add_output_integrator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>add<em>output</em>integrator(sys::StateSpace{&lt;:Discrete}, ind = 1; ϵ = 0)</p><p>Augment the output of <code>sys</code> with the integral of output at index <code>ind</code>, i.e.,  <code>y_aug = [y; ∫y[ind]]</code> To add both an integrator and a differentiator to a SISO system, use</p><pre><code class="language-julia hljs">Gd = add_output_integrator(add_output_differentiator(G), 1)</code></pre><p>Note: numerical integration is subject to numerical drift. If the output of the system corresponds to, e.g., a velocity reference and the integral to position reference, consider methods for mitigating this drift.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/model_augmentation.jl#L128-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}" href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}"><code>RobustAndOptimalControl.add_resonant_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_resonant_disturbance(sys::StateSpace{Continuous}, ω, ζ, Ai::Int; measurement = false)</code></pre><p>Augment <code>sys</code> with a resonant disturbance model.</p><p><strong>Arguments:</strong></p><ul><li><code>ω</code>: Frequency</li><li><code>ζ</code>: Relative damping.</li><li><code>Ai</code>: The affected state</li><li><code>measurement</code>: If true, the disturbace is acting on the output, this will cause the controller to have zeros at ω (roots of poly s² + 2ζωs + ω²). If false, the disturbance is acting on the input, this will cause the controller to have poles at ω (roots of poly s² + 2ζωs + ω²).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/model_augmentation.jl#L76-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}" href="#RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilinearc2d(Ac::AbstractArray, Bc::AbstractArray, Cc::AbstractArray, Dc::AbstractArray, Ts::Number; tolerance=1e-12)</code></pre><p>Balanced Bilinear transformation in State-Space. This method computes a discrete time equivalent of a continuous-time system, such that</p><pre><code class="nohighlight hljs">G_d(z) = s2z[G_c(s)]</code></pre><p>in a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||<em>2=||C||</em>2   (iii) Satisfies G<em>c(s) = z2s[s2z[G</em>c(s)]] for some map z2s[]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L1010-L1022">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilinearc2d-Tuple{ControlSystems.StateSpace{ControlSystems.Continuous}, Number}" href="#RobustAndOptimalControl.bilinearc2d-Tuple{ControlSystems.StateSpace{ControlSystems.Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilinearc2d(sys::StateSpace, Ts::Number)</code></pre><p>Applies a Balanced Bilinear transformation to a discrete-time statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L1069-L1073">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{ControlSystems.Continuous}, Number}" href="#RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{ControlSystems.Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilinearc2d(sys::ExtendedStateSpace, Ts::Number)</code></pre><p>Applies a Balanced Bilinear transformation to a discrete-time extended statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L1085-L1089">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}" href="#RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilineard2c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilineard2c(Ad::AbstractArray, Bd::AbstractArray, Cd::AbstractArray, Dd::AbstractArray, Ts::Number; tolerance=1e-12)</code></pre><p>Balanced Bilinear transformation in State-Space. This method computes a continuous time equivalent of a discrete time system, such that</p><pre><code class="nohighlight hljs">G_c(z) = z2s[G_d(z)]</code></pre><p>in a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||<em>2=||C||</em>2   (iii) Satisfies G<em>d(z) = s2z[z2s[G</em>d(z)]] for some map s2z[]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L906-L918">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilineard2c-Tuple{ControlSystems.StateSpace}" href="#RobustAndOptimalControl.bilineard2c-Tuple{ControlSystems.StateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilineard2c(sys::StateSpace)</code></pre><p>Applies a Balanced Bilinear transformation to continuous-time statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L957-L961">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilineard2c(sys::ExtendedStateSpace)</code></pre><p>Applies a Balanced Bilinear transformation to continuous-time extended statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L974-L978">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.broken_feedback-Tuple{ControlSystems.LTISystem, Any}" href="#RobustAndOptimalControl.broken_feedback-Tuple{ControlSystems.LTISystem, Any}"><code>RobustAndOptimalControl.broken_feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">broken_feedback(L, i)</code></pre><p>Closes all loops in square MIMO system <code>L</code> except for loops <code>i</code>. Forms L1 in fig 14. of &quot;An Introduction to Disk Margins&quot; https://arxiv.org/abs/2003.04771</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L298-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.closedloop" href="#RobustAndOptimalControl.closedloop"><code>RobustAndOptimalControl.closedloop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closedloop(l::LQGProblem, L = lqr(l), K = kalman(l))</code></pre><p>Closed-loop system as defined in Glad and Ljung eq. 8.28</p><p>The return value will be the closed loop from reference only, other disturbance signals (B1) are ignored. See <code>feedback</code> for a more advanced option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.comp_sensitivity-Tuple" href="#RobustAndOptimalControl.comp_sensitivity-Tuple"><code>RobustAndOptimalControl.comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a></p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L334-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.connect-Tuple{Any}" href="#RobustAndOptimalControl.connect-Tuple{Any}"><code>RobustAndOptimalControl.connect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connect(systems, connections; w1, z1 = (:), verbose = true, kwargs...)</code></pre><p>Create complicated feedback interconnection. </p><p>Addition and subtraction nodes are achieved by creating a linear combination node, i.e., a system with a <code>D</code> matrix only.</p><p><strong>Arguments:</strong></p><ul><li><code>systems</code>: A vector of named systems to be connected</li><li><code>connections</code>: a vector of pairs indicating output =&gt; input mappings.<ul><li><code>u1</code>: input mappings  (alternative input argument)</li><li><code>y1</code>: output mappings (alternative input argument)</li></ul></li><li><code>w1</code>: external signals</li><li><code>z1</code>: outputs (can overlap with <code>y1</code>)</li><li><code>verbose</code>: Issue warnings for signals that have no connection</li></ul><p>Example: The following complicated feedback interconnection</p><pre><code class="nohighlight hljs">                 yF
              ┌────────────────────────────────┐
              │                                │
    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐
uF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP
────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►
    │       │    │       │   ┌──►         │         │       │    │
    └───────┘    └───────┘   │  └─────────┘         └───────┘    │
                             │                                   │
                             └───────────────────────────────────┘</code></pre><p>can be created by</p><pre><code class="nohighlight hljs">F = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)
R = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)
C = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)
P = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)

addP = sumblock(&quot;uP = yF + yC&quot;) # Sum node before P
addC = sumblock(&quot;uC = yR - yP&quot;) # Sum node before C

connections = [
    :yP =&gt; :yP # Output to input
    :uP =&gt; :uP
    :yC =&gt; :yC
    :yF =&gt; :yF
    :yF =&gt; :uR
    :uC =&gt; :uC
    :yR =&gt; :yR
]
w1 = [:uF] # External inputs

G = connect([F, R, C, P, addP, addC], connections; w1)</code></pre><p>If an external input is to be connected to multiple points, use a <code>splitter</code> to split up the signal into a set of unique names which are then used in the connections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/named_systems2.jl#L310-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.controller_reduction" href="#RobustAndOptimalControl.controller_reduction"><code>RobustAndOptimalControl.controller_reduction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">controller_reduction(P, K, r, out=false)</code></pre><p>Minimize    ||(K-Kᵣ) W||∞ if out=false             ||W (K-Kᵣ)||∞ if out=true See Robust and Optimal Control Ch 19.1 out indicates if the weight will be applied as output or input weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/reduction.jl#L75-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.diskmargin" href="#RobustAndOptimalControl.diskmargin"><code>RobustAndOptimalControl.diskmargin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diskmargin(L, σ = 0)
diskmargin(L, σ::Real, ω)</code></pre><p>Calculate the disk margin of LTI system <code>L</code>. <code>L</code> is supposed to be a loop-transfer function, i.e., it should be square. If <code>L = PC</code> the disk margin for output perturbations is computed, whereas if <code>L = CP</code>, input perturbations are considered. If the method <code>diskmargin(P, C, args...)</code> is used, both are computed.</p><p>The implementation and notation follows &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771</p><p>The margins are aviable as fields of the returned objects, see <a href="#RobustAndOptimalControl.Diskmargin"><code>Diskmargin</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>L</code>: A loop-transfer function.</li><li><code>σ</code>: If little is known about the distribution of gain variations then σ = 0 is a reasonable choice as it allows for a gain increase or decrease by the same relative amount. <em>The choice σ &lt; 0</em> is justified if the gain can decrease by a larger factor than it can increase. Similarly, <em>the choice σ &gt; 0</em> is justified when the gain can increase by a larger factor than it can decrease. <em>If σ = −1</em> then the disk margin condition is αmax = inv(MT). This margin is related to the robust stability condition for models with multiplicative uncertainty of the form P (1 + δ). If σ = +1 then the disk margin condition is αmax = inv(MS)</li><li><code>kwargs</code>: Are sent to the <a href="@ref"><code>hinfnorm</code></a> calculation</li><li><code>ω</code>: If a vector of frequencies is supplied, the frequency-dependent disk margin will be computed, see example below.</li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">L = tf(25, [1,10,10,10])
dm = diskmargin(L, 0)
plot(dm) # Plot the disk margin to illustrate maximum allowed simultaneous gain and phase variations.

nyquistplot(L)
plot!(dm, nyquist=true) # plot a nyquist exclusion disk. The Nyquist curve will be tangent to this disk at `dm.ω0`
nyquistplot!(dm.f0*L) # If we perturb the system with the worst-case perturbation `f0`, the curve will pass through the critical point -1.

## Frequency-dependent margin
w = exp10.(LinRange(-2, 2, 500))
dms = diskmargin(L, 0, w)
plot(w, dms)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/diskmargin.jl#L128-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Any, AbstractVector, Vararg{Any}}" href="#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Any, AbstractVector, Vararg{Any}}"><code>RobustAndOptimalControl.diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diskmargin(P::LTISystem, C::LTISystem, σ, w::AbstractVector, args...; kwargs...)</code></pre><p>Simultaneuous diskmargin at outputs, inputs and input/output simultaneously of <code>P</code>.  Returns a named tuple with the fields <code>input, output, simultaneous_input, simultaneous_output, simultaneous</code> where <code>input</code> and <code>output</code> represent loop-at-a-time margins, <code>simultaneous_input</code> is the margin for simultaneous perturbations on all inputs and <code>simultaneous</code> is the margin for perturbations on all inputs and outputs simultaneously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L245-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractArray}" href="#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractArray}"><code>RobustAndOptimalControl.diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diskmargin(L::LTISystem, σ::Real, ω)</code></pre><p>Calculate the diskmargin at a particular frequency or vector of frequencies. If <code>ω</code> is a vector, you get a frequency-dependent diskmargin plot if you plot the returned value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/diskmargin.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}" href="#RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}"><code>RobustAndOptimalControl.expand_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_symbol(s::Symbol, n::Int)</code></pre><p>Takes a symbol and an integer and returns a vector of symbols with increasing numbers appended to the end. E.g., (:x, 3) -&gt; [:x1, :x2, :x3]</p><p>The short-hand syntax <code>s^n</code> is also available, e.g., <code>:x^3 == expand_symbol(:x, 3)</code>.</p><p>Useful to create signal names for named systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/named_systems2.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.extended_controller" href="#RobustAndOptimalControl.extended_controller"><code>RobustAndOptimalControl.extended_controller</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extended_controller(l::LQGProblem, L = lqr(l), K = kalman(l))</code></pre><p>Returns an expression for the controller that is obtained when state-feedback <code>u = -L(xᵣ-x̂)</code> is combined with a Kalman filter with gain <code>K</code> that produces state estimates x̂. The controller is an instance of <code>ExtendedStateSpace</code> where <code>C2 = -L, D21 = L</code> and <code>B2 = K</code>.</p><p>The returned system has <em>inputs</em> <code>[xᵣ; y]</code> and outputs the control signal <code>u</code>. If a reference model <code>R</code> is used to generate state references <code>xᵣ</code>, the controller from <code>e = ry - y -&gt; u</code> is given by</p><pre><code class="language-julia hljs">Ce = extended_controller(l)
Ce = named_ss(Ce; x = :xC, y = :u, u = [R.y; :y^l.ny]) # Name the inputs of Ce the same as the outputs of `R`.
connect([R, Ce]; u1 = R.y, y1 = R.y, w1 = [:ry^l.ny, :y^l.ny], z1=[:u])</code></pre><p>Since the negative part of the feedback is built into the returned system, we have <code>C = observer_controller(l) Ce = extended_controller(l) system_mapping(Ce) == -C</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L205-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.extended_controller-Tuple{ControlSystems.AbstractStateSpace}" href="#RobustAndOptimalControl.extended_controller-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.extended_controller</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extended_controller(K::AbstractStateSpace)</code></pre><p>Takes a controller and returns an <code>ExtendedStateSpace</code> version which has augmented input <code>[r; y]</code> and output <code>y</code> (<code>z</code> output is 0-dim).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any, F}} where {N, F}" href="#RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any, F}} where {N, F}"><code>RobustAndOptimalControl.find_lft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">l = find_lft(sys::StateSpace{&lt;:Any, &lt;:StaticParticles{&lt;:Any, N}}, δ) where N</code></pre><p>Given an systems <code>sys</code> with uncertain coefficients in the form of <code>StaticParticles</code>, find a lower linear fractional transformation <code>M</code> such that <code>lft(M, δ) ≈ sys</code>. </p><p><code>δ</code> can be either the source of uncertainty in <code>sys</code>, i.e., a vector of the unique uncertain parameters that were used to create <code>sys</code>. These should be constructed as uniform randomly distributed particles for most robust-control theory to be applicable.  <code>δ</code> can also be an integer, in which case a numer of <code>δ</code> sources of uncertainty are automatically created. This could be used for order reduction if the number of uncertainty sources in <code>sys</code> is large.</p><p>Note, uncertainty in <code>sys</code> is only supported in <code>A</code> and <code>B</code>, <code>C</code> and <code>D</code> must be deterministic.</p><p>Returns <code>l::LFT</code> that internaly contains all four blocks of <code>M</code> as well as <code>δ</code>. Call <code>ss(l,sys)</code> do obtain <code>lft(M, δ) ≈ sys</code>.</p><p>Call <code>Matrix(l)</code> to obtain <code>M = [M11 M12; M21 M22]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/find_lft.jl#L57-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.frequency_weighted_reduction-NTuple{4, Any}" href="#RobustAndOptimalControl.frequency_weighted_reduction-NTuple{4, Any}"><code>RobustAndOptimalControl.frequency_weighted_reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frequency_weighted_reduction(G, Wo, Wi)</code></pre><p>Find Gr such that ||Wₒ(G-Gr)Wᵢ||∞ is minimized. For a realtive reduction, set Wo = inv(G) and Wi = I.</p><p>Ref: Robust and Optimal Control ch. 7.2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/reduction.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.glover_mcfarlane" href="#RobustAndOptimalControl.glover_mcfarlane"><code>RobustAndOptimalControl.glover_mcfarlane</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">K, γmin = glover_mcfarlane(G::AbstractStateSpace{Continuous}, γ = 1.1)</code></pre><p>Design a controller for <code>G</code> that maximizes the stability margin ϵ = 1/γ with normalized coprime factor uncertainty using the method of Glover and McFarlane</p><pre><code class="nohighlight hljs">γ = 1/ϵ = ||[K;I] inv(I-G*K)*inv(M)||∞
G = inv(M + ΔM)*(N + ΔN)</code></pre><p>γ is given as a relative factor above γmin and must be greater than 1, i.e., if γ = 1.1, the controller will be designed for γ = 1.1*γmin.</p><p>We want γmin ≥ 1 as small as possible, and we usually require that min is less than 4, corresponding to 25% allowed coprime uncertainty.</p><p>Performance modeling is incorporated in the design by calling <code>glover_mcfarlane</code> on the shaped system <code>W2*G*W1</code> and then forming the controller as <code>W1*K*W2</code>. Using this formulation, traditional loop shaping can be done on <code>W2*G*W1</code>.</p><p><strong>Example:</strong></p><p>Example 9.3 from the reference below.</p><pre><code class="language-julia hljs">using RobustAndOptimalControl, ControlSystems, Plots, Test
G = tf(200, [10, 1])*tf(1, [0.05, 1])^2     |&gt; ss
Gd = tf(100, [10, 1])                       |&gt; ss
W1 = tf([1, 2], [1, 1e-6])                  |&gt; ss
Gs = G*W1
Ks, γmin = glover_mcfarlane(Gs, 1.1)
@test γmin ≈ 2.34 atol=0.005

bodeplot([G, Gs, Gs*Ks]) |&gt; display

plot( step(Gd*feedback(1, G*W1), 3))
plot!(step(Gd*feedback(1, G*W1*Ks), 3)) |&gt; display

nyquistplot([G*W1, G*W1*Ks], ylims=(-2,1), xlims=(-2, 1), Ms_circles=1.5) |&gt; display</code></pre><p>Ref: Sec 9.4.1 of Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;</p><p><strong>Extended help</strong></p><p>Skogestad gives the following general advice:</p><ol><li><p>Scale the plant outputs and inputs. This is very important for most design  procedures and is sometimes forgotten. In general, scaling improves the  conditioning of the design problem, it enables meaningful analysis to be made  of the robustness properties of the feedback system in the frequency domain,  and for loop-shaping it can simplify the selection of weights. There are a variety  of methods available including normalization with respect to the magnitude of  the maximum or average value of the signal in question. If one is to go straight to a design the following variation has  proved useful in practice:  (a) The outputs are scaled such that equal magnitudes of cross-coupling into each      of the outputs is equally undesirable.  (b) Each input is scaled by a given percentage (say 10%) of its expected range      of operation. That is, the inputs are scaled to reflect the relative actuator      capabilities. An example of this type of scaling is given in the aero-engine      case study of Chapter 12.</p></li><li><p>Order the inputs and outputs so that the plant is as diagonal as possible. The  relative gain array <a href="@ref"><code>rga</code></a> can be useful here. The purpose of this pseudo-diagonalization  is to ease the design of the pre- and post-compensators which, for simplicity, will  be chosen to be diagonal.</p><p>Next, we discuss the selection of weights to obtain the shaped plant <span>$G_s = W_2 G W_1$</span>  where <span>$W_1 = W_p W_a W_g$</span></p></li><li><p>Select the elements of diagonal pre- and post-compensators <span>$W_p$</span> and <span>$W_2$</span> so that  the singular values of <span>$W_2 G W_p$</span> are desirable. This would normally mean high  gain at low frequencies, roll-off rates of approximately 20 dB/decade (a slope of  about 1) at the desired bandwidth(s), with higher rates at high frequencies. Some  trial and error is involved here. <span>$W_2$</span> is usually chosen as a constant, reflecting the  relative importance of the outputs to be controlled and the other measurements  being fed back to the controller. For example, if there are feedback measurements  of two outputs to be controlled and a velocity signal, then <span>$W_2$</span> might be chosen  to be <code>diag([1, 1, 0.1])</code>, where 0.1 is in the velocity signal channel. <span>$W_p$</span> contains the  dynamic shaping. Integral action, for low frequency performance; phase-advance  for reducing the roll-off rates at crossover, and phase-lag to increase the roll-off  rates at high frequencies should all be placed in <span>$W_p$</span> if desired. The weights should  be chosen so that no unstable hidden modes are created in <span>$G_s$</span>.</p></li><li><p>Optional: Introduce an additional gain matrix <span>$W_g$</span> cascaded with <span>$W_a$</span> to provide  control over actuator usage. <span>$W_g$</span> is diagonal and is adjusted so that actuator rate  limits are not exceeded for reference demands and typical disturbances on the  scaled plant outputs. This requires some trial and error.</p></li><li><p>Robustly stabilize the shaped plant <span>$G_s = W_2 G W_1$</span> , where <span>$W_1 = W_p W_a W_g$</span>,  using <code>glover_mcfarlane</code>. First, the maximum stability  margin <span>$ϵ_{max} = 1/γ_{min}$</span> is calculated. If the margin is too small, <span>$ϵmax &lt; 0.25$</span>, then go back and modify the weights. Otherwise, a γ-suboptimal controller is synthesized. There is usually no advantage to be gained by using the optimal controller. When <span>$ϵ_{max}$</span> &gt; 0.25  (respectively <span>$γ_{min}$</span> &lt; 4) the design is usually successful. In this case, at least  25% coprime factor uncertainty is allowed, and we also find that the shape of the  open-loop singular values will not have changed much after robust stabilization.  A small value of ϵmax indicates that the chosen singular value loop-shapes are  incompatible with robust stability requirements. That the loop-shapes do not  change much following robust stabilization if γ is small (ϵ large), is justified  theoretically in McFarlane and Glover (1990).</p></li><li><p>Analyze the design and if all the specifications are not met make further  modifications to the weights.</p></li><li><p>Implement the controller. The configuration shown in below has been found  useful when compared with the conventional set up. This is because  the references do not directly excite the dynamics of <span>$K$</span>, which can result in large amounts of overshoot (classical derivative kick). The constant prefilter ensures a steady-state gain of 1 between r and y, assuming integral action in <span>$W_1$</span> or <span>$G$</span> (note, the K returned by this function has opposite sign compared to that of Skogestad, so we use negative feedback here).</p></li></ol><p>Anti-windup can be added to <span>$W_1$</span> but putting <span>$W_1$</span> on Hanus form after the synthesis, see <a href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>hanus</code></a>.</p><pre><code class="nohighlight hljs">       ┌─────────┐      ┌────────┐      ┌────────┐
    r  │         │    us│        │  u   │        │  y
   ───►│(K*W2)(0)├──+──►│   W1   ├─────►│   G    ├────┬──►
       │         │  │-  │        │      │        │    │
       └─────────┘  │   └────────┘      └────────┘    │
                    │                                 │
                    │                                 │
                    │   ┌────────┐      ┌────────┐    │
                    │   │        │  ys  │        │    │
                    └───┤   K    │◄─────┤   W2   │◄───┘
                        │        │      │        │
                        └────────┘      └────────┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/glover_mcfarlane.jl#L1-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.h2synthesize" href="#RobustAndOptimalControl.h2synthesize"><code>RobustAndOptimalControl.h2synthesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">K, Cl = h2synthesize(P::ExtendedStateSpace, γ = nothing)</code></pre><p>Synthesize H₂-optimal controller K and calculate the closed-loop transfer function from <code>w</code> to <code>z</code>. Ref: Cha. 14.5 in Robust and Optimal Control.</p><p>If <code>γ = nothing</code>, use the formulas for H₂ in Ch 14.5. If γ is a large value, the H∞ formulas are used. As γ → ∞, these two are equivalent. The h∞ formulas do a coordinate transfromation that handles slightly more general systems so if you run into an error, it might be worth trying setting γ to something large, e.g., 1000.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/h2_design.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hanus-Tuple{Any}" href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>RobustAndOptimalControl.hanus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`Wh` = hanus(W)</code></pre><p>Return <code>Wh</code> on Hanus form. <code>Wh</code> has twice the number of inputs, where the second half of the inputs are &quot;actual inputs&quot;, e.g., potentially saturated. This is used to endow <code>W</code> with anti-windup protection. <code>W</code> must have an invertable <code>D</code> matrix and be minimum phase.</p><p>Ref: Sec 9.4.5 of Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/glover_mcfarlane.jl#L145-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfassumptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flag = hinfassumptions(P::ExtendedStateSpace; verbose=true)</code></pre><p>Check the assumptions for using the γ-iteration synthesis in Theorem 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfpartition-NTuple{4, Any}" href="#RobustAndOptimalControl.hinfpartition-NTuple{4, Any}"><code>RobustAndOptimalControl.hinfpartition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">P = hinfpartition(G, WS, WU, WT)</code></pre><p>Transform a SISO or MIMO system G, with weighting functions WS, WU, WT into and LFT with an isolated controller, and write the resulting system, P(s), on a state-space form. Valid inputs for G are transfer functions (with dynamics, can be both MIMO and SISO, both in tf and ss forms). Valid inputs for the weighting functions are empty arrays, numbers (static gains), and <code>LTISystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L582-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, ControlSystems.LTISystem, ControlSystems.LTISystem}" href="#RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, ControlSystems.LTISystem, ControlSystems.LTISystem}"><code>RobustAndOptimalControl.hinfsignals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hinfsignals(P::ExtendedStateSpace, G::LTISystem, C::LTISystem)</code></pre><p>Use the extended state-space model, a plant and the found controller to extract the closed loop transfer functions operating solely on the state-space.</p><ul><li><code>Pcl : w → z</code> : From input to the weighted functions</li><li><code>S   : w → e</code> : From input to error</li><li><code>CS  : w → u</code> : From input to control</li><li><code>T   : w → y</code> : From input to output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L841-L851">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfsynthesize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flag, K, γ, mats = hinfsynthesize(P::ExtendedStateSpace; maxIter=20, interval=(2/3,20), verbose=true)</code></pre><p>Computes an H-infinity optimal controller K for an extended plant P such that ||F_l(P, K)||∞ &lt; γ for the largest possible γ given P. The routine is known as the γ-iteration, and is based on the paper &quot;State-space formulae for all stabilizing controllers that satisfy an H∞-norm bound and relations to risk sensitivity&quot; by Glover and Doyle. See the Bib-entry below [1] above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/hinfinity_design.jl#L112-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hsvd-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}}" href="#RobustAndOptimalControl.hsvd-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}}"><code>RobustAndOptimalControl.hsvd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hsvd(sys::AbstractStateSpace{Continuous})</code></pre><p>Return the Hankel singular values of <code>sys</code>, computed as the eigenvalues of <code>QP</code> Where <code>Q</code> and <code>P</code> are the Gramians of <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/reduction.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}" href="#RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.input_comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_comp_sensitivity(P,C)
input_comp_sensitivity(l::LQGProblem)</code></pre><p>Transfer function from load disturbance to control signal.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case controller output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L400-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}" href="#RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.input_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_sensitivity(P, C)
input_sensitivity(l::LQGProblem)</code></pre><p>Transfer function from load disturbance to total plant input.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L369-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}" href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loop_diskmargin(P, C, args...; kwargs...)</code></pre><p>Calculate the loop-at-a-time diskmargin for each output and input of <code>P</code>. See also <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>, <a href="#RobustAndOptimalControl.sim_diskmargin"><code>sim_diskmargin</code></a>. Ref: &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L284-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, Vararg{Any}}" href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loop_diskmargin(L, args...; kwargs...)</code></pre><p>Calculate the loop-at-a-time diskmargin for each output of <code>L</code>.</p><p>See also <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>, <a href="#RobustAndOptimalControl.sim_diskmargin"><code>sim_diskmargin</code></a>. Ref: &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L268-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}" href="#RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}"><code>RobustAndOptimalControl.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure(s::NamedStateSpace, names)</code></pre><p>Return a system with specified states as measurement outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/named_systems2.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T" href="#RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.named_ss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">named_ss(sys::AbstractStateSpace{T}; x, u, y)</code></pre><p>Create a <code>NamedStateSpace</code> system. This kind of system uses names rather than integer indices to refer to states, inputs and outputs</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: A system to add names to.</li><li><code>x</code>: A list of symbols with names of the states.</li><li><code>u</code>: A list of symbols with names of the inputs.</li><li><code>y</code>: A list of symbols with names of the outputs.</li></ul><p>Default names of signals if none are provided are <code>x,u,y</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">G1 = ss(1,1,1,0)
G2 = ss(1,1,1,0)
s1 = named_ss(G1, x = :x, u = :u1, y=:y1)
s2 = named_ss(G2, x = :z, u = :u2, y=:y2)

s1[:y1, :u1] # Index using symbols

fb = feedback(s1, s2, r = :r) # </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/named_systems2.jl#L96-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.noise_mapping-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.noise_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.noise_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noise_mapping(P::ExtendedStateSpace)</code></pre><p>Return the system from w -&gt; y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/ExtendedStateSpace.jl#L515-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}" href="#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.output_comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_comp_sensitivity(P,C)
output_comp_sensitivity(l::LQGProblem)</code></pre><p>Transfer function from measurement noise / reference to plant output.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case plant output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L414-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}" href="#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.output_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_sensitivity(P, C)
output_sensitivity(l::LQGProblem)</code></pre><p>Transfer function from measurement noise / reference to control signal.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L383-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}" href="#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition(P::AbstractStateSpace; u, y, w=!u, z=!y)</code></pre><p>Partition <code>P</code> into an <a href="@ref"><code>ExtendedStateSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/ExtendedStateSpace.jl#L465-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.performance_mapping-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.performance_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.performance_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">performance_mapping(P::ExtendedStateSpace)</code></pre><p>Return the system from w -&gt; z</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/ExtendedStateSpace.jl#L506-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}" href="#RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}"><code>RobustAndOptimalControl.robstab</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">robstab(M0::UncertainSS, w=exp10.(LinRange(-3, 3, 1500)); kwargs...)</code></pre><p>Return the robust stability margin of an uncertain model, defined as the inverse of the structured singular value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sensitivity-Tuple" href="#RobustAndOptimalControl.sensitivity-Tuple"><code>RobustAndOptimalControl.sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a></p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/lqg.jl#L326-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sim_diskmargin" href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_diskmargin(L, σ::Real = 0)</code></pre><p>Return the smallest simultaneous diskmargin over the grid 1e-3:1e3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sim_diskmargin" href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_diskmargin(P::LTISystem, C::LTISystem, σ::Real = 0)</code></pre><p>Simultaneuous diskmargin at both outputs and inputs of <code>P</code>. Ref: &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L222-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sim_diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractVector}" href="#RobustAndOptimalControl.sim_diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractVector}"><code>RobustAndOptimalControl.sim_diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_diskmargin(L, σ::Real, w::AbstractVector)
sim_diskmargin(L, σ::Real = 0)</code></pre><p>Simultaneuous diskmargin at the outputs of <code>L</code>.  Uses should consider using <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L204-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.specificationplot" href="#RobustAndOptimalControl.specificationplot"><code>RobustAndOptimalControl.specificationplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">specificationplot([S,CS,T], [WS,WU,WT])</code></pre><p>This function visualizes the control synthesis using the hInf_synthesize with the three weighting functions {WS(jω), WU(jω), WT(jω)} inverted and scaled by γ, against the corresponding transfer fucntions {S(jω), C(jω)S(jω), T(jω)}, to verify visually that the specifications are met. This may be run using both MIMO and SISO systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/plotting.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.structured_singular_value-Tuple{UncertainSS, AbstractVector}" href="#RobustAndOptimalControl.structured_singular_value-Tuple{UncertainSS, AbstractVector}"><code>RobustAndOptimalControl.structured_singular_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">structured_singular_value(M0::UncertainSS, [w::AbstractVector]; kwargs...)</code></pre><ul><li><code>w</code>: Frequency vector, if none is provided, the maximum μ over a brid 1e-3 : 1e3 will be returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T" href="#RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.structured_singular_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">μ = structured_singular_value(M; tol=1e-4)</code></pre><p>Compute (an upper bound of) the structured singular value μ for diagonal Δ of complex perturbations (other structures of Δ are not yet supported). <code>M</code> is assumed to be an (n × n × N_freq) array or a matrix.</p><p>We currently don&#39;t have any methods to compute a lower bound, but if all perturbations are complex the spectral radius <code>ρ(M)</code> is always a lower bound (usually not a good one).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/mimo_diskmargin.jl#L133-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sumblock-Tuple{String}" href="#RobustAndOptimalControl.sumblock-Tuple{String}"><code>RobustAndOptimalControl.sumblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sumblock(ex::String; Ts = 0, n = 1)</code></pre><p>Create a summation node that sums (or subtracts) vectors of length <code>n</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>Ts</code>: Sample time</li><li><code>n</code>: The length of the input and output vectors. Set <code>n=1</code> for scalars.</li></ul><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; sumblock(&quot;uP = vf + yL&quot;)
NamedStateSpace{Continuous, Int64}
D = 
 1  1

With state  names: 
     input  names: vf yL
     output names: uP


julia&gt; sumblock(&quot;x_diff = xr - xh&quot;; n=3)
NamedStateSpace{Continuous, Int64}
D = 
 1  0  0  -1   0   0
 0  1  0   0  -1   0
 0  0  1   0   0  -1

With state  names: 
     input  names: xr1 xr2 xr3 xh1 xh2 xh3
     output names: x_diff1 x_diff2 x_diff3
     

julia&gt; sumblock(&quot;a = b + c - d&quot;)
NamedStateSpace{Continuous, Int64}
D = 
 1  1  -1

With state  names: 
     input  names: b c d
     output names: a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/named_systems2.jl#L411-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.system_mapping-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.system_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.system_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">system_mapping(P::ExtendedStateSpace)</code></pre><p>Return the system from u -&gt; y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/ExtendedStateSpace.jl#L497-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.uss" href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uss(d::AbstractVector{&lt;:δ}, Ts = nothing)</code></pre><p>Create a diagonal uncertain statespace object with the uncertain elements <code>d</code> on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/uncertainty_interface.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.uss" href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uss(D::AbstractArray, Δ, Ts = nothing)</code></pre><p>If only a single <code>D</code> matrix is provided, it&#39;s treated as <code>D11</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/uncertainty_interface.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.uss" href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uss(D11, D12, D21, D22, Δ, Ts = nothing)</code></pre><p>Create an uncertain statespace object with only gin matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/uncertainty_interface.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}" href="#RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uss(d::δ{C, F}, Ts = nothing)</code></pre><p>Convert a δ object to an UncertainSS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/uncertainty_interface.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.δc" href="#RobustAndOptimalControl.δc"><code>RobustAndOptimalControl.δc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">δr(val::Real = 0.0, radius::Real = 1.0, name)</code></pre><p>Create a complex, uncertain parameter. If no name is given, a boring name will be generated automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/uncertainty_interface.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.δr" href="#RobustAndOptimalControl.δr"><code>RobustAndOptimalControl.δr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">δr(val::Real = 0.0, radius::Real = 1.0, name)</code></pre><p>Create a real, uncertain parameter. If no name is given, a boring name will be generated automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/830bed726a915bcba5249c9b8b41df5af0315451/src/uncertainty_interface.jl#L20-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="uncertainty/">Uncertainty modeling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 30 December 2021 12:57">Thursday 30 December 2021</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
