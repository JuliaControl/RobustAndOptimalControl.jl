<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Control design for a pendulum on a cart · RobustAndOptimalControl Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RobustAndOptimalControl Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../uncertainty/">Uncertainty modeling</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../hinf_DC/">Simple mixed-sensitivity <span>$H_\infty$</span> design</a></li><li><a class="tocitem" href="../hinf_connection/">General <span>$H_\infty$</span> design</a></li><li><a class="tocitem" href="../lqg_disturbance/">LQG control with integral action</a></li><li class="is-active"><a class="tocitem" href>Control design for a pendulum on a cart</a><ul class="internal"><li><a class="tocitem" href="#System-model"><span>System model</span></a></li><li><a class="tocitem" href="#Linearization"><span>Linearization</span></a></li><li><a class="tocitem" href="#Control-design"><span>Control design</span></a></li><li><a class="tocitem" href="#PID-controller"><span>PID controller</span></a></li><li><a class="tocitem" href="#Pole-placement-and-observer-design"><span>Pole placement and observer design</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../measurable_disturbance/"><span>$H_2$</span> design with a known disturbance</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Control design for a pendulum on a cart</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Control design for a pendulum on a cart</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/docs/src/cartpole.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Control-design-for-a-pendulum-on-a-cart"><a class="docs-heading-anchor" href="#Control-design-for-a-pendulum-on-a-cart">Control design for a pendulum on a cart</a><a id="Control-design-for-a-pendulum-on-a-cart-1"></a><a class="docs-heading-anchor-permalink" href="#Control-design-for-a-pendulum-on-a-cart" title="Permalink"></a></h1><p>In this example we will consider control design for the basic inverted pendulum on a cart. This system has two equilibria, one where the pendulum is hanging straight down, and one where it&#39;s balancing straight up. The upper one is unstable, making it slightly more interesting to design a controller for (even if the lower equilibrium is highly relevant, it&#39;s a good model for an overhead crane moving goods).</p><h2 id="System-model"><a class="docs-heading-anchor" href="#System-model">System model</a><a id="System-model-1"></a><a class="docs-heading-anchor-permalink" href="#System-model" title="Permalink"></a></h2><p>In this tutorial, we assume that we have the nonlinear dynamics of the system encodeed as a julia function <code>ẋ = cartpole(x, u)</code>, and linearize this to get a statespace system</p><p class="math-container">\[\begin{aligned}
ẋ &amp;= Ax + Bu\\
y &amp;= Cx
\end{aligned}\]</p><p>We make use of <a href="https://github.com/JuliaDiff/ForwardDiff.jl/">ForwardDiff.jl</a> for the linearization. We start by defining the dynamics function</p><pre><code class="language- hljs">using ControlSystemsBase, RobustAndOptimalControl, ForwardDiff, LinearAlgebra, Plots
default(label=&quot;&quot;) # hide

function cartpole(x, u)
    mc, mp, l, g = 1.0, 0.2, 0.5, 9.81

    q  = x[1:2]
    qd = x[3:4]

    s = sin(q[2])
    c = cos(q[2])

    H = [mc+mp mp*l*c; mp*l*c mp*l^2]
    C = [0.1 -mp*qd[2]*l*s; 0 0]
    G = [0, mp * g * l * s]
    B = [1, 0]

    qdd = -H \ (C * qd + G - B * u[1])
    return [qd; qdd]
end

nu = 1    # number of control inputs
nx = 4    # number of states
ny = 2    # number of outputs (here we assume that the cart position and the pendulum angle are measurable)
nothing # hide</code></pre><h2 id="Linearization"><a class="docs-heading-anchor" href="#Linearization">Linearization</a><a id="Linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Linearization" title="Permalink"></a></h2><p>The next step is to choose an operating point around which to linearize and to calculate the Jacobians <span>$A$</span> and <span>$B$</span>:</p><pre><code class="language- hljs">x0 = [0, π, 0, 0]
u0 = [0]

Ac = ForwardDiff.jacobian(x-&gt;cartpole(x, u0), x0)
Bc = ForwardDiff.jacobian(u-&gt;cartpole(x0, u), u0)
Cc = [1 0 0 0; 0 1 0 0]
Λ = Diagonal([0.4, deg2rad(25)]) # Maximum output ranges
Cc = Λ\Cc # This normalizes expected outputs to be ∈ [-1, 1], a good practice for MIMO systems
nothing # hide</code></pre><p>we package everything into a <a href="@ref"><code>StateSpace</code></a> object and visualize its poles and zeros:</p><pre><code class="language- hljs">sys = ss(Ac, Bc, Cc, 0)</code></pre><pre><code class="language- hljs">pzmap(sys)</code></pre><h2 id="Control-design"><a class="docs-heading-anchor" href="#Control-design">Control design</a><a id="Control-design-1"></a><a class="docs-heading-anchor-permalink" href="#Control-design" title="Permalink"></a></h2><p>We will design a number of different controllers. We will start with a basic PID controller. Since the PID controller in its standard form really only handles SISO systems, we will also design a state-feedback controller with an observer to estimate the full state vector <span>$x$</span> based on the two measurements <span>$y$</span>. Lastly, we will attempt to &quot;robustify&quot; the state-feedback controller using the <a href="../api/#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a> procedure.</p><p>Since the system has an unstable pole <span>$p \approx 4.85$</span>rad/s, there wil be fundamental limitations on the performance of the closed loop system. A common rule-of-thumb (see, e.g., Åström and Murray) is that a single RHP pole <span>$p$</span> puts a <em>lower</em> limit on the gain crossover frequency <span>$\omega_{gc} &gt; 2p$</span>, something to take into consideration when tuning our controllers. </p><h2 id="PID-controller"><a class="docs-heading-anchor" href="#PID-controller">PID controller</a><a id="PID-controller-1"></a><a class="docs-heading-anchor-permalink" href="#PID-controller" title="Permalink"></a></h2><p>Since the PID controller only accepts a single measurement, we choose the measurement of the pendulum angle for feedback. While doing so, we notice that the number of states in the model can be reduced by the function <a href="https://juliacontrol.github.io/ControlSystemsBase.jl/latest/lib/synthesis/#ControlSystemsBase.sminreal-Tuple{StateSpace}"><code>sminreal</code></a></p><pre><code class="language- hljs">P = sminreal(sys[2,1]) # Position state goes away, not observable</code></pre><p>this indicates that the state corresponding to the position of the cart is not observable from the measurement of the pendulum angle. This is slightly worrisome, but we nevertheless proceed to design a controller. By using a single measurement only, we have also introduced a zero in the system</p><pre><code class="language- hljs">pzmap(P)</code></pre><p>A PID controller can be constructed using the function <a href="https://juliacontrol.github.io/ControlSystemsBase.jl/latest/lib/synthesis/#ControlSystemsBase.pid-Tuple{}"><code>pid</code></a>. We start our tuning by a simple P controller</p><pre><code class="language- hljs">C = pid(1, 0, 0)</code></pre><p>We will attempt to perform loop shaping using the PID controller, and plot the stability margins in a Bode plot using the function <code>marginplot</code></p><pre><code class="language- hljs">w = exp10.(LinRange(-2.5, 3, 500))
function pid_marginplot(C)
    f1 = marginplot(P*C, w)
    vline!([2*4.85], sp=1, lab=&quot;Fundamental limitation&quot;, l=(:dash, :black))
    ylims!((1e-3, 1e2), sp=1)
    f2 = nyquistplot(P*C)
    plot(f1, f2)
end
pid_marginplot(C)</code></pre><p>We notice that the gain of the loop-transfer function <span>$L = PC$</span> is much too low, and increase it, we also notice that the Nyquist plot fails to encircle to critical point, which it has to do once since we have one unstable pole. We will solve this in the end by adding integral action, but proceed for now to shape other parts of the loop. We start by lifting the Bode curve by increasing the gain:</p><pre><code class="language- hljs">C = pid(20, 0, 0)
pid_marginplot(C)</code></pre><p>we are now getting close to the rule-of-thumb for <span>$\omega_{gc}$</span>, but have a low loop gain at low frequencies. Remember, to get good disturbance rejection, we typically want a high loop gain at low frequencies. We also have an extremely small phase margin at 0.66 degrees. To fix the phase margin, we add some derivative gain. While adding derivative gain, it&#39;s also a good idea to add noise filtering (with a pure derivative term, the PID controller is not proper and can not be realized as a statespace system)</p><pre><code class="language- hljs">C = pid(20, 0, 0.2, Tf=0.01)
pid_marginplot(C)</code></pre><p>The derivative term lifted the phase at <span>$\omega_{gc}$</span> and we now have very nice phase margins. We also got a slight increase in <span>$\omega_{gc}$</span> while at it. </p><p>The closed-loop system will still be unstable since the Nyquist curve fails to encircle the point -1, something we can check by calling</p><pre><code class="language- hljs">isstable(feedback(P*C))</code></pre><p>We make the Nyquist curve wrap around the -1 point by adding integral gain:</p><pre><code class="language- hljs">C = pid(20, 1.25, 0.2, Tf=0.01)
pid_marginplot(C)</code></pre><p>Now, the Nyquist curve looks fine and the system is stable</p><pre><code class="language- hljs">isstable(minreal(feedback(P*C)))</code></pre><p>If we simulate a disturbance acting on this system (<code>feedback(P, C)</code> is the transfer function from load disturbance to output)</p><pre><code class="language- hljs">plot(step(feedback(P,C), 8), ylab=&quot;ϕ&quot;)</code></pre><p>we see that we have a reasonable disturbance response. </p><p>To verify robustness properties, we plot the gang-of-four sensitivity functions:</p><pre><code class="language- hljs">f1 = gangoffourplot(P,C,w, Ms_lines=[1.4], Mt_lines=[1.5])
f2 = nyquistplot(P*C, Ms_circles=[1.4], Mt_circles=[1.5], ylims=(-2, 2), xlims=(-4,1))
plot(f1, f2, size=(1000,800))</code></pre><p>This all looks nice and we appear to have reasonable robustness margins, the Nyquist curve stays outside the <span>$M_S = 1.4$</span> circle and the <span>$M_T = 1.5$</span> circle.</p><p>However, there is a dragon lurking behind these plots. Remember the state corresponding the the cart position that was removed above? What has happened to this state? To investigate this, we form an <a href="../api/#RobustAndOptimalControl.ExtendedStateSpace"><code>ExtendedStateSpace</code></a> model where we have both cart position and pendulum angle as controlled outputs, while keeping only the pendulum angle as measured output:</p><pre><code class="language- hljs">Pe = ExtendedStateSpace(sys, C2 = sys.C[2:2, :]) # Indicate that we can only measure the pendulum angle
Gecl = feedback(Pe, ss(C)) |&gt; minreal
plot(step(Gecl, 8), ylab=[&quot;Cart pos&quot; &quot;ϕ&quot;])</code></pre><p>We see that the cart position drifts away without ever thinking about stopping. Indeed, the PID controller is unaware of this and can not really do anything about it. We could attempt to design a second control loop that would close the loop around the cart position, but we would have to carefully manage the interactions between the two loops. Instead, we move on to a state-feedback design, a methodology that makes handling multiple outputs much more straightforward. </p><h2 id="Pole-placement-and-observer-design"><a class="docs-heading-anchor" href="#Pole-placement-and-observer-design">Pole placement and observer design</a><a id="Pole-placement-and-observer-design-1"></a><a class="docs-heading-anchor-permalink" href="#Pole-placement-and-observer-design" title="Permalink"></a></h2><p>The design of a state-feedback controller typically involves two steps, designing the feedback gain and designing an observer. We will arrive at the feedback gain through pole placement, but will design the observer as a Kalman filter, i.e., by solving a Riccati equation rather than using Ackermann&#39;s formula. </p><p>When performing pole placement, there are a number of design guidlines that help you arrive at a robust design. One of these are that past process poles should be matched with an equally fast closed-loop pole. We can get an overview of the open-loop poles with <code>dampreport</code></p><pre><code class="language- hljs">dampreport(sys)</code></pre><p>we see that we have two poles at roughly <span>$\pm 4.85$</span>rad/s, and almost two integrators. We thus keep the fast pole, and place the unstable pole at the same location (same bandwidth but stable instead of unstable). We also try to move the integrator poles to -5 to make the system nice and fast. </p><pre><code class="language- hljs">desired_poles = [-4.85, -4.85, -5, -5]
L = place(sys, desired_poles, :c)</code></pre><p>For the observer, we make use of the function <code>kalman</code>. We choose the covariance matrices <code>R1, R2</code> that determine the amount of noise acting on the system and on the measurements respectively. We assume that there are two noise components, both entering as forces. One disturbance force acts on the cart and the other on the pendulum. We indicate this using the matrix <span>$B_w$</span>. </p><pre><code class="language- hljs">Bw = [0 0; 0 0; 1 0; 0 1]
R1 = Bw*I(2)*Bw&#39;
R2 = 0.0001I(ny)
K = kalman(sys, R1, R2)</code></pre><p>With our feedback gain <code>L</code> and the Kalman gain <code>K</code>, we form the controller using <a href="@ref"><code>observer_controller</code></a></p><pre><code class="language- hljs">controller = observer_controller(sys, L, K)
@assert isstable(controller)
@assert isstable(feedback(sys * controller))</code></pre><p>We may have a look at the Nyquist plot and the gang-of-four to assess robustness margins. In this case we look at the loop transfer function at the input simply because this function is SISO while the standard output-loop transfer is MIMO. This will allow us to asses robustness w.r.t. input perturbations only</p><pre><code class="language- hljs">nyquistplot(controller*sys, w, Ms_circles=[2.7], Mt_circles=[3], xlims=(-2, 2), ylims=(-1, 3))</code></pre><p>The Nyquist plot shows a rather weak robustness margin, with a peak in the input sensitivity of about</p><pre><code class="language- hljs">round(hinfnorm2(input_sensitivity(sys, controller))[1], digits=2) # hide</code></pre><p>and a peak in the complementary sensitivity function of around</p><pre><code class="language- hljs">round(hinfnorm2(input_comp_sensitivity(sys, controller))[1], digits=2) # hide</code></pre><p>These can be verified by calling <a href="../api/#RobustAndOptimalControl.hinfnorm2-Tuple{ControlSystemsBase.LTISystem}"><code>hinfnorm2</code></a></p><pre><code class="language- hljs">hinfnorm2(input_comp_sensitivity(sys, controller))</code></pre><div class="admonition is-info"><header class="admonition-header">Hover information</header><div class="admonition-body"><p>If you plot with the Plotly backend, activated by calling <code>plotly()</code> if you have Plotly.jl installed, you can hover the mouse over the Nyquist curve and the gain circles to see frequency information etc. This is not possible when using the default GR backend, used in this documentation.</p></div></div><p>Also the gang-of-four indicate rather poor margins:</p><pre><code class="language- hljs">gangoffourplot(sys, controller, w, xlabel=&quot;&quot;, sigma=false, titlefont=8)</code></pre><h3 id="Robustification-using-Glover-McFarlane"><a class="docs-heading-anchor" href="#Robustification-using-Glover-McFarlane">Robustification using Glover-McFarlane</a><a id="Robustification-using-Glover-McFarlane-1"></a><a class="docs-heading-anchor-permalink" href="#Robustification-using-Glover-McFarlane" title="Permalink"></a></h3><p>In an attempt at improving this initial design, we call <a href="../api/#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a>. This can be seen as a semi-automatic approach to robustifying an initial design, and will yield us an updated controller <code>Kgmf</code> with, hopefully, improved robustness properties.</p><pre><code class="language- hljs">Kgmf, γ, info = glover_mcfarlane(sys, 1.05; W1=controller)
@assert isstable(Kgmf)
γ</code></pre><p>The γ is an indication of the achieved robustness. A value of <span>$γ &lt; 4$</span> is typically desired, this time we did not quite achieve that, but will nevertheless proceed and look deeper into the robustness using other means.</p><div class="admonition is-info"><header class="admonition-header">Controller order reduction</header><div class="admonition-body"><p>The Glover-McFarlane procedure often leads to high-order controllers. These controllers can sometimes be simplified by calling <a href="../api/#RobustAndOptimalControl.controller_reduction"><code>controller_reduction</code></a>, i.e., like this</p><pre><code class="language- hljs">Kgmfr, hs = controller_reduction(ExtendedStateSpace(sys), -Kgmf, 9) # Expects positive-feedback controller
Kgmfr = -Kgmfr # Flip sign again
Kgmfr.D .*= 0.0 # a hack to get better rolloff after reduction
nothing # hide</code></pre></div></div><h3 id="Robustness-verification"><a class="docs-heading-anchor" href="#Robustness-verification">Robustness verification</a><a id="Robustness-verification-1"></a><a class="docs-heading-anchor-permalink" href="#Robustness-verification" title="Permalink"></a></h3><p>We will now verify these designs in a number of ways. We start by inspecting sensitivity functions at the input, this function tells you how a load disturbance at the plant input translates to total plant input (including control action)</p><pre><code class="language- hljs">f1 = bodeplot([controller*sys, Kgmf*sys], w, plot_title=&quot;Input Loop transfers&quot;, lab=[&quot;Pole placement&quot; &quot;&quot; &quot;GMF&quot; &quot;&quot;]); vline!([2*4.85], sp=1, lab=&quot;Fundamental limitation&quot;, l=(:dash, :black))
f2 = nyquistplot([controller*sys, Kgmf*sys], xlims=(-4, 4), ylims=(-1, 5), Ms_circles=[2.7], Mt_circles=[3], lab=[&quot;Pole placement&quot; &quot;GMF&quot;])
f3 = bodeplot(controller, w, lab=&quot;Pole placement&quot;)
bodeplot!(Kgmf, w, plot_title=&quot;Controllers&quot;, lab=&quot;GMF&quot;, legend=:bottomleft)
f4 = sigmaplot([
    input_sensitivity(sys, controller),
    input_sensitivity(sys, Kgmf)
    ], w, title=&quot;Input S&quot;, lab=[&quot;Pole placement&quot; &quot;GMF&quot;], legend=:bottomright)
plot(f1,f2,f3,f4, size=(1000,1000))</code></pre><p>We see that the Glover-Mcfarlane method increased the gain crossover frequency <span>$\omega_{gc}$</span> slightly compared to the initial pole-placement controller, as well as lifted the phase even further. It also increased the roll-off, providing better filtering of high-frequency noise. However, it uses quite a bit more gain from the measurement of the pendulum angle.</p><p>The gang-of-four, shown below, looks slightly better for the GMF controller, shown in orange.</p><pre><code class="language- hljs">gangoffourplot(sys, [controller, Kgmf], w, xlabel=&quot;&quot;, sigma=false, titlefontsize=8)</code></pre><p>The robustified controller has better disturbance rejection (<span>$P/(I + PC)$</span>) and slightly lower peaks in the sensitivity and complementary sensitivity functions.</p><p>Inspecting the singular values of the output sensitivity, we see that the GMF controller reduces the peak and improves the disturbance rejection for the lower singular value, while leaving the upper singular value more or less where it is for low frequencies.</p><pre><code class="language- hljs">sigmaplot(sensitivity.(Ref(sys), [controller, Kgmf]), w, lab=[&quot;Pole placement&quot; &quot;GMF&quot;], legend=:bottomright)</code></pre><p>Further verification of robustness properties can be conducted by inspecting the diskmargins at inputs and at outputs</p><pre><code class="language- hljs">dmf1 = plot(diskmargin(sys*controller), title=&quot;Simultaneous Output diskmargin&quot;, lab=&quot;Pole placement&quot;)
dmf2 = plot(diskmargin(controller*sys), title=&quot;Input diskmargin&quot;, lab=&quot;Pole placement&quot;)
plot!(dmf1, diskmargin(sys*Kgmf), title=&quot;Simultaneous Output diskmargin&quot;, lab=&quot;GMF&quot;)
plot!(dmf2, diskmargin(Kgmf*sys), title=&quot;Input diskmargin&quot;, lab=&quot;GMF&quot;)
plot(dmf1, dmf2)</code></pre><p>With the robustified controller, ee can tolerate a gain variation of about 1.6 at the plant input, but only 1.23 at the plant output. Please note that simultaneous margins can be quite conservative, it&#39;s much less likely that both outputs have equally large gain errors at the same time. One can also investigate the margins for one loop at a time using <a href="../api/#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystemsBase.LTISystem, ControlSystemsBase.LTISystem, Vararg{Any}}"><code>loop_diskmargin</code></a>.</p><h3 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h3><p>Finally, it&#39;s time to simulate the system. First we simulate the response to a reference step for the cart position:</p><pre><code class="language- hljs">plot([
    step(feedback(sys*controller)[:, 1], 8),
    step(feedback(sys*Kgmf)[:, 1], 8),
], ylab=[&quot;Pos&quot; &quot;Angle&quot;], plot_title=&quot;Position command step response&quot;, lab=[&quot;Pole placement&quot; &quot;&quot; &quot;GMF&quot; &quot;&quot;], legend=:bottomright)</code></pre><p>Then we simulate the response to an impulsive disturbance acting on the cart (i.e., someone hit it with a hammer)</p><pre><code class="language- hljs">plot([
    impulse(feedback(sys, controller), 8),
    impulse(feedback(sys, Kgmf), 8),
], ylab=[&quot;Pos&quot; &quot;Angle&quot;], plot_title=&quot;Disturbance step response&quot;, lab=[&quot;Pole placement&quot; &quot;&quot; &quot;GMF&quot; &quot;&quot;], legend=:bottomright)</code></pre><p>This time, the controllers control also the cart position while keeping the pendulum stabilized. </p><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>We started out designing a PID controller and used the Bode plot to guide the tuning. While we ended up with a controller with good robustness margins, we had completely forgotten about the cart position and the controller turned out to not stabilize this &quot;hidden state&quot;. We include this example here as an example of following a mostly sound procedure, leading to a robust controller, but failing to meet real-world constraints due to lack of observability.</p><p>The loop-shaping procedure yielded a controller that stabilized all states of the plant, but with questionable robustness margins. In practice, pole placement can be rather difficult and it&#39;s not always obvious where to place the poles to achieve a robust design. In this case, a robust design is very hard to achieve with a pole-placement controller without model augmentation, the poor robustness of the pole-placement controller compared to the PID controller is due to the low gain at low frequencies, indeed, the pole placement controller lacks integral action! See <a href="../lqg_disturbance/#Disturbance-modeling-and-rejection-with-LQG-controllers">Disturbance modeling and rejection with LQG controllers</a> for a tutorial on how to add integral action to state-feedback controllers by augmenting the system model with a disturbance model.</p><p>We looked at several different ways of quantifying robustness of a system with multiple outputs, and tried our luck with a procedure for automatic robustification, <a href="../api/#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a>. In this case, the procedure worked and we got a slightly more robust controller as a result, this controller also increased the gain for low frequencies significantly, further indicating that the low-frequency gain was a source of problems for the pole-placement controller. The result of the Glover-McFarlane procedure may either be used directly as the final controller, or to provide insight into how the procedure modifies the existing controller in order to improve robustness.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lqg_disturbance/">« LQG control with integral action</a><a class="docs-footer-nextpage" href="../measurable_disturbance/"><span>$H_2$</span> design with a known disturbance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 11 September 2022 15:59">Sunday 11 September 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
