<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · RobustAndOptimalControl Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>RobustAndOptimalControl Documentation</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Named-systems"><span>Named systems</span></a></li><li class="toplevel"><a class="tocitem" href="#Connecting-systems-together"><span>Connecting systems together</span></a></li><li class="toplevel"><a class="tocitem" href="#Model-augmentation"><span>Model augmentation</span></a></li><li class="toplevel"><a class="tocitem" href="#H_\\infty-and-H_2-design"><span><span>$H_\infty$</span> and <span>$H_2$</span> design</span></a></li><li class="toplevel"><a class="tocitem" href="#LQG-design"><span>LQG design</span></a></li><li class="toplevel"><a class="tocitem" href="#Structured-singular-value-and-diskmargin"><span>Structured singular value and diskmargin</span></a></li><li class="toplevel"><a class="tocitem" href="#Closed-loop-analysis"><span>Closed-loop analysis</span></a></li><li class="toplevel"><a class="tocitem" href="#Exported-functions-and-types"><span>Exported functions and types</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="uncertainty/">Uncertainty modeling</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RobustAndOptimalControl.jl"><a class="docs-heading-anchor" href="#RobustAndOptimalControl.jl">RobustAndOptimalControl.jl</a><a id="RobustAndOptimalControl.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RobustAndOptimalControl.jl" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="language-julia hljs">pkg&gt; add RobustAndOptimalControl</code></pre><h1 id="Named-systems"><a class="docs-heading-anchor" href="#Named-systems">Named systems</a><a id="Named-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Named-systems" title="Permalink"></a></h1><p>See <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/examples/complicated_feedback.jl">complicated-feedback example</a></p><ul><li><a href="#RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T"><code>named_ss</code></a></li></ul><h1 id="Connecting-systems-together"><a class="docs-heading-anchor" href="#Connecting-systems-together">Connecting systems together</a><a id="Connecting-systems-together-1"></a><a class="docs-heading-anchor-permalink" href="#Connecting-systems-together" title="Permalink"></a></h1><p>See <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/examples/complicated_feedback.jl">complicated-feedback example</a></p><ul><li><a href="#RobustAndOptimalControl.connect-Tuple{Any}"><code>connect</code></a></li></ul><p>The following complicated feedback interconnection</p><pre><code class="nohighlight hljs">                 yF
              ┌────────────────────────────────┐
              │                                │
    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐
uF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP
────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►
    │       │    │       │   ┌──►         │         │       │    │
    └───────┘    └───────┘   │  └─────────┘         └───────┘    │
                             │                                   │
                             └───────────────────────────────────┘</code></pre><p>can be created by</p><pre><code class="language-julia hljs">F = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)
R = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)
C = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)
P = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)

addP = sumblock(&quot;uP = yF + yC&quot;) # Sum node before P
addC = sumblock(&quot;uC = yR - yP&quot;) # Sum node before C (drawn as two arrows into C in the diagram)

connections = [
    :yP =&gt; :yP # Output to input
    :uP =&gt; :uP # addP&#39;s output is called the same as P&#39;s input
    :yC =&gt; :yC
    :yF =&gt; :yF
    :yF =&gt; :uR
    :uC =&gt; :uC
    :yR =&gt; :yR
]
w1 = [:uF] # External inputs

G = connect([F, R, C, P, addP, addC], connections; w1)</code></pre><p>If an external input is to be connected to multiple points, use a <code>splitter</code> to split up the signal into a set of unique names which are then used in the connections.</p><h1 id="Model-augmentation"><a class="docs-heading-anchor" href="#Model-augmentation">Model augmentation</a><a id="Model-augmentation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-augmentation" title="Permalink"></a></h1><p>TODO.</p><p>Add disturbance and performance models to your system model.</p><ul><li><a href="#RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>add_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}"><code>add_measurement_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_input_differentiator"><code>add_input_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_output_differentiator"><code>add_output_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_input_integrator"><code>add_input_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_output_integrator"><code>add_output_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>add_low_frequency_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}"><code>add_resonant_disturbance</code></a></li></ul><h1 id="H_\\infty-and-H_2-design"><a class="docs-heading-anchor" href="#H_\\infty-and-H_2-design"><span>$H_\infty$</span> and <span>$H_2$</span> design</a><a id="H_\\infty-and-H_2-design-1"></a><a class="docs-heading-anchor-permalink" href="#H_\\infty-and-H_2-design" title="Permalink"></a></h1><p>TODO Examples are available in the <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/tree/master/examples">example folder</a>.</p><ul><li><a href="#RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}"><code>hinfsynthesize</code></a></li><li><a href="#RobustAndOptimalControl.h2synthesize"><code>h2synthesize</code></a></li><li><a href="#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a></li></ul><h1 id="LQG-design"><a class="docs-heading-anchor" href="#LQG-design">LQG design</a><a id="LQG-design-1"></a><a class="docs-heading-anchor-permalink" href="#LQG-design" title="Permalink"></a></h1><p>TODO</p><ul><li><a href="#RobustAndOptimalControl.LQGProblem"><code>LQGProblem</code></a></li></ul><h1 id="Structured-singular-value-and-diskmargin"><a class="docs-heading-anchor" href="#Structured-singular-value-and-diskmargin">Structured singular value and diskmargin</a><a id="Structured-singular-value-and-diskmargin-1"></a><a class="docs-heading-anchor-permalink" href="#Structured-singular-value-and-diskmargin" title="Permalink"></a></h1><ul><li><a href="#RobustAndOptimalControl.structured_singular_value-Tuple{ControlSystems.LTISystem, AbstractVector}"><code>structured_singular_value</code></a>. Note, this only handles diagonal complex perturbations at the moment.</li><li><a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}"><code>loop_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin"><code>sim_diskmargin</code></a></li></ul><h1 id="Closed-loop-analysis"><a class="docs-heading-anchor" href="#Closed-loop-analysis">Closed-loop analysis</a><a id="Closed-loop-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Closed-loop-analysis" title="Permalink"></a></h1><ul><li><a href="#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a></li><li><a href="@ref"><code>G_CS</code></a></li><li><a href="@ref"><code>G_PS</code></a></li><li><a href="@ref"><code>gangoffour</code></a></li></ul><h1 id="Exported-functions-and-types"><a class="docs-heading-anchor" href="#Exported-functions-and-types">Exported functions and types</a><a id="Exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#RobustAndOptimalControl.Disk"><code>RobustAndOptimalControl.Disk</code></a></li><li><a href="#RobustAndOptimalControl.Diskmargin"><code>RobustAndOptimalControl.Diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.LQGProblem</code></a></li><li><a href="#RobustAndOptimalControl.LQGProblem"><code>RobustAndOptimalControl.LQGProblem</code></a></li><li><a href="#RobustAndOptimalControl.NamedStateSpace"><code>RobustAndOptimalControl.NamedStateSpace</code></a></li><li><a href="#RobustAndOptimalControl.UncertainSS"><code>RobustAndOptimalControl.UncertainSS</code></a></li><li><a href="#RobustAndOptimalControl.nyquistcircles"><code>RobustAndOptimalControl.nyquistcircles</code></a></li><li><a href="#RobustAndOptimalControl.δ"><code>RobustAndOptimalControl.δ</code></a></li><li><a href="#ControlSystems.ss"><code>ControlSystems.ss</code></a></li><li><a href="#DescriptorSystems.dss-Tuple{ControlSystems.AbstractStateSpace}"><code>DescriptorSystems.dss</code></a></li><li><a href="#RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_input_differentiator"><code>RobustAndOptimalControl.add_input_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_input_integrator"><code>RobustAndOptimalControl.add_input_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_measurement_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_output_differentiator"><code>RobustAndOptimalControl.add_output_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_output_integrator"><code>RobustAndOptimalControl.add_output_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}"><code>RobustAndOptimalControl.add_resonant_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.baltrunc2-Tuple{ControlSystems.LTISystem}"><code>RobustAndOptimalControl.baltrunc2</code></a></li><li><a href="#RobustAndOptimalControl.bilinearc2d-Tuple{ControlSystems.StateSpace{ControlSystems.Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a></li><li><a href="#RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a></li><li><a href="#RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{ControlSystems.Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a></li><li><a href="#RobustAndOptimalControl.bilineard2c-Tuple{ControlSystems.StateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a></li><li><a href="#RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilineard2c</code></a></li><li><a href="#RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a></li><li><a href="#RobustAndOptimalControl.blocksort-Tuple{UncertainSS}"><code>RobustAndOptimalControl.blocksort</code></a></li><li><a href="#RobustAndOptimalControl.broken_feedback-Tuple{ControlSystems.LTISystem, Any}"><code>RobustAndOptimalControl.broken_feedback</code></a></li><li><a href="#RobustAndOptimalControl.closedloop"><code>RobustAndOptimalControl.closedloop</code></a></li><li><a href="#RobustAndOptimalControl.comp_sensitivity-Tuple"><code>RobustAndOptimalControl.comp_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.connect-Tuple{Any}"><code>RobustAndOptimalControl.connect</code></a></li><li><a href="#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractArray}"><code>RobustAndOptimalControl.diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.diskmargin"><code>RobustAndOptimalControl.diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Any, AbstractVector, Vararg{Any}}"><code>RobustAndOptimalControl.diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}"><code>RobustAndOptimalControl.expand_symbol</code></a></li><li><a href="#RobustAndOptimalControl.extended_controller"><code>RobustAndOptimalControl.extended_controller</code></a></li><li><a href="#RobustAndOptimalControl.extended_controller-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.extended_controller</code></a></li><li><a href="#RobustAndOptimalControl.extended_gangoffour-Tuple{Any, Any}"><code>RobustAndOptimalControl.extended_gangoffour</code></a></li><li><a href="#RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any, F}} where {N, F}"><code>RobustAndOptimalControl.find_lft</code></a></li><li><a href="#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}"><code>RobustAndOptimalControl.fit_complex_perturbations</code></a></li><li><a href="#RobustAndOptimalControl.frequency_weighted_reduction"><code>RobustAndOptimalControl.frequency_weighted_reduction</code></a></li><li><a href="#RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}"><code>RobustAndOptimalControl.gain_and_delay_uncertainty</code></a></li><li><a href="#RobustAndOptimalControl.glover_mcfarlane"><code>RobustAndOptimalControl.glover_mcfarlane</code></a></li><li><a href="#RobustAndOptimalControl.h2norm-Tuple{ControlSystems.LTISystem}"><code>RobustAndOptimalControl.h2norm</code></a></li><li><a href="#RobustAndOptimalControl.h2synthesize"><code>RobustAndOptimalControl.h2synthesize</code></a></li><li><a href="#RobustAndOptimalControl.hankelnorm-Tuple{ControlSystems.LTISystem}"><code>RobustAndOptimalControl.hankelnorm</code></a></li><li><a href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>RobustAndOptimalControl.hanus</code></a></li><li><a href="#RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfassumptions</code></a></li><li><a href="#RobustAndOptimalControl.hinfgrad-Tuple{Any, Any, Any}"><code>RobustAndOptimalControl.hinfgrad</code></a></li><li><a href="#RobustAndOptimalControl.hinfnorm2-Tuple{ControlSystems.LTISystem}"><code>RobustAndOptimalControl.hinfnorm2</code></a></li><li><a href="#RobustAndOptimalControl.hinfpartition-NTuple{4, Any}"><code>RobustAndOptimalControl.hinfpartition</code></a></li><li><a href="#RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, ControlSystems.LTISystem, ControlSystems.LTISystem}"><code>RobustAndOptimalControl.hinfsignals</code></a></li><li><a href="#RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfsynthesize</code></a></li><li><a href="#RobustAndOptimalControl.hsvd-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}}"><code>RobustAndOptimalControl.hsvd</code></a></li><li><a href="#RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.input_comp_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.input_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.loop_scale"><code>RobustAndOptimalControl.loop_scale</code></a></li><li><a href="#RobustAndOptimalControl.loop_scaling"><code>RobustAndOptimalControl.loop_scaling</code></a></li><li><a href="#RobustAndOptimalControl.makeweight-Tuple{Any, Number, Any}"><code>RobustAndOptimalControl.makeweight</code></a></li><li><a href="#RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}"><code>RobustAndOptimalControl.measure</code></a></li><li><a href="#RobustAndOptimalControl.muplot"><code>RobustAndOptimalControl.muplot</code></a></li><li><a href="#RobustAndOptimalControl.mvnyquistplot"><code>RobustAndOptimalControl.mvnyquistplot</code></a></li><li><a href="#RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.named_ss</code></a></li><li><a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>RobustAndOptimalControl.ncfmargin</code></a></li><li><a href="#RobustAndOptimalControl.neglected_delay-Tuple{Any}"><code>RobustAndOptimalControl.neglected_delay</code></a></li><li><a href="#RobustAndOptimalControl.neglected_lag-Tuple{Any}"><code>RobustAndOptimalControl.neglected_lag</code></a></li><li><a href="#RobustAndOptimalControl.noise_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.noise_mapping</code></a></li><li><a href="#RobustAndOptimalControl.nugap-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem}"><code>RobustAndOptimalControl.nugap</code></a></li><li><a href="#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.output_comp_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.output_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.partition</code></a></li><li><a href="#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace, Int64, Int64}"><code>RobustAndOptimalControl.partition</code></a></li><li><a href="#RobustAndOptimalControl.performance_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.performance_mapping</code></a></li><li><a href="#RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}"><code>RobustAndOptimalControl.robstab</code></a></li><li><a href="#RobustAndOptimalControl.sensitivity-Tuple"><code>RobustAndOptimalControl.sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.show_construction-Tuple{IO, ControlSystems.LTISystem}"><code>RobustAndOptimalControl.show_construction</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractVector}"><code>RobustAndOptimalControl.sim_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.specificationplot"><code>RobustAndOptimalControl.specificationplot</code></a></li><li><a href="#RobustAndOptimalControl.structured_singular_value-Tuple{ControlSystems.LTISystem, AbstractVector}"><code>RobustAndOptimalControl.structured_singular_value</code></a></li><li><a href="#RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.structured_singular_value</code></a></li><li><a href="#RobustAndOptimalControl.sumblock-Tuple{String}"><code>RobustAndOptimalControl.sumblock</code></a></li><li><a href="#RobustAndOptimalControl.system_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.system_mapping</code></a></li><li><a href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.vec2sys"><code>RobustAndOptimalControl.vec2sys</code></a></li><li><a href="#RobustAndOptimalControl.δc"><code>RobustAndOptimalControl.δc</code></a></li><li><a href="#RobustAndOptimalControl.δr"><code>RobustAndOptimalControl.δr</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.Disk" href="#RobustAndOptimalControl.Disk"><code>RobustAndOptimalControl.Disk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Disk</code></pre><p>Represents a perturbation disc in the complex plane. <code>Disk(0.5, 2)</code> represents all perturbations in the circle centered at 1.25 with radius 0.75, or in other words, a gain margin of 2 and a pahse margin of 36.9 degrees.</p><p>A disk can be converted to a Nyquist exclusion disk by <code>nyquist(disk)</code> and plotted using <code>plot(disk)</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>γmin</code>: Lower intercept</li><li><code>γmax</code>: Upper intercept</li><li><code>c</code>: Center</li><li><code>r</code>: Radius</li><li><code>ϕm</code>: Angle of tangent line through origin.</li></ul><p>If γmax &lt; γmin the disk is inverted. See <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a> for disk margin computations. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/diskmargin.jl#L71-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.Diskmargin" href="#RobustAndOptimalControl.Diskmargin"><code>RobustAndOptimalControl.Diskmargin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Diskmargin</code></pre><p>The notation follows &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet</p><p><strong>Fields:</strong></p><p><code>α</code>: The disk margin <code>ω0</code>: The worst-case frequency <code>f0</code>: The destabilizing perturbation <code>f0</code> is a complex number with simultaneous gain and phase variation. This critical perturbation causes an instability with closed-loop pole on the imaginary axis at the critical frequency ω0  <code>δ0</code>: The uncertain element generating f0. <code>γmin</code>: The lower real-axis intercept of the disk (analogous to classical lower gain margin). <code>γmax</code>: The upper real-axis intercept of the disk (analogous to classical upper gain margin). <code>ϕm</code>: is analogous to the classical phase margin. <code>σ</code>: The skew parameter that was used to calculate the margin</p><p>Note, <code>γmax</code> and <code>ϕm</code> are in smaller than the classical gain and phase margins sicne the classical margins do not consider simultaneous perturbations in gain and phase. </p><p>The &quot;disk&quot; margin becomes a half plane for <code>α = 2</code> and an inverted circle for <code>α &gt; 2</code>. In this case, the upper gain margin is infinite. See the paper for more details, in particular figure 6.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/diskmargin.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.LQGProblem" href="#RobustAndOptimalControl.LQGProblem"><code>RobustAndOptimalControl.LQGProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">G = LQG(sys::AbstractStateSpace, Q1, Q2, R1, R2; qQ=0, qR=0, M = I, N = I)</code></pre><p>Return an LQG object that describes the closed control loop around the process <code>sys=ss(A,B,C,D)</code> where the controller is of LQG-type. The controller is specified by weight matrices <code>Q1,Q2</code> that penalizes state deviations and control signal variance respectively, and covariance matrices <code>R1,R2</code> which specify state drift and measurement covariance respectively.</p><p><code>qQ</code> and <code>qR</code> can be set to incorporate loop transfer recovery, i.e.,</p><pre><code class="language-julia hljs">L = lqr(A, B, Q1+qQ*C&#39;C, Q2)
K = kalman(A, C, R1+qR*B*B&#39;, R2)</code></pre><p>Increasing <code>qQ</code> will add more cost in output direction, e.g., encouraging the use of cheap control, while increasing <code>qR</code> adds fictious dynamics noise, makes the observer faster in the direction we control.</p><p><code>M</code> is a matrix that defines the controlled variables <code>z</code>, i.e., the variables for which you provide reference signals. If no <code>M</code> is provided, the default is to consider all state variables of the system as controlled. The definitions of <code>z</code> and <code>y</code> are given below</p><pre><code class="nohighlight hljs">y = C*x
z = M*x</code></pre><p><code>size(M, 1)</code> determines the size of the <code>Q1</code> matrix you need to supply.</p><p><code>N</code> is a matrix that defines how the dynamics noise <code>v</code> enters the system, i.e. If no <code>N</code> is provided, the default is to consider all state variables being affected by independent noise components. The definition of <code>v</code> is given below</p><pre><code class="nohighlight hljs">x′ = A*x + B*u + N*v</code></pre><p><code>size(N, 2)</code> determines the size of the <code>R1</code> matrix you need to supply.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">s = tf(&quot;s&quot;)
P = [1/(s+1) 2/(s+2); 1/(s+3) 1/(s-1)]
sys = ss(P)
eye(n) = Matrix{Float64}(I,n,n) # For convinience

qQ = 1
qR = 1
Q1 = 10eye(4)
Q2 = 1eye(2)
R1 = 1eye(6)
R2 = 1eye(2)

G = LQG(sys, Q1, Q2, R1, R2, qQ=qQ, qR=qR)

Gcl = G.cl
T = G.T
S = G.S
sigmaplot([S,T],exp10.(range(-3, stop=3, length=1000)))
stepplot(Gcl)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L5-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.LQGProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LQGProblem(P::ExtendedStateSpace)</code></pre><p>If only an <code>ExtendedStateSpace</code> system is provided, the system <code>P</code> is assumed to correspond to the H₂ optimal control problem with</p><pre><code class="nohighlight hljs">C1&#39;C1    = Q1
D12&#39;D12  = Q2

B1*B1&#39;   = R1
D21*D21&#39; = R2</code></pre><p>and an <code>LQGProblem</code> with the above covariance matrices is returned. The system description in the returned LQGProblem will have <code>B1 = C1 = I</code>. See Ch. 13 in Robust and optimal control for reference. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L94-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.NamedStateSpace" href="#RobustAndOptimalControl.NamedStateSpace"><code>RobustAndOptimalControl.NamedStateSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>See <code>named_ss</code> for a convenient constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/named_systems2.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.UncertainSS" href="#RobustAndOptimalControl.UncertainSS"><code>RobustAndOptimalControl.UncertainSS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UncertainSS{TE} &lt;: AbstractStateSpace{TE}</code></pre><p>Represents LFT_u(M, Diagonal(Δ))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/uncertainty_interface.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.nyquistcircles" href="#RobustAndOptimalControl.nyquistcircles"><code>RobustAndOptimalControl.nyquistcircles</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">nyquistcircles(w, centers, radii)</code></pre><p>Plot the nyquist curve with circles. It only makes sense to call this function if the circles represent additive uncertainty, i.e., were calculated with <code>relative=false</code>.</p><p>See also <a href="#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}"><code>fit_complex_perturbations</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/weights.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.δ" href="#RobustAndOptimalControl.δ"><code>RobustAndOptimalControl.δ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">δ(N=32)</code></pre><p>Create an uncertain element of <code>N</code> uniformly distributed samples ∈ [-1, 1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/find_lft.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.ss" href="#ControlSystems.ss"><code>ControlSystems.ss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ss(A, B1, B2, C1, C2, D11, D12, D21, D22 [, Ts])
ss(A, B1, B2, C1, C2; D11, D12, D21, D22 [, Ts])</code></pre><p>Create <a href="@ref"><code>ExtendedStateSpace</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/ExtendedStateSpace.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.dss-Tuple{ControlSystems.AbstractStateSpace}" href="#DescriptorSystems.dss-Tuple{ControlSystems.AbstractStateSpace}"><code>DescriptorSystems.dss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DescriptorSystems.dss(sys::AbstractStateSpace)</code></pre><p>Convert <code>sys</code> to a descriptor statespace system from <a href="https://andreasvarga.github.io/DescriptorSystems.jl/dev/index.html">DescriptorSystems.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/descriptor.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}" href="#RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_disturbance(sys::StateSpace, Ad::Matrix, Cd::Matrix)</code></pre><p>See CCS pp. 144</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: System to augment</li><li><code>Ad</code>: The dynamics of the disturbance</li><li><code>Cd</code>: How the disturbance states affect the states of <code>sys</code>. This matrix has the shape (sys.nx, size(Ad, 1))</li></ul><p>See also <a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>add_low_frequency_disturbance</code></a>, <a href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}"><code>add_resonant_disturbance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/model_augmentation.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_input_differentiator" href="#RobustAndOptimalControl.add_input_differentiator"><code>RobustAndOptimalControl.add_input_differentiator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_input_differentiator(sys::StateSpace, ui = 1:sys.nu; goodwin=false)</code></pre><p>Augment the output of <code>sys</code> with the difference <code>u(k+1)-u(k)</code></p><p><strong>Arguments:</strong></p><ul><li><code>ui</code>: An index or vector of indices indicating which inputs to differentiate.</li><li><code>goodwin</code>: If true, the difference operator will use the Goodwin δ operator, i.e., <code>(u(k+1)-u(k)) / sys.Ts</code>.</li></ul><p>The augmented system will have the matrices</p><pre><code class="nohighlight hljs">[A 0; 0 0]  [B; I]  [C 0; 0 -I]  [D; I]</code></pre><p>with <code>length(ui)</code> added states and outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/model_augmentation.jl#L177-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_input_integrator" href="#RobustAndOptimalControl.add_input_integrator"><code>RobustAndOptimalControl.add_input_integrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_input_integrator(sys::StateSpace, ui = 1, ϵ = 0)</code></pre><p>Augment the output of <code>sys</code> with the integral of input at index <code>ui</code>, i.e.,  <code>y_aug = [y; ∫u[ui]]</code> See also <a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>add_low_frequency_disturbance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/model_augmentation.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}" href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_low_frequency_disturbance(sys::StateSpace, Ai::Integer; ϵ = 0)</code></pre><p>A disturbance affecting only state <code>Ai</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/model_augmentation.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace}" href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_low_frequency_disturbance(sys::StateSpace; ϵ = 0, measurement = false)</code></pre><p>Augment <code>sys</code> with a low-frequency (integrating if <code>ϵ=0</code>) disturbance model. If an integrating input disturbance is used together with an observer, the controller will have integral action.</p><p><strong>Arguments:</strong></p><ul><li><code>ϵ</code>: Move the integrator pole <code>ϵ</code> into the stable region.</li><li><code>measurement</code>: If true, the disturbance is a measurement disturbance, otherwise it&#39;s an input diturbance. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/model_augmentation.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}" href="#RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_measurement_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_measurement_disturbance(sys::StateSpace{Continuous}, Ad::Matrix, Cd::Matrix)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/model_augmentation.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_output_differentiator" href="#RobustAndOptimalControl.add_output_differentiator"><code>RobustAndOptimalControl.add_output_differentiator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_differentiator(sys::StateSpace{&lt;:Discrete})</code></pre><p>Augment the output of <code>sys</code> with the numerical difference (discrete-time derivative) of output, i.e., <code>y_aug = [y; (y-y_prev)/sys.Ts]</code> To add both an integrator and a differentiator to a SISO system, use</p><pre><code class="language-julia hljs">Gd = add_output_integrator(add_output_differentiator(G), 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/model_augmentation.jl#L102-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_output_integrator" href="#RobustAndOptimalControl.add_output_integrator"><code>RobustAndOptimalControl.add_output_integrator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>add<em>output</em>integrator(sys::StateSpace{&lt;:Discrete}, ind = 1; ϵ = 0)</p><p>Augment the output of <code>sys</code> with the integral of output at index <code>ind</code>, i.e.,  <code>y_aug = [y; ∫y[ind]]</code> To add both an integrator and a differentiator to a SISO system, use</p><pre><code class="language-julia hljs">Gd = add_output_integrator(add_output_differentiator(G), 1)</code></pre><p>Note: numerical integration is subject to numerical drift. If the output of the system corresponds to, e.g., a velocity reference and the integral to position reference, consider methods for mitigating this drift.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/model_augmentation.jl#L128-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}" href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}"><code>RobustAndOptimalControl.add_resonant_disturbance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_resonant_disturbance(sys::StateSpace{Continuous}, ω, ζ, Ai::Int; measurement = false)</code></pre><p>Augment <code>sys</code> with a resonant disturbance model.</p><p><strong>Arguments:</strong></p><ul><li><code>ω</code>: Frequency</li><li><code>ζ</code>: Relative damping.</li><li><code>Ai</code>: The affected state</li><li><code>measurement</code>: If true, the disturbace is acting on the output, this will cause the controller to have zeros at ω (roots of poly s² + 2ζωs + ω²). If false, the disturbance is acting on the input, this will cause the controller to have poles at ω (roots of poly s² + 2ζωs + ω²).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/model_augmentation.jl#L76-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.baltrunc2-Tuple{ControlSystems.LTISystem}" href="#RobustAndOptimalControl.baltrunc2-Tuple{ControlSystems.LTISystem}"><code>RobustAndOptimalControl.baltrunc2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">baltrunc2(sys::LTISystem; residual=false, n=missing, kwargs...)</code></pre><p>Compute the a balanced truncation of order <code>n</code> and the hankel singular values</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.gbalmr</code>, reproduced below</p><pre><code class="nohighlight hljs">gbalmr(sys, balance = false, matchdc = false, ord = missing, atolhsv = 0, rtolhsv = nϵ, 
       atolmin = atolhsv, rtolmin = rtolhsv, 
       atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true) -&gt; (sysr, hs)</code></pre><p>Compute for a proper and stable descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, a reduced order realization <code>sysr = (Ar-λEr,Br,Cr,Dr)</code> and the vector <code>hs</code> of decreasingly  ordered Hankel singular values of the system <code>sys</code>. If <code>balance = true</code>, a balancing-based approach is used to determine a reduced order minimal realization  of the form <code>sysr = (Ar-λI,Br,Cr,Dr)</code>. For a continuous-time system <code>sys</code>, the resulting realization <code>sysr</code> is balanced, i.e., the controllability and observability grammians are equal and diagonal.  If additonally <code>matchdc = true</code>, the resulting <code>sysr</code> is computed using state rezidualization formulas  (also known as <em>singular perturbation approximation</em>) which additionally preserves the DC-gain of <code>sys</code>.  In this case, the resulting realization <code>sysr</code> is balanced (for both continuous- and discrete-time systems). If <code>balance = false</code>, an enhanced accuracy balancing-free approach is used to determine the  reduced order system <code>sysr</code>. </p><p>If <code>ord = nr</code>, the resulting order of <code>sysr</code> is <code>min(nr,nrmin)</code>, where <code>nrmin</code> is the order of a minimal   realization of <code>sys</code> determined as the number of Hankel singular values exceeding <code>max(atolmin,rtolmin*HN)</code>, with <code>HN</code>, the Hankel norm of <code>G(λ)</code>. If <code>ord = missing</code>, the resulting order is chosen as the number of Hankel  singular values exceeding <code>max(atolhsv,rtolhsv*HN)</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>nϵ</code>, where <code>ϵ</code> is the working <em>machine epsilon</em>  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>If <code>E</code> is singular, the uncontrollable infinite eigenvalues of the pair <code>(A,E)</code> and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>. </p><p>Method:  For the order reduction of a standard system, the balancing-free method of [1] or  the balancing-based method of [2] are used. For a descriptor system the balancing related order reduction  methods of [3] are used. To preserve the DC-gain of the original system, the singular perturbation  approximation method of [4] is used in conjunction with the balancing-based or balancing-free approach of [5]. </p><p>References</p><p>[1] A. Varga.      Efficient minimal realization procedure based on balancing.     In A. El Moudni, P. Borne, and S.G. Tzafestas (Eds.),      Prepr. of the IMACS Symp. on Modelling and Control of Technological      Systems, Lille, France, vol. 2, pp.42-47, 1991.</p><p>[2] M. S. Tombs and I. Postlethwaite.      Truncated balanced realization of a stable non-minimal state-space      system. Int. J. Control, vol. 46, pp. 1319–1330, 1987.</p><p>[3] T. Stykel.      Gramian based model reduction for descriptor systems.      Mathematics of Control, Signals, and Systems, 16:297–319, 2004.</p><p>[4] Y. Liu Y. and B.D.O. Anderson      Singular Perturbation Approximation of Balanced Systems,     Int. J. Control, Vol. 50, pp. 1379-1405, 1989.</p><p>[5] Varga A.     Balancing-free square-root algorithm for computing singular perturbation approximations.     Proc. 30-th IEEE CDC,  Brighton, Dec. 11-13, 1991, Vol. 2, pp. 1062-1065.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/descriptor.jl#L76-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}" href="#RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilinearc2d(Ac::AbstractArray, Bc::AbstractArray, Cc::AbstractArray, Dc::AbstractArray, Ts::Number; tolerance=1e-12)</code></pre><p>Balanced Bilinear transformation in State-Space. This method computes a discrete time equivalent of a continuous-time system, such that</p><pre><code class="nohighlight hljs">G_d(z) = s2z[G_c(s)]</code></pre><p>in a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||<em>2=||C||</em>2   (iii) Satisfies G<em>c(s) = z2s[s2z[G</em>c(s)]] for some map z2s[]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L1025-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilinearc2d-Tuple{ControlSystems.StateSpace{ControlSystems.Continuous}, Number}" href="#RobustAndOptimalControl.bilinearc2d-Tuple{ControlSystems.StateSpace{ControlSystems.Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilinearc2d(sys::StateSpace, Ts::Number)</code></pre><p>Applies a Balanced Bilinear transformation to a discrete-time statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L1084-L1088">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{ControlSystems.Continuous}, Number}" href="#RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{ControlSystems.Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilinearc2d(sys::ExtendedStateSpace, Ts::Number)</code></pre><p>Applies a Balanced Bilinear transformation to a discrete-time extended statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L1100-L1104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}" href="#RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilineard2c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilineard2c(Ad::AbstractArray, Bd::AbstractArray, Cd::AbstractArray, Dd::AbstractArray, Ts::Number; tolerance=1e-12)</code></pre><p>Balanced Bilinear transformation in State-Space. This method computes a continuous time equivalent of a discrete time system, such that</p><pre><code class="nohighlight hljs">G_c(z) = z2s[G_d(z)]</code></pre><p>in a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||<em>2=||C||</em>2   (iii) Satisfies G<em>d(z) = s2z[z2s[G</em>d(z)]] for some map s2z[]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L921-L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilineard2c-Tuple{ControlSystems.StateSpace}" href="#RobustAndOptimalControl.bilineard2c-Tuple{ControlSystems.StateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilineard2c(sys::StateSpace)</code></pre><p>Applies a Balanced Bilinear transformation to continuous-time statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L972-L976">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilineard2c(sys::ExtendedStateSpace)</code></pre><p>Applies a Balanced Bilinear transformation to continuous-time extended statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L989-L993">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.blocksort-Tuple{UncertainSS}" href="#RobustAndOptimalControl.blocksort-Tuple{UncertainSS}"><code>RobustAndOptimalControl.blocksort</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blocks, M = blocksort(P::UncertainSS)</code></pre><p>Returns the block structure of <code>P.Δ</code> as well as <code>P.M</code> permuted according to the sorted block structure. <code>blocks</code> is a vector of vectors with the block structure of perturbation blocks as described by μ-tools, i.e.</p><ul><li><code>[-N, 0]</code> denotes a repeated real block of size <code>N</code></li><li><code>[N, 0]</code> denotes a repeated complex block of size <code>N</code></li><li><code>[ny, nu]</code> denotes a full complex block of size <code>ny × nu</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/uncertainty_interface.jl#L569-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.broken_feedback-Tuple{ControlSystems.LTISystem, Any}" href="#RobustAndOptimalControl.broken_feedback-Tuple{ControlSystems.LTISystem, Any}"><code>RobustAndOptimalControl.broken_feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">broken_feedback(L, i)</code></pre><p>Closes all loops in square MIMO system <code>L</code> except for loops <code>i</code>. Forms L1 in fig 14. of &quot;An Introduction to Disk Margins&quot; https://arxiv.org/abs/2003.04771</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L353-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.closedloop" href="#RobustAndOptimalControl.closedloop"><code>RobustAndOptimalControl.closedloop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closedloop(l::LQGProblem, L = lqr(l), K = kalman(l))</code></pre><p>Closed-loop system as defined in Glad and Ljung eq. 8.28</p><p>The return value will be the closed loop from reference only, other disturbance signals (B1) are ignored. See <code>feedback</code> for a more advanced option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.comp_sensitivity-Tuple" href="#RobustAndOptimalControl.comp_sensitivity-Tuple"><code>RobustAndOptimalControl.comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a></p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L334-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.connect-Tuple{Any}" href="#RobustAndOptimalControl.connect-Tuple{Any}"><code>RobustAndOptimalControl.connect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connect(systems, connections; w1, z1 = (:), verbose = true, kwargs...)</code></pre><p>Create complicated feedback interconnection. </p><p>Addition and subtraction nodes are achieved by creating a linear combination node, i.e., a system with a <code>D</code> matrix only.</p><p><strong>Arguments:</strong></p><ul><li><code>systems</code>: A vector of named systems to be connected</li><li><code>connections</code>: a vector of pairs indicating output =&gt; input mappings.<ul><li><code>u1</code>: input mappings  (alternative input argument)</li><li><code>y1</code>: output mappings (alternative input argument)</li></ul></li><li><code>w1</code>: external signals</li><li><code>z1</code>: outputs (can overlap with <code>y1</code>)</li><li><code>verbose</code>: Issue warnings for signals that have no connection</li></ul><p>Example: The following complicated feedback interconnection</p><pre><code class="nohighlight hljs">                 yF
              ┌────────────────────────────────┐
              │                                │
    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐
uF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP
────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►
    │       │    │       │   ┌──►         │         │       │    │
    └───────┘    └───────┘   │  └─────────┘         └───────┘    │
                             │                                   │
                             └───────────────────────────────────┘</code></pre><p>can be created by</p><pre><code class="nohighlight hljs">F = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)
R = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)
C = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)
P = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)

addP = sumblock(&quot;uP = yF + yC&quot;) # Sum node before P
addC = sumblock(&quot;uC = yR - yP&quot;) # Sum node before C

connections = [
    :yP =&gt; :yP # Output to input
    :uP =&gt; :uP
    :yC =&gt; :yC
    :yF =&gt; :yF
    :yF =&gt; :uR
    :uC =&gt; :uC
    :yR =&gt; :yR
]
w1 = [:uF] # External inputs

G = connect([F, R, C, P, addP, addC], connections; w1)</code></pre><p>If an external input is to be connected to multiple points, use a <code>splitter</code> to split up the signal into a set of unique names which are then used in the connections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/named_systems2.jl#L310-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.diskmargin" href="#RobustAndOptimalControl.diskmargin"><code>RobustAndOptimalControl.diskmargin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diskmargin(L, σ = 0)
diskmargin(L, σ::Real, ω)</code></pre><p>Calculate the disk margin of LTI system <code>L</code>. <code>L</code> is supposed to be a loop-transfer function, i.e., it should be square. If <code>L = PC</code> the disk margin for output perturbations is computed, whereas if <code>L = CP</code>, input perturbations are considered. If the method <code>diskmargin(P, C, args...)</code> is used, both are computed.</p><p>The implementation and notation follows &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771</p><p>The margins are aviable as fields of the returned objects, see <a href="#RobustAndOptimalControl.Diskmargin"><code>Diskmargin</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>L</code>: A loop-transfer function.</li><li><code>σ</code>: If little is known about the distribution of gain variations then σ = 0 is a reasonable choice as it allows for a gain increase or decrease by the same relative amount. <em>The choice σ &lt; 0</em> is justified if the gain can decrease by a larger factor than it can increase. Similarly, <em>the choice σ &gt; 0</em> is justified when the gain can increase by a larger factor than it can decrease. <em>If σ = −1</em> then the disk margin condition is αmax = inv(MT). This margin is related to the robust stability condition for models with multiplicative uncertainty of the form P (1 + δ). If σ = +1 then the disk margin condition is αmax = inv(MS)</li><li><code>kwargs</code>: Are sent to the <a href="@ref"><code>hinfnorm</code></a> calculation</li><li><code>ω</code>: If a vector of frequencies is supplied, the frequency-dependent disk margin will be computed, see example below.</li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">L = tf(25, [1,10,10,10])
dm = diskmargin(L, 0)
plot(dm) # Plot the disk margin to illustrate maximum allowed simultaneous gain and phase variations.

nyquistplot(L)
plot!(dm, nyquist=true) # plot a nyquist exclusion disk. The Nyquist curve will be tangent to this disk at `dm.ω0`
nyquistplot!(dm.f0*L) # If we perturb the system with the worst-case perturbation `f0`, the curve will pass through the critical point -1.

## Frequency-dependent margin
w = exp10.(LinRange(-2, 2, 500))
dms = diskmargin(L, 0, w)
plot(w, dms)</code></pre><p>See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/diskmargin.jl#L130-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Any, AbstractVector, Vararg{Any}}" href="#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Any, AbstractVector, Vararg{Any}}"><code>RobustAndOptimalControl.diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diskmargin(P::LTISystem, C::LTISystem, σ, w::AbstractVector, args...; kwargs...)</code></pre><p>Simultaneuous diskmargin at outputs, inputs and input/output simultaneously of <code>P</code>.  Returns a named tuple with the fields <code>input, output, simultaneous_input, simultaneous_output, simultaneous</code> where <code>input</code> and <code>output</code> represent loop-at-a-time margins, <code>simultaneous_input</code> is the margin for simultaneous perturbations on all inputs and <code>simultaneous</code> is the margin for perturbations on all inputs and outputs simultaneously. See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L299-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractArray}" href="#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractArray}"><code>RobustAndOptimalControl.diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diskmargin(L::LTISystem, σ::Real, ω)</code></pre><p>Calculate the diskmargin at a particular frequency or vector of frequencies. If <code>ω</code> is a vector, you get a frequency-dependent diskmargin plot if you plot the returned value. See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/diskmargin.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}" href="#RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}"><code>RobustAndOptimalControl.expand_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_symbol(s::Symbol, n::Int)</code></pre><p>Takes a symbol and an integer and returns a vector of symbols with increasing numbers appended to the end. E.g., (:x, 3) -&gt; [:x1, :x2, :x3]</p><p>The short-hand syntax <code>s^n</code> is also available, e.g., <code>:x^3 == expand_symbol(:x, 3)</code>.</p><p>Useful to create signal names for named systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/named_systems2.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.extended_controller" href="#RobustAndOptimalControl.extended_controller"><code>RobustAndOptimalControl.extended_controller</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extended_controller(l::LQGProblem, L = lqr(l), K = kalman(l))</code></pre><p>Returns an expression for the controller that is obtained when state-feedback <code>u = -L(xᵣ-x̂)</code> is combined with a Kalman filter with gain <code>K</code> that produces state estimates x̂. The controller is an instance of <code>ExtendedStateSpace</code> where <code>C2 = -L, D21 = L</code> and <code>B2 = K</code>.</p><p>The returned system has <em>inputs</em> <code>[xᵣ; y]</code> and outputs the control signal <code>u</code>. If a reference model <code>R</code> is used to generate state references <code>xᵣ</code>, the controller from <code>e = ry - y -&gt; u</code> is given by</p><pre><code class="language-julia hljs">Ce = extended_controller(l)
Ce = named_ss(Ce; x = :xC, y = :u, u = [R.y; :y^l.ny]) # Name the inputs of Ce the same as the outputs of `R`.
connect([R, Ce]; u1 = R.y, y1 = R.y, w1 = [:ry^l.ny, :y^l.ny], z1=[:u])</code></pre><p>Since the negative part of the feedback is built into the returned system, we have</p><pre><code class="language-julia hljs">C = observer_controller(l)
Ce = extended_controller(l)
system_mapping(Ce) == -C</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L205-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.extended_controller-Tuple{ControlSystems.AbstractStateSpace}" href="#RobustAndOptimalControl.extended_controller-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.extended_controller</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extended_controller(K::AbstractStateSpace)</code></pre><p>Takes a controller and returns an <code>ExtendedStateSpace</code> version which has augmented input <code>[r; y]</code> and output <code>y</code> (<code>z</code> output is 0-dim).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.extended_gangoffour-Tuple{Any, Any}" href="#RobustAndOptimalControl.extended_gangoffour-Tuple{Any, Any}"><code>RobustAndOptimalControl.extended_gangoffour</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extended_gangoffour(P, C)</code></pre><p>Returns a single statespace system that maps </p><ul><li><code>w1</code> reference or measurement noise</li><li><code>w2</code> load disturbance</li></ul><p>to</p><ul><li><code>z1</code> control error</li><li><code>z2</code> control input</li></ul><pre><code class="nohighlight hljs">      z1          z2
      ▲  ┌─────┐  ▲      ┌─────┐
      │  │     │  │      │     │
w1──+─┴─►│  C  ├──┴───+─►│  P  ├─┐
    │    │     │      │  │     │ │
    │    └─────┘      │  └─────┘ │
    │                 w2         │
    └────────────────────────────┘</code></pre><p>The returned system has the transfer-function matrix</p><p class="math-container">\[\begin{bmatrix}
I \\ C
\end{bmatrix} (I + PC)^{-1} \begin{bmatrix}
I &amp; P
\end{bmatrix}\]</p><p>The gang of four can be plotted like so</p><pre><code class="language-julia hljs">Gcl = extended_gangoffour(G, C) # Form closed-loop system
bodeplot(Gcl, lab=[&quot;S&quot; &quot;CS&quot; &quot;PS&quot; &quot;T&quot;], plotphase=false) |&gt; display # Plot gang of four</code></pre><p>Note, the last output of Gcl is the negative of the <code>CS</code> and <code>PS</code> transfer functions from <code>gangoffour2</code>. See <a href="#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a> for an extended example. See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/glover_mcfarlane.jl#L174-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any, F}} where {N, F}" href="#RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any}, Tuple{ControlSystems.StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any, F}} where {N, F}"><code>RobustAndOptimalControl.find_lft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">l = find_lft(sys::StateSpace{&lt;:Any, &lt;:StaticParticles{&lt;:Any, N}}, δ) where N</code></pre><p>Given an systems <code>sys</code> with uncertain coefficients in the form of <code>StaticParticles</code>, find a lower linear fractional transformation <code>M</code> such that <code>lft(M, δ) ≈ sys</code>. </p><p><code>δ</code> can be either the source of uncertainty in <code>sys</code>, i.e., a vector of the unique uncertain parameters that were used to create <code>sys</code>. These should be constructed as uniform randomly distributed particles for most robust-control theory to be applicable.  <code>δ</code> can also be an integer, in which case a numer of <code>δ</code> sources of uncertainty are automatically created. This could be used for order reduction if the number of uncertainty sources in <code>sys</code> is large.</p><p>Note, uncertainty in <code>sys</code> is only supported in <code>A</code> and <code>B</code>, <code>C</code> and <code>D</code> must be deterministic.</p><p>Returns <code>l::LFT</code> that internaly contains all four blocks of <code>M</code> as well as <code>δ</code>. Call <code>ss(l,sys)</code> do obtain <code>lft(M, δ) ≈ sys</code>.</p><p>Call <code>Matrix(l)</code> to obtain <code>M = [M11 M12; M21 M22]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/find_lft.jl#L57-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}" href="#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}"><code>RobustAndOptimalControl.fit_complex_perturbations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centers, radii = fit_complex_perturbations(P, w; relative=true, nominal=:mean)</code></pre><p>For each frequency in <code>w</code>, fit a circle in the complex plane that contains all models in the model set <code>P</code>, represented as an <code>LTISystem</code> with <code>Particles</code> coefficients. Note, the resulting radii can be quite unstable if the number of particles is small, in particular if the particles are normally distributed instead of uniformly.</p><p>If <code>realtive = true</code>, circles encompassing <code>|(P - Pn)/Pn|</code> will be returned (multiplicative/relative uncertainty). If <code>realtive = false</code>, circles encompassing <code>|P - Pn|</code> will be returned (additive uncertainty).</p><p>If <code>nominal = :mean</code>, the mean of <code>P</code> will be used as nominal model. If <code>nominal = :first</code>, the first particle will be used. See <code>MonteCarloMeasurements.with_nominal</code> to set the nominal value in the first particle. </p><p>See also <a href="#RobustAndOptimalControl.nyquistcircles"><code>nyquistcircles</code></a> to plot circles (only if relative=false).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/weights.jl#L71-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.frequency_weighted_reduction" href="#RobustAndOptimalControl.frequency_weighted_reduction"><code>RobustAndOptimalControl.frequency_weighted_reduction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frequency_weighted_reduction(G, Wo, Wi; residual=true)</code></pre><p>Find Gr such that ||Wₒ(G-Gr)Wᵢ||∞ is minimized. For a realtive reduction, set Wo = inv(G) and Wi = I.</p><p>If <code>residual = true</code>, matched static gain is achieved through &quot;residualization&quot;, i.e., setting</p><p class="math-container">\[0 = A_{21}x_{1} + A_{22}x_{2} + B_{2}u\]</p><p>where indices 1/2 correspond to the remaining/truncated states respectively. This choice typically results in a better match in the low-frequency region and a smaller overall error.</p><p>Ref: Andras Varga and Brian D.O. Anderson, &quot;Accuracy enhancing methods for the frequency-weighted balancing related model reduction&quot; https://elib.dlr.de/11746/1/varga_cdc01p2.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/reduction.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}" href="#RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}"><code>RobustAndOptimalControl.gain_and_delay_uncertainty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gain_and_delay_uncertainty(kmin, kmax, Lmax)</code></pre><p>Return a multiplicative weight to represent the uncertainty coming from neglecting the dynamics <code>k*exp(-s*L)</code> where <code>k ∈ [kmin, kmax]</code> and <code>L ≤ Lmax</code>. This weight is slightly optimistic, an expression for a more exact weight appears in eq (7.27), &quot;Multivariable Feedback Control: Analysis and Design&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/weights.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.glover_mcfarlane" href="#RobustAndOptimalControl.glover_mcfarlane"><code>RobustAndOptimalControl.glover_mcfarlane</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">K, γ, info = glover_mcfarlane(G::AbstractStateSpace{Continuous}, γ = 1.1)</code></pre><p>Design a controller for <code>G</code> that maximizes the stability margin ϵ = 1/γ with normalized coprime factor uncertainty using the method of Glover and McFarlane</p><pre><code class="nohighlight hljs">γ = 1/ϵ = ||[K;I] inv(I-G*K)*inv(M)||∞
G = inv(M + ΔM)*(N + ΔN)</code></pre><p>γ is given as a relative factor above γmin and must be greater than 1, i.e., if γ = 1.1, the controller will be designed for γ = 1.1*γmin.</p><p>We want γmin (which is always ≥ 1) as small as possible, and we usually require that γmin is less than 4, corresponding to 25% allowed coprime uncertainty.</p><p>Performance modeling is incorporated in the design by calling <code>glover_mcfarlane</code> on the shaped system <code>W2*G*W1</code> and then forming the controller as <code>W1*K*W2</code>. Using this formulation, traditional loop shaping can be done on <code>W2*G*W1</code>.</p><p><strong>Example:</strong></p><p>Example 9.3 from the reference below.</p><pre><code class="language-julia hljs">using RobustAndOptimalControl, ControlSystems, Plots, Test
G = tf(200, [10, 1])*tf(1, [0.05, 1])^2     |&gt; ss
Gd = tf(100, [10, 1])                       |&gt; ss
W1 = tf([1, 2], [1, 1e-6])                  |&gt; ss
K, γ, info = glover_mcfarlane(G, 1.1; W1)
@test info.γmin ≈ 2.34 atol=0.005
Gcl = extended_gangoffour(G, K) # Form closed-loop system

bodeplot([G, info.Gs, G*K], lab=[&quot;G&quot; &quot;&quot; &quot;G scaled&quot; &quot;&quot; &quot;Loop transfer&quot;]) |&gt; display
bodeplot(Gcl, lab=[&quot;S&quot; &quot;KS&quot; &quot;PS&quot; &quot;T&quot;], plotphase=false) |&gt; display # Plot gang of four

plot( step(Gd*feedback(1, info.Gs), 3), lab=&quot;Initial controller&quot;)
plot!(step(Gd*feedback(1, G*K), 3), lab=&quot;Robustified&quot;) |&gt; display

nyquistplot([info.Gs, G*K], ylims=(-2,1), xlims=(-2, 1),
    Ms_circles = 1.5,
    lab = [&quot;Initial controller&quot; &quot;Robustified&quot;],
    title = &quot;Loop transfers with and without robustified controller&quot;
    ) |&gt; display</code></pre><p>Ref: Sec 9.4.1 of Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;</p><p><strong>Extended help</strong></p><p>Skogestad gives the following general advice:</p><ol><li><p>Scale the plant outputs and inputs. This is very important for most design  procedures and is sometimes forgotten. In general, scaling improves the  conditioning of the design problem, it enables meaningful analysis to be made  of the robustness properties of the feedback system in the frequency domain,  and for loop-shaping it can simplify the selection of weights. There are a variety  of methods available including normalization with respect to the magnitude of  the maximum or average value of the signal in question. If one is to go straight to a design the following variation has  proved useful in practice:  (a) The outputs are scaled such that equal magnitudes of cross-coupling into each      of the outputs is equally undesirable.  (b) Each input is scaled by a given percentage (say 10%) of its expected range      of operation. That is, the inputs are scaled to reflect the relative actuator      capabilities. An example of this type of scaling is given in the aero-engine      case study of Chapter 12.</p></li><li><p>Order the inputs and outputs so that the plant is as diagonal as possible. The  relative gain array <a href="@ref"><code>rga</code></a> can be useful here. The purpose of this pseudo-diagonalization  is to ease the design of the pre- and post-compensators which, for simplicity, will  be chosen to be diagonal.</p><p>Next, we discuss the selection of weights to obtain the shaped plant <span>$G_s = W_2 G W_1$</span>  where <span>$W_1 = W_p W_a W_g$</span></p></li><li><p>Select the elements of diagonal pre- and post-compensators <span>$W_p$</span> and <span>$W_2$</span> so that  the singular values of <span>$W_2 G W_p$</span> are desirable. This would normally mean high  gain at low frequencies, roll-off rates of approximately 20 dB/decade (a slope of  about 1) at the desired bandwidth(s), with higher rates at high frequencies. Some  trial and error is involved here. <span>$W_2$</span> is usually chosen as a constant, reflecting the  relative importance of the outputs to be controlled and the other measurements  being fed back to the controller. For example, if there are feedback measurements  of two outputs to be controlled and a velocity signal, then <span>$W_2$</span> might be chosen  to be <code>diag([1, 1, 0.1])</code>, where 0.1 is in the velocity signal channel. <span>$W_p$</span> contains the  dynamic shaping. Integral action, for low frequency performance; phase-advance  for reducing the roll-off rates at crossover, and phase-lag to increase the roll-off  rates at high frequencies should all be placed in <span>$W_p$</span> if desired. The weights should  be chosen so that no unstable hidden modes are created in <span>$G_s$</span>.</p></li><li><p>Optional: Introduce an additional gain matrix <span>$W_g$</span> cascaded with <span>$W_a$</span> to provide  control over actuator usage. <span>$W_g$</span> is diagonal and is adjusted so that actuator rate  limits are not exceeded for reference demands and typical disturbances on the  scaled plant outputs. This requires some trial and error.</p></li><li><p>Robustly stabilize the shaped plant <span>$G_s = W_2 G W_1$</span> , where <span>$W_1 = W_p W_a W_g$</span>,  using <code>glover_mcfarlane</code>. First, the maximum stability  margin <span>$ϵ_{max} = 1/γ_{min}$</span> is calculated. If the margin is too small, <span>$ϵmax &lt; 0.25$</span>, then go back and modify the weights. Otherwise, a γ-suboptimal controller is synthesized. There is usually no advantage to be gained by using the optimal controller. When <span>$ϵ_{max}$</span> &gt; 0.25  (respectively <span>$γ_{min}$</span> &lt; 4) the design is usually successful. In this case, at least  25% coprime factor uncertainty is allowed, and we also find that the shape of the  open-loop singular values will not have changed much after robust stabilization.  A small value of ϵmax indicates that the chosen singular value loop-shapes are  incompatible with robust stability requirements. That the loop-shapes do not  change much following robust stabilization if γ is small (ϵ large), is justified  theoretically in McFarlane and Glover (1990).</p></li><li><p>Analyze the design and if all the specifications are not met make further  modifications to the weights.</p></li><li><p>Implement the controller. The configuration shown in below has been found  useful when compared with the conventional set up. This is because  the references do not directly excite the dynamics of <span>$K$</span>, which can result in large amounts of overshoot (classical derivative kick). The constant prefilter ensures a steady-state gain of 1 between r and y, assuming integral action in <span>$W_1$</span> or <span>$G$</span> (note, the K returned by this function has opposite sign compared to that of Skogestad, so we use negative feedback here).</p></li></ol><p>Anti-windup can be added to <span>$W_1$</span> but putting <span>$W_1$</span> on Hanus form after the synthesis, see <a href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>hanus</code></a>.</p><pre><code class="nohighlight hljs">       ┌─────────┐      ┌────────┐      ┌────────┐
    r  │         │    us│        │  u   │        │  y
   ───►│(K*W2)(0)├──+──►│   W1   ├─────►│   G    ├────┬──►
       │         │  │-  │        │      │        │    │
       └─────────┘  │   └────────┘      └────────┘    │
                    │                                 │
                    │                                 │
                    │   ┌────────┐      ┌────────┐    │
                    │   │        │  ys  │        │    │
                    └───┤   K    │◄─────┤   W2   │◄───┘
                        │        │      │        │
                        └────────┘      └────────┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/glover_mcfarlane.jl#L1-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.h2norm-Tuple{ControlSystems.LTISystem}" href="#RobustAndOptimalControl.h2norm-Tuple{ControlSystems.LTISystem}"><code>RobustAndOptimalControl.h2norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n = h2norm(sys::LTISystem; kwargs...)</code></pre><p>A numerically robust version of <code>norm</code> using DescriptorSystems.jl</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.gh2norm</code>, reproduced below</p><pre><code class="nohighlight hljs">gh2norm(sys, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atolinf = atol, rtol = n*ϵ)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> the <code>H2</code> norm of its transfer function  matrix <code>G(λ)</code>. The <code>H2</code> norm is infinite, if <code>sys</code> has unstable poles, or, for a continuous-time, the system has nonzero gain at infinity. To check the stability, the eigenvalues of the <em>pole pencil</em> <code>A-λE</code> must have real parts less  than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset. The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The keyword argument <code>atolinf</code> is the absolute tolerance for the gain of <code>G(λ)</code> at <code>λ = ∞</code>.  The used default value is <code>atolinf = 0</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/descriptor.jl#L36-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.h2synthesize" href="#RobustAndOptimalControl.h2synthesize"><code>RobustAndOptimalControl.h2synthesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">K, Cl = h2synthesize(P::ExtendedStateSpace, γ = nothing)</code></pre><p>Synthesize H₂-optimal controller K and calculate the closed-loop transfer function from <code>w</code> to <code>z</code>. Ref: Cha. 14.5 in Robust and Optimal Control.</p><p>If <code>γ = nothing</code>, use the formulas for H₂ in Ch 14.5. If γ is a large value, the H∞ formulas are used. As γ → ∞, these two are equivalent. The h∞ formulas do a coordinate transfromation that handles slightly more general systems so if you run into an error, it might be worth trying setting γ to something large, e.g., 1000.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/h2_design.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hankelnorm-Tuple{ControlSystems.LTISystem}" href="#RobustAndOptimalControl.hankelnorm-Tuple{ControlSystems.LTISystem}"><code>RobustAndOptimalControl.hankelnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n, hsv = hankelnorm(sys::LTISystem; kwargs...)</code></pre><p>Compute the hankelnorm and the hankel singular values</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.ghanorm</code>, reproduced below</p><pre><code class="nohighlight hljs">ghanorm(sys, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (hanorm, hs)</code></pre><p>Compute for a proper and stable descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, the Hankel norm <code>hanorm =</code> <span>$\small ||G(\lambda)||_H$</span> and the vector of Hankel singular values <code>hs</code> of the system.</p><p>For a proper system with <code>E</code> singular, the uncontrollable infinite eigenvalues of the pair <code>(A,E)</code> and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/descriptor.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hanus-Tuple{Any}" href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>RobustAndOptimalControl.hanus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wh = hanus(W)</code></pre><p>Return <code>Wh</code> on Hanus form. <code>Wh</code> has twice the number of inputs, where the second half of the inputs are &quot;actual inputs&quot;, e.g., potentially saturated. This is used to endow <code>W</code> with anti-windup protection. <code>W</code> must have an invertable <code>D</code> matrix and be minimum phase.</p><p>Ref: Sec 9.4.5 of Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/glover_mcfarlane.jl#L156-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfassumptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flag = hinfassumptions(P::ExtendedStateSpace; verbose=true)</code></pre><p>Check the assumptions for using the γ-iteration synthesis in Theorem 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfgrad-Tuple{Any, Any, Any}" href="#RobustAndOptimalControl.hinfgrad-Tuple{Any, Any, Any}"><code>RobustAndOptimalControl.hinfgrad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇A, ∇B, ∇C, ∇D, hn, ω = hinfgrad(sys; rtolinf=1e-8, kwargs...)
∇A, ∇B, ∇C, ∇D        = hinfgrad(sys, hn, ω)</code></pre><p>Compute the gradient of the H∞ norm w.r.t. the statespace matrices <code>A,B,C,D</code>. If only a system is provided, the norm <code>hn</code> and the peak frequency <code>ω</code> are automatically calculated. <code>kwargs</code> are sent to <a href="#RobustAndOptimalControl.hinfnorm2-Tuple{ControlSystems.LTISystem}"><code>hinfnorm2</code></a>. Note, the default tolerance to which the norm is calculated is set smaller than default for <a href="#RobustAndOptimalControl.hinfnorm2-Tuple{ControlSystems.LTISystem}"><code>hinfnorm2</code></a>, gradients will be discontinuous with any non-finite tolerance, and sensitive optimization algorithms may require even tighter tolerance.</p><p>In cases where the maximum singular value is reached at more than one frequency, a random frequency is used.</p><p>If the system is unstable, the gradients are <code>NaN</code>. Strategies to find an initial stabilizing controllers are outlined in Apkarian and D. Noll, &quot;Nonsmooth H∞ Synthesis&quot; in IEEE Transactions on Automatic Control.</p><p>An <code>rrule</code> for ChainRules is defined using this function, so <code>hn</code> is differentiable with any AD package that derives its rules from ChainRules (only applies to the <code>hn</code> return value, not <code>ω</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L1148-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfnorm2-Tuple{ControlSystems.LTISystem}" href="#RobustAndOptimalControl.hinfnorm2-Tuple{ControlSystems.LTISystem}"><code>RobustAndOptimalControl.hinfnorm2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n, ω = hinfnorm2(sys::LTISystem; kwargs...)</code></pre><p>A numerically robust version of <code>hinfnorm</code> using DescriptorSystems.jl</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.ghinfnorm</code>, reproduced below</p><pre><code class="nohighlight hljs">ghinfnorm(sys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (hinfnorm, fpeak)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function  matrix <code>G(λ)</code>  the <code>H∞</code> norm <code>hinfnorm</code> (i.e.,  the peak gain of <code>G(λ)</code>) and  the corresponding peak frequency <code>fpeak</code>, where the peak gain is achieved.  The <code>H∞</code> norm is infinite if the <em>pole pencil</em> <code>A-λE</code> has unstable zeros (i.e., <code>sys</code> has unstable poles).  To check the stability, the eigenvalues of the pencil <code>A-λE</code> must have real parts less than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset. The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy for the computed infinity norm.  The  default value used for <code>rtolinf</code> is <code>0.001</code>.</p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon   and <code>n</code> is the order of the system <code>sys</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/descriptor.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfpartition-NTuple{4, Any}" href="#RobustAndOptimalControl.hinfpartition-NTuple{4, Any}"><code>RobustAndOptimalControl.hinfpartition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">P = hinfpartition(G, WS, WU, WT)</code></pre><p>Transform a SISO or MIMO system G, with weighting functions WS, WU, WT into an LFT with an isolated controller, and write the resulting system, P(s), on a state-space form. Valid inputs for G are transfer functions (with dynamics, can be both MIMO and SISO, both in tf and ss forms). Valid inputs for the weighting functions are empty arrays, numbers (static gains), and <code>LTISystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L597-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, ControlSystems.LTISystem, ControlSystems.LTISystem}" href="#RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, ControlSystems.LTISystem, ControlSystems.LTISystem}"><code>RobustAndOptimalControl.hinfsignals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hinfsignals(P::ExtendedStateSpace, G::LTISystem, C::LTISystem)</code></pre><p>Use the extended state-space model, a plant and the found controller to extract the closed loop transfer functions.</p><ul><li><code>Pcl : w → z</code> : From input to the weighted functions</li><li><code>S   : w → e</code> : From input to error</li><li><code>CS  : w → u</code> : From input to control</li><li><code>T   : w → y</code> : From input to output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L856-L866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfsynthesize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flag, K, γ, mats = hinfsynthesize(P::ExtendedStateSpace; maxIter = 20, interval = (2 / 3, 20), verbose = false, tolerance = 1.0e-10, γrel = 1.01)</code></pre><p>Computes an H-infinity optimal controller K for an extended plant P such that ||F_l(P, K)||∞ &lt; γ for the smallest possible γ given P. The routine is known as the γ-iteration, and is based on the paper &quot;State-space formulae for all stabilizing controllers that satisfy an H∞-norm bound and relations to risk sensitivity&quot; by Glover and Doyle.</p><p><strong>Arguments:</strong></p><ul><li><code>maxIter</code>: Maximum number of γ iterations</li><li><code>interval</code>: The starting interval for the bisection.</li><li><code>verbose</code>: Print progress?</li><li><code>tolerance</code>: Stop when the interval is this small.</li><li><code>γrel</code>: If <code>γrel &gt; 1</code>, the optimal γ will be found by γ iteration after which a controller will be designed for <code>γ = γopt * γrel</code>. It is often a good idea to design a slightly suboptimal controller, both for numerical reasons, but also since the optimal controller may contain very fast dynamics. If <code>γrel → ∞</code>, the computed controller will approach the 𝑯₂ optimal controller. Getting a mix between 𝑯∞ and 𝑯₂ properties is another reason to choose <code>γrel &gt; 1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/hinfinity_design.jl#L112-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.hsvd-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}}" href="#RobustAndOptimalControl.hsvd-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}}"><code>RobustAndOptimalControl.hsvd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hsvd(sys::AbstractStateSpace{Continuous})</code></pre><p>Return the Hankel singular values of <code>sys</code>, computed as the eigenvalues of <code>QP</code> Where <code>Q</code> and <code>P</code> are the Gramians of <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/reduction.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}" href="#RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.input_comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_comp_sensitivity(P,C)
input_comp_sensitivity(l::LQGProblem)</code></pre><p>Transfer function from load disturbance to control signal.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case controller output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L400-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}" href="#RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.input_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_sensitivity(P, C)
input_sensitivity(l::LQGProblem)</code></pre><p>Transfer function from load disturbance to total plant input.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L369-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}" href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loop_diskmargin(P, C, args...; kwargs...)</code></pre><p>Calculate the loop-at-a-time diskmargin for each output and input of <code>P</code>. See also <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>, <a href="#RobustAndOptimalControl.sim_diskmargin"><code>sim_diskmargin</code></a>. Ref: &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L339-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, Vararg{Any}}" href="#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loop_diskmargin(L, args...; kwargs...)</code></pre><p>Calculate the loop-at-a-time diskmargin for each output of <code>L</code>.</p><p>See also <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>, <a href="#RobustAndOptimalControl.sim_diskmargin"><code>sim_diskmargin</code></a>. Ref: &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L323-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.loop_scale" href="#RobustAndOptimalControl.loop_scale"><code>RobustAndOptimalControl.loop_scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loop_scale(L::LTISystem, w = 0)</code></pre><p>Find the optimal diagonal scaling matrix <code>D</code> such that <code>D\L(iw)*D</code> has a minimized condition number at frequency <code>w</code>. Applicable to square <code>L</code> only. Use <a href="#RobustAndOptimalControl.loop_scaling"><code>loop_scaling</code></a> to obtain <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L421-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.loop_scaling" href="#RobustAndOptimalControl.loop_scaling"><code>RobustAndOptimalControl.loop_scaling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loop_scaling(M0::Matrix, tol = 0.0001)</code></pre><p>Find the optimal diagonal scaling matrix <code>D</code> such that <code>D\M0*D</code> has a minimized condition number. Applicable to square <code>M0</code> only. See also <a href="#RobustAndOptimalControl.structured_singular_value-Tuple{ControlSystems.LTISystem, AbstractVector}"><code>structured_singular_value</code></a> with option <code>dynamic=true</code>. Use <a href="#RobustAndOptimalControl.loop_scale"><code>loop_scale</code></a> to find and apply the scaling to a loop-transfer function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L377-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.makeweight-Tuple{Any, Number, Any}" href="#RobustAndOptimalControl.makeweight-Tuple{Any, Number, Any}"><code>RobustAndOptimalControl.makeweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makeweight(low, f_mid, high)
makeweight(low, (f_mid, gain_mid), high)</code></pre><p>Create a weighting function that goes from gain <code>low</code> at zero frequency, through gain <code>gain_mid</code> to gain <code>high</code> at ∞</p><p><strong>Arguments:</strong></p><ul><li><code>low</code>: A number specifying the DC gain </li><li><code>mid</code>: A number specifying the frequency at which the gain is 1, or a tuple <code>(freq, gain)</code>. If <code>gain_mid</code> is not specified, the geometric mean of <code>high</code> and <code>low</code> is used.</li><li><code>high</code>: A number specifying the gain at ∞</li></ul><pre><code class="language- hljs">using ControlSystems, Plots
W = makeweight(10, (5,2), 1/10)
bodeplot(W)
hline!([10, 2, 1/10], l=(:black, :dash), primary=false)
vline!([5], l=(:black, :dash), primary=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/weights.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}" href="#RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}"><code>RobustAndOptimalControl.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure(s::NamedStateSpace, names)</code></pre><p>Return a system with specified states as measurement outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/named_systems2.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.muplot" href="#RobustAndOptimalControl.muplot"><code>RobustAndOptimalControl.muplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">muplot(sys, args...; hz=false)
muplot(LTISystem[sys1, sys2...], args...; hz=false)</code></pre><p>Plot the structured singular values of the frequency response of the <code>LTISystem</code>(s). This plot is similar to <code>sigmaplot</code>, but scales the loop-transfer function to minimize the maximum singular value. Only applicable to square systems. A frequency vector <code>w</code> can be optionally provided.</p><p>If <code>hz=true</code>, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.</p><p><code>kwargs</code> is sent as argument to Plots.plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/plotting.jl#L159-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.mvnyquistplot" href="#RobustAndOptimalControl.mvnyquistplot"><code>RobustAndOptimalControl.mvnyquistplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fig = mvnyquistplot(sys, w;  unit_circle=false, hz = false, kwargs...)</code></pre><p>Create a Nyquist plot of the <code>LTISystem</code>. A frequency vector <code>w</code> must be provided.</p><ul><li><code>unit_circle</code>: if the unit circle should be displayed</li></ul><p>If <code>hz=true</code>, the hover information will be displayed in Hertz, the input frequency vector is still treated as rad/s.</p><p><code>kwargs</code> is sent as argument to plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/plotting.jl#L100-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T" href="#RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.named_ss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">named_ss(sys::AbstractStateSpace{T}; x, u, y)</code></pre><p>Create a <code>NamedStateSpace</code> system. This kind of system uses names rather than integer indices to refer to states, inputs and outputs</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: A system to add names to.</li><li><code>x</code>: A list of symbols with names of the states.</li><li><code>u</code>: A list of symbols with names of the inputs.</li><li><code>y</code>: A list of symbols with names of the outputs.</li></ul><p>Default names of signals if none are provided are <code>x,u,y</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">G1 = ss(1,1,1,0)
G2 = ss(1,1,1,0)
s1 = named_ss(G1, x = :x, u = :u1, y=:y1)
s2 = named_ss(G2, x = :z, u = :u2, y=:y2)

s1[:y1, :u1] # Index using symbols

fb = feedback(s1, s2, r = :r) # </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/named_systems2.jl#L96-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}" href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>RobustAndOptimalControl.ncfmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">m, ω = ncfmargin(P, K)</code></pre><p>Normalized coprime factor margin, defined has the inverse H∞ norm of</p><p class="math-container">\[\begin{bmatrix}
I \\ K
\end{bmatrix} (I + PK)^{-1} \begin{bmatrix}
I &amp; P
\end{bmatrix}\]</p><p>A margin ≥ 0.25-0.3 is a reasonable for robustness. </p><p>If controller <code>K</code> stabilizes <code>P</code> with margin <code>m</code>, then <code>K</code> will also stabilize <code>P̃</code> if <code>nugap(P, P̃) &lt; m</code>.</p><p>See also <a href="#RobustAndOptimalControl.extended_gangoffour-Tuple{Any, Any}"><code>extended_gangoffour</code></a>, <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/glover_mcfarlane.jl#L218-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.neglected_delay-Tuple{Any}" href="#RobustAndOptimalControl.neglected_delay-Tuple{Any}"><code>RobustAndOptimalControl.neglected_delay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neglected_delay(Lmax)</code></pre><p>Return a multiplicative weight to represent the uncertainty coming from neglecting the dynamics <code>exp(-s*L)</code> where <code>L ≤ Lmax</code>. &quot;Multivariable Feedback Control: Analysis and Design&quot; Ch 7.4.5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/weights.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.neglected_lag-Tuple{Any}" href="#RobustAndOptimalControl.neglected_lag-Tuple{Any}"><code>RobustAndOptimalControl.neglected_lag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neglected_lag(τmax)</code></pre><p>Return a multiplicative weight to represent the uncertainty coming from neglecting the dynamics <code>1/(s*τ + 1)</code> where <code>τ ≤ τmax</code>. &quot;Multivariable Feedback Control: Analysis and Design&quot; Ch 7.4.5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/weights.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.noise_mapping-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.noise_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.noise_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noise_mapping(P::ExtendedStateSpace)</code></pre><p>Return the system from w -&gt; y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/ExtendedStateSpace.jl#L515-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.nugap-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem}" href="#RobustAndOptimalControl.nugap-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem}"><code>RobustAndOptimalControl.nugap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nugap(sys0::LTISystem, sys1::LTISystem; kwargs...)</code></pre><p>Compute the ν-gap metric between two systems. See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.gnugap</code>, reproduced below</p><pre><code class="nohighlight hljs">gnugap(sys1, sys2; freq = ω, rtolinf = 0.00001, fast = true, offset = sqrt(ϵ), 
       atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (nugapdist, fpeak)</code></pre><p>Compute the ν-gap distance <code>nugapdist</code> between two descriptor systems <code>sys1 = (A1-λE1,B1,C1,D1)</code> and  <code>sys2 = (A2-λE2,B2,C2,D2)</code> and the corresponding frequency <code>fpeak</code> (in rad/TimeUnit), where the ν-gap  distance achieves its peak value. </p><p>If <code>freq = missing</code>, the resulting <code>nugapdist</code> satisfies <code>0 &lt;= nugapdist &lt;= 1</code>.  The value <code>nugapdist = 1</code> results, if the winding number is different of zero in which case <code>fpeak = []</code>. </p><p>If <code>freq = ω</code>, where <code>ω</code> is a given vector of real frequency values, the resulting <code>nugapdist</code> is a vector  of pointwise ν-gap distances of the dimension of <code>ω</code>, whose components satisfies <code>0 &lt;= maximum(nugapdist) &lt;= 1</code>.  In this case, <code>fpeak</code> is the frequency for which the pointwise distance achieves its peak value.  All components of <code>nugapdist</code> are set to 1 if the winding number is different of zero in which case <code>fpeak = []</code>.</p><p>The stability boundary offset, <code>β</code>, to be used to assess the finite zeros which belong to the boundary of the stability domain can be specified via the keyword parameter <code>offset = β</code>. Accordingly, for a continuous-time system, these are the finite zeros having  real parts within the interval <code>[-β,β]</code>, while for a discrete-time system,  these are the finite zeros having moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>Pencil reduction algorithms are employed to compute range and coimage spaces  which perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code> and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A1</code>, <code>A2</code>, <code>B1</code>, <code>B2</code>, <code>C1</code>, <code>C2</code>, <code>D1</code> and <code>D2</code>, the absolute tolerance for the nonzero elements of <code>E1</code> and <code>E2</code>,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximum of the orders of the systems <code>sys1</code> and <code>sys2</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy to be used  to compute the ν-gap as the infinity norm of the relevant system according to [1].  The default value used for <code>rtolinf</code> is <code>0.00001</code>.</p><p><em>Method:</em> The evaluation of ν-gap uses the definition proposed in [1], extended to generalized LTI (descriptor) systems. The computation of winding number is based on enhancements covering zeros on the boundary of the  stability domain and infinite zeros.</p><p><em>References:</em></p><p>[1] G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/descriptor.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}" href="#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.output_comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_comp_sensitivity(P,C)
output_comp_sensitivity(l::LQGProblem)</code></pre><p>Transfer function from measurement noise / reference to plant output.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case plant output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L414-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}" href="#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}"><code>RobustAndOptimalControl.output_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_sensitivity(P, C)
output_sensitivity(l::LQGProblem)</code></pre><p>Transfer function from measurement noise / reference to control signal.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L383-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace, Int64, Int64}" href="#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace, Int64, Int64}"><code>RobustAndOptimalControl.partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition(P::AbstractStateSpace, nw::Int, nz::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/ExtendedStateSpace.jl#L491-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}" href="#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}"><code>RobustAndOptimalControl.partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition(P::AbstractStateSpace; u, y, w=!u, z=!y)</code></pre><p>Partition <code>P</code> into an <a href="@ref"><code>ExtendedStateSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/ExtendedStateSpace.jl#L462-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.performance_mapping-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.performance_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.performance_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">performance_mapping(P::ExtendedStateSpace)</code></pre><p>Return the system from w -&gt; z</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/ExtendedStateSpace.jl#L506-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}" href="#RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}"><code>RobustAndOptimalControl.robstab</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">robstab(M0::UncertainSS, w=exp10.(LinRange(-3, 3, 1500)); kwargs...)</code></pre><p>Return the robust stability margin of an uncertain model, defined as the inverse of the structured singular value. Currently, only diagonal complex perturbations supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L224-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sensitivity-Tuple" href="#RobustAndOptimalControl.sensitivity-Tuple"><code>RobustAndOptimalControl.sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a></p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │-    └─────┘     │
      │                 │
      │     ┌─────┐     │
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li>Input  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹</li><li>Output sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹</li><li>Input  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹</li><li>Output complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/lqg.jl#L326-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.show_construction-Tuple{IO, ControlSystems.LTISystem}" href="#RobustAndOptimalControl.show_construction-Tuple{IO, ControlSystems.LTISystem}"><code>RobustAndOptimalControl.show_construction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show_construction([io::IO,] sys::LTISystem; name = &quot;temp&quot;, letb = true)</code></pre><p>Print code to <code>io</code> that reconstructs <code>sys</code>.</p><ul><li><code>letb</code>: If true, the code is surrounded by a let block.</li></ul><pre><code class="language- hljs">julia&gt; sys = ss(tf(1, [1, 1]))
StateSpace{Continuous, Float64}
A = 
 -1.0
B = 
 1.0
C = 
 1.0
D = 
 0.0

Continuous-time state-space model

julia&gt; show_construction(sys, name=&quot;Jörgen&quot;)
sys = let
    JörgenA = [-1.0;;]
    JörgenB = [1.0;;]
    JörgenC = [1.0;;]
    JörgenD = [0.0;;]
    ss(JörgenA, JörgenB, JörgenC, JörgenD)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/utils.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sim_diskmargin" href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_diskmargin(L, σ::Real = 0)</code></pre><p>Return the smallest simultaneous diskmargin over the grid 1e-3:1e3 See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L287-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sim_diskmargin" href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_diskmargin(P::LTISystem, C::LTISystem, σ::Real = 0)</code></pre><p>Simultaneuous diskmargin at both outputs and inputs of <code>P</code>. Ref: &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771 See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L274-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sim_diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractVector}" href="#RobustAndOptimalControl.sim_diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractVector}"><code>RobustAndOptimalControl.sim_diskmargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_diskmargin(L, σ::Real, w::AbstractVector)
sim_diskmargin(L, σ::Real = 0)</code></pre><p>Simultaneuous diskmargin at the outputs of <code>L</code>.  Uses should consider using <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L256-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.specificationplot" href="#RobustAndOptimalControl.specificationplot"><code>RobustAndOptimalControl.specificationplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">specificationplot([S,CS,T], [WS,WU,WT])</code></pre><p>This function visualizes the control synthesis using the hInf_synthesize with the three weighting functions {WS(jω), WU(jω), WT(jω)} inverted and scaled by γ, against the corresponding transfer fucntions {S(jω), C(jω)S(jω), T(jω)}, to verify visually that the specifications are met. This may be run using both MIMO and SISO systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/plotting.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.structured_singular_value-Tuple{ControlSystems.LTISystem, AbstractVector}" href="#RobustAndOptimalControl.structured_singular_value-Tuple{ControlSystems.LTISystem, AbstractVector}"><code>RobustAndOptimalControl.structured_singular_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">structured_singular_value(M0::UncertainSS, [w::AbstractVector]; kwargs...)</code></pre><ul><li><code>w</code>: Frequency vector, if none is provided, the maximum μ over a brid 1e-3 : 1e3 will be returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T" href="#RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.structured_singular_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">μ = structured_singular_value(M; tol=1e-4, scalings=false, dynamic=false)</code></pre><p>Compute (an upper bound of) the structured singular value μ for diagonal Δ of complex perturbations (other structures of Δ are not yet supported). <code>M</code> is assumed to be an (n × n × N_freq) array or a matrix.</p><p>We currently don&#39;t have any methods to compute a lower bound, but if all perturbations are complex the spectral radius <code>ρ(M)</code> is always a lower bound (usually not a good one).</p><p>If <code>scalings = true</code>, return also a <code>n × nf</code> matrix <code>Dm</code> with the diagonal scalings <code>D</code> such that</p><pre><code class="nohighlight hljs">D = Diagonal(Dm[:, i])
σ̄(D\M[:,:,i]*D)</code></pre><p>is minimized.</p><p>If <code>dynamic = true</code>, the perturbations are assumed to be time-varying <code>Δ(t)</code>. In this case, the same scaling is used for all frequencies and the returned <code>D</code> if <code>scalings=true</code> is a vector <code>d</code> such that <code>D = Diagonal(d)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/mimo_diskmargin.jl#L146-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.sumblock-Tuple{String}" href="#RobustAndOptimalControl.sumblock-Tuple{String}"><code>RobustAndOptimalControl.sumblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sumblock(ex::String; Ts = 0, n = 1)</code></pre><p>Create a summation node that sums (or subtracts) vectors of length <code>n</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>Ts</code>: Sample time</li><li><code>n</code>: The length of the input and output vectors. Set <code>n=1</code> for scalars.</li></ul><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; sumblock(&quot;uP = vf + yL&quot;)
NamedStateSpace{Continuous, Int64}
D = 
 1  1

With state  names: 
     input  names: vf yL
     output names: uP


julia&gt; sumblock(&quot;x_diff = xr - xh&quot;; n=3)
NamedStateSpace{Continuous, Int64}
D = 
 1  0  0  -1   0   0
 0  1  0   0  -1   0
 0  0  1   0   0  -1

With state  names: 
     input  names: xr1 xr2 xr3 xh1 xh2 xh3
     output names: x_diff1 x_diff2 x_diff3
     

julia&gt; sumblock(&quot;a = b + c - d&quot;)
NamedStateSpace{Continuous, Int64}
D = 
 1  1  -1

With state  names: 
     input  names: b c d
     output names: a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/named_systems2.jl#L411-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.system_mapping-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.system_mapping-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.system_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">system_mapping(P::ExtendedStateSpace)</code></pre><p>Return the system from u -&gt; y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/ExtendedStateSpace.jl#L497-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.uss" href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uss(d::AbstractVector{&lt;:δ}, Ts = nothing)</code></pre><p>Create a diagonal uncertain statespace object with the uncertain elements <code>d</code> on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/uncertainty_interface.jl#L201-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.uss" href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uss(D::AbstractArray, Δ, Ts = nothing)</code></pre><p>If only a single <code>D</code> matrix is provided, it&#39;s treated as <code>D11</code> if Δ is given, and as <code>D22</code> if no Δ is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/uncertainty_interface.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.uss" href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uss(D11, D12, D21, D22, Δ, Ts = nothing)</code></pre><p>Create an uncertain statespace object with only gin matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/uncertainty_interface.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}" href="#RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uss(d::δ{C, F}, Ts = nothing)</code></pre><p>Convert a δ object to an UncertainSS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/uncertainty_interface.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.vec2sys" href="#RobustAndOptimalControl.vec2sys"><code>RobustAndOptimalControl.vec2sys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vec2sys(v::AbstractArray, ny::Int, nu::Int, ts = nothing)</code></pre><p>Create a statespace system from the parameters</p><pre><code class="language-julia hljs">v = vec(sys) = [vec(sys.A); vec(sys.B); vec(sys.C); vec(sys.D)]</code></pre><p>Use <code>vec(sys)</code> to create <code>v</code>.</p><p>This can be useful in order to convert to and from vectors for, e.g., optimization.</p><pre><code class="language- hljs">julia&gt; sys  = ss(tf(1, [1, 1]))
StateSpace{Continuous, Float64}
A = 
 -1.0
B = 
 1.0
C = 
 1.0
D = 
 0.0

Continuous-time state-space model

julia&gt; v    = vec(sys)
4-element Vector{Float64}:
 -1.0
  1.0
  1.0
  0.0

julia&gt; sys2 = vec2sys(v, sys.ny, sys.nu)
StateSpace{Continuous, Float64}
A = 
 -1.0
B = 
 1.0
C = 
 1.0
D = 
 0.0

Continuous-time state-space model</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/utils.jl#L56-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.δc" href="#RobustAndOptimalControl.δc"><code>RobustAndOptimalControl.δc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">δc(val::Complex = complex(0.0), radius::Real = 1.0, name)</code></pre><p>Create a complex, uncertain parameter. If no name is given, a boring name will be generated automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/uncertainty_interface.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustAndOptimalControl.δr" href="#RobustAndOptimalControl.δr"><code>RobustAndOptimalControl.δr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">δr(val::Real = 0.0, radius::Real = 1.0, name)</code></pre><p>Create a real, uncertain parameter. If no name is given, a boring name will be generated automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/752ee33bed86cd1e66809d6a1f5a44cb30451775/src/uncertainty_interface.jl#L20-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="uncertainty/">Uncertainty modeling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 14 January 2022 21:08">Friday 14 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
