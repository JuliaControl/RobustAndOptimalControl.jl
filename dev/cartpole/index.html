<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Control design for a pendulum on a cart · RobustAndOptimalControl Documentation</title><meta name="title" content="Control design for a pendulum on a cart · RobustAndOptimalControl Documentation"/><meta property="og:title" content="Control design for a pendulum on a cart · RobustAndOptimalControl Documentation"/><meta property="twitter:title" content="Control design for a pendulum on a cart · RobustAndOptimalControl Documentation"/><meta name="description" content="Documentation for RobustAndOptimalControl Documentation."/><meta property="og:description" content="Documentation for RobustAndOptimalControl Documentation."/><meta property="twitter:description" content="Documentation for RobustAndOptimalControl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RobustAndOptimalControl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../uncertainty/">Uncertainty modeling</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../hinf_DC/">Simple mixed-sensitivity <span>$H_\infty$</span> design</a></li><li><a class="tocitem" href="../hinf_connection/">General <span>$H_\infty$</span> design</a></li><li><a class="tocitem" href="../lqg_disturbance/">LQG control with integral action</a></li><li class="is-active"><a class="tocitem" href>Control design for a pendulum on a cart</a><ul class="internal"><li><a class="tocitem" href="#System-model"><span>System model</span></a></li><li><a class="tocitem" href="#Linearization"><span>Linearization</span></a></li><li><a class="tocitem" href="#Control-design"><span>Control design</span></a></li><li><a class="tocitem" href="#PID-controller"><span>PID controller</span></a></li><li><a class="tocitem" href="#Pole-placement-and-observer-design"><span>Pole placement and observer design</span></a></li><li><a class="tocitem" href="#Cascade-control"><span>Cascade control</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../measurable_disturbance/"><span>$H_2$</span> design with a known disturbance</a></li><li><a class="tocitem" href="../similarity/">When are systems similar?</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Control design for a pendulum on a cart</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Control design for a pendulum on a cart</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/docs/src/cartpole.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Control-design-for-a-pendulum-on-a-cart"><a class="docs-heading-anchor" href="#Control-design-for-a-pendulum-on-a-cart">Control design for a pendulum on a cart</a><a id="Control-design-for-a-pendulum-on-a-cart-1"></a><a class="docs-heading-anchor-permalink" href="#Control-design-for-a-pendulum-on-a-cart" title="Permalink"></a></h1><p>In this example we will consider control design for the basic inverted pendulum on a cart. This system has two equilibria, one where the pendulum is hanging straight down, and one where it&#39;s balancing straight up. The upper one is unstable, making it slightly more interesting to design a controller for (even if the lower equilibrium is highly relevant, it&#39;s a good model for an overhead crane moving goods).</p><h2 id="System-model"><a class="docs-heading-anchor" href="#System-model">System model</a><a id="System-model-1"></a><a class="docs-heading-anchor-permalink" href="#System-model" title="Permalink"></a></h2><p>In this tutorial, we assume that we have the nonlinear dynamics of the system encodeed as a julia function <code>ẋ = cartpole(x, u)</code>, and linearize this to get a statespace system</p><p class="math-container">\[\begin{aligned}
ẋ &amp;= Ax + Bu\\
y &amp;= Cx
\end{aligned}\]</p><p>We make use of <a href="https://github.com/JuliaDiff/ForwardDiff.jl/">ForwardDiff.jl</a> for the linearization. We start by defining the dynamics function</p><pre><code class="language-julia hljs">using ControlSystemsBase, RobustAndOptimalControl, ForwardDiff, LinearAlgebra, Plots

function cartpole(x, u)
    mc, mp, l, g = 1.0, 0.2, 0.5, 9.81

    q  = x[1:2]
    qd = x[3:4]

    s = sin(q[2])
    c = cos(q[2])

    H = [mc+mp mp*l*c; mp*l*c mp*l^2]
    C = [0.1 -mp*qd[2]*l*s; 0 0]
    G = [0, mp * g * l * s]
    B = [1, 0]

    qdd = -H \ (C * qd + G - B * u[1])
    return [qd; qdd]
end

nu = 1    # number of control inputs
nx = 4    # number of states
ny = 2    # number of outputs (here we assume that the cart position and the pendulum angle are measurable)</code></pre><h2 id="Linearization"><a class="docs-heading-anchor" href="#Linearization">Linearization</a><a id="Linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Linearization" title="Permalink"></a></h2><p>The next step is to choose an operating point around which to linearize and to calculate the Jacobians <span>$A$</span> and <span>$B$</span>:</p><pre><code class="language-julia hljs">x0 = [0, π, 0, 0]
u0 = [0]

Ac = ForwardDiff.jacobian(x-&gt;cartpole(x, u0), x0)
Bc = ForwardDiff.jacobian(u-&gt;cartpole(x0, u), u0)
Cc = [1 0 0 0; 0 1 0 0]
Λ = Diagonal([0.4, deg2rad(25)]) # Maximum output ranges
Cc = Λ\Cc # This normalizes expected outputs to be ∈ [-1, 1], a good practice for MIMO systems</code></pre><p>we package everything into a <a href="@ref"><code>StateSpace</code></a> object and visualize its poles and zeros:</p><pre><code class="language-julia hljs">sys = ss(Ac, Bc, Cc, 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StateSpace{Continuous, Float64}
A = 
 0.0   0.0                  1.0  0.0
 0.0   0.0                  0.0  1.0
 0.0   1.9620000000000002  -0.1  0.0
 0.0  23.544               -0.2  0.0
B = 
 0.0
 0.0
 1.0
 2.0
C = 
 2.5  0.0                0.0  0.0
 0.0  2.291831180523293  0.0  0.0
D = 
 0.0
 0.0

Continuous-time state-space model</code></pre><pre><code class="language-julia hljs">pzmap(sys)</code></pre><img src="32d829ff.svg" alt="Example block output"/><h2 id="Control-design"><a class="docs-heading-anchor" href="#Control-design">Control design</a><a id="Control-design-1"></a><a class="docs-heading-anchor-permalink" href="#Control-design" title="Permalink"></a></h2><p>We will design a number of different controllers. We will start with a basic PID controller. Since the PID controller in its standard form really only handles SISO systems, we will also design a state-feedback controller with an observer to estimate the full state vector <span>$x$</span> based on the two measurements <span>$y$</span>. Lastly, we will attempt to &quot;robustify&quot; the state-feedback controller using the <a href="../api/#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a> procedure.</p><p>Since the system has an unstable pole <span>$p \approx 4.85$</span>rad/s, there wil be fundamental limitations on the performance of the closed loop system. A common rule-of-thumb (see, e.g., Åström and Murray) is that a single RHP pole <span>$p$</span> puts a <em>lower</em> limit on the gain crossover frequency <span>$\omega_{gc} &gt; 2p$</span>, something to take into consideration when tuning our controllers. </p><h2 id="PID-controller"><a class="docs-heading-anchor" href="#PID-controller">PID controller</a><a id="PID-controller-1"></a><a class="docs-heading-anchor-permalink" href="#PID-controller" title="Permalink"></a></h2><p>Since the PID controller only accepts a single measurement, we choose the measurement of the pendulum angle for feedback. While doing so, we notice that the number of states in the model can be reduced by the function <a href="https://juliacontrol.github.io/ControlSystemsBase.jl/latest/lib/synthesis/#ControlSystemsBase.sminreal-Tuple{StateSpace}"><code>sminreal</code></a></p><pre><code class="language-julia hljs">P = sminreal(sys[2,1]) # Position state goes away, not observable</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StateSpace{Continuous, Float64}
A = 
  0.0                  0.0  1.0
  1.9620000000000002  -0.1  0.0
 23.544               -0.2  0.0
B = 
 0.0
 1.0
 2.0
C = 
 2.291831180523293  0.0  0.0
D = 
 0.0

Continuous-time state-space model</code></pre><p>this indicates that the state corresponding to the position of the cart is not observable from the measurement of the pendulum angle. This is slightly worrisome, but we nevertheless proceed to design a controller. By using a single measurement only, we have also introduced a zero in the system</p><pre><code class="language-julia hljs">pzmap(P)</code></pre><img src="355afe72.svg" alt="Example block output"/><p>A PID controller can be constructed using the function <a href="https://juliacontrol.github.io/ControlSystemsBase.jl/latest/lib/synthesis/#ControlSystemsBase.pid-Tuple{}"><code>pid</code></a>. We start our tuning by a simple P controller</p><pre><code class="language-julia hljs">C = pid(1, 0, 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TransferFunction{Continuous, ControlSystemsBase.SisoRational{Int64}}
1
-
1

Continuous-time transfer function model</code></pre><p>We will attempt to perform loop shaping using the PID controller, and plot the stability margins in a Bode plot using the function <code>marginplot</code></p><pre><code class="language-julia hljs">w = exp10.(LinRange(-2.5, 3, 500))
function pid_marginplot(C)
    f1 = marginplot(P*C, w)
    vline!([2*4.85], sp=1, lab=&quot;Fundamental limitation&quot;, l=(:dash, :black))
    ylims!((1e-3, 1e2), sp=1)
    f2 = nyquistplot(P*C)
    plot(f1, f2)
end
pid_marginplot(C)</code></pre><img src="6d6a0f80.svg" alt="Example block output"/><p>We notice that the gain of the loop-transfer function <span>$L = PC$</span> is much too low, and increase it, we also notice that the Nyquist plot fails to encircle to critical point, which it has to do once since we have one unstable pole. We will solve this in the end by adding integral action, but proceed for now to shape other parts of the loop. We start by lifting the Bode curve by increasing the gain:</p><pre><code class="language-julia hljs">C = pid(20, 0, 0)
pid_marginplot(C)</code></pre><img src="e8ffd924.svg" alt="Example block output"/><p>we are now getting close to the rule-of-thumb for <span>$\omega_{gc}$</span>, but have a low loop gain at low frequencies. Remember, to get good disturbance rejection, we typically want a high loop gain at low frequencies. We also have an extremely small phase margin at 0.66 degrees. To fix the phase margin, we add some derivative gain. While adding derivative gain, it&#39;s also a good idea to add noise filtering (with a pure derivative term, the PID controller is not proper and can not be realized as a statespace system)</p><pre><code class="language-julia hljs">C = pid(20, 0, 0.2, Tf=0.01)
pid_marginplot(C)</code></pre><img src="0a782ab7.svg" alt="Example block output"/><p>The derivative term lifted the phase at <span>$\omega_{gc}$</span> and we now have very nice phase margins. We also got a slight increase in <span>$\omega_{gc}$</span> while at it. </p><p>The closed-loop system will still be unstable since the Nyquist curve fails to encircle the point -1, something we can check by calling</p><pre><code class="language-julia hljs">isstable(feedback(P*C))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>We make the Nyquist curve wrap around the -1 point by adding integral gain:</p><pre><code class="language-julia hljs">C = pid(20, 1.25, 0.2, Tf=0.01)
pid_marginplot(C)</code></pre><img src="08eda985.svg" alt="Example block output"/><p>Now, the Nyquist curve looks fine and the system is stable</p><pre><code class="language-julia hljs">isstable(minreal(feedback(P*C)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>If we simulate a disturbance acting on this system (<code>feedback(P, C)</code> is the transfer function from load disturbance to output)</p><pre><code class="language-julia hljs">plot(step(feedback(P,C), 8), ylab=&quot;ϕ&quot;)</code></pre><img src="9a9fb5a0.svg" alt="Example block output"/><p>we see that we have a reasonable disturbance response. </p><p>To verify robustness properties, we plot the gang-of-four sensitivity functions:</p><pre><code class="language-julia hljs">f1 = gangoffourplot(P,C,w, Ms_lines=[1.4], Mt_lines=[1.5])
f2 = nyquistplot(P*C, Ms_circles=[1.4], Mt_circles=[1.5], ylims=(-2, 2), xlims=(-4,1))
plot(f1, f2, size=(1000,800))</code></pre><img src="5757037f.svg" alt="Example block output"/><p>This all looks nice and we appear to have reasonable robustness margins, the Nyquist curve stays outside the <span>$M_S = 1.4$</span> circle and the <span>$M_T = 1.5$</span> circle.</p><p>However, there is a dragon lurking behind these plots. Remember the state corresponding the the cart position that was removed above? What has happened to this state? To investigate this, we form an <a href="../api/#RobustAndOptimalControl.ExtendedStateSpace"><code>ExtendedStateSpace</code></a> model where we have both cart position and pendulum angle as controlled outputs, while keeping only the pendulum angle as measured output:</p><pre><code class="language-julia hljs">Pe = ExtendedStateSpace(sys, C2 = sys.C[2:2, :]) # Indicate that we can only measure the pendulum angle
Gecl = feedback(Pe, ss(C)) |&gt; minreal
plot(step(Gecl, 8), ylab=[&quot;Cart pos&quot; &quot;ϕ&quot;])</code></pre><img src="8922c023.svg" alt="Example block output"/><p>We see that the cart position drifts away without ever thinking about stopping. Indeed, the PID controller is unaware of this and can not really do anything about it. We could attempt to design a second control loop that would close the loop around the cart position, but we would have to carefully manage the interactions between the two loops. Instead, we move on to a state-feedback design, a methodology that makes handling multiple outputs much more straightforward. </p><h2 id="Pole-placement-and-observer-design"><a class="docs-heading-anchor" href="#Pole-placement-and-observer-design">Pole placement and observer design</a><a id="Pole-placement-and-observer-design-1"></a><a class="docs-heading-anchor-permalink" href="#Pole-placement-and-observer-design" title="Permalink"></a></h2><p>The design of a state-feedback controller typically involves two steps, designing the feedback gain and designing an observer. We will arrive at the feedback gain through pole placement, but will design the observer as a Kalman filter, i.e., by solving a Riccati equation rather than using Ackermann&#39;s formula. </p><p>When performing pole placement, there are a number of design guidlines that help you arrive at a robust design. One of these are that past process poles should be matched with an equally fast closed-loop pole. We can get an overview of the open-loop poles with <code>dampreport</code></p><pre><code class="language-julia hljs">dampreport(sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|        Pole        |   Damping     |   Frequency   |   Frequency   | Time Constant |
|                    |    Ratio      |   (rad/sec)   |     (Hz)      |     (sec)     |
+--------------------+---------------+---------------+---------------+---------------+
| +0                 |  -1           |  0            |  0            |  -Inf         |
| -0.0833            |  1            |  0.0833       |  0.0133       |  12           |
| +4.84              |  -1           |  4.84         |  0.771        |  -0.206       |
| -4.86              |  1            |  4.86         |  0.774        |  0.206        |</code></pre><p>we see that we have two poles at roughly <span>$\pm 4.85$</span>rad/s, and almost two integrators. We thus keep the fast pole, and place the unstable pole at the same location (same bandwidth but stable instead of unstable). We also try to move the integrator poles to -5 to make the system nice and fast. </p><pre><code class="language-julia hljs">desired_poles = [-4.85, -4.85, -5, -5]
L = place(sys, desired_poles, :c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×4 Matrix{Float64}:
 -29.9726  99.5196  -24.4489  22.0244</code></pre><p>For the observer, we make use of the function <code>kalman</code>. We choose the covariance matrices <code>R1, R2</code> that determine the amount of noise acting on the system and on the measurements respectively. We assume that there are two noise components, both entering as forces. One disturbance force acts on the cart and the other on the pendulum. We indicate this using the matrix <span>$B_w$</span>. </p><pre><code class="language-julia hljs">Bw = [0 0; 0 0; 1 0; 0 1]
R1 = Bw*I(2)*Bw&#39;
R2 = 0.0001I(ny)
K = kalman(sys, R1, R2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×2 Matrix{Float64}:
  8.90448     -0.0161568
 -0.0176244    9.83322
 99.1125       0.481841
 -1.31513    110.801</code></pre><p>With our feedback gain <code>L</code> and the Kalman gain <code>K</code>, we form the controller using <a href="@ref"><code>observer_controller</code></a></p><pre><code class="language-julia hljs">controller = observer_controller(sys, L, K)
@assert isstable(controller)
@assert isstable(feedback(sys * controller))</code></pre><p>We may have a look at the Nyquist plot and the gang-of-four to assess robustness margins. In this case we look at the loop transfer function at the input simply because this function is SISO while the standard output-loop transfer is MIMO. This will allow us to asses robustness w.r.t. input perturbations only</p><pre><code class="language-julia hljs">nyquistplot(controller*sys, w, Ms_circles=[2.7], Mt_circles=[3], xlims=(-2, 2), ylims=(-1, 3))</code></pre><img src="48ae5571.svg" alt="Example block output"/><p>The Nyquist plot shows a rather weak robustness margin, with a peak in the input sensitivity of about</p><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.67</code></pre><p>and a peak in the complementary sensitivity function of around</p><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.02</code></pre><p>These can be verified by calling <a href="../api/#RobustAndOptimalControl.hinfnorm2-Tuple{LTISystem}"><code>hinfnorm2</code></a></p><pre><code class="language-julia hljs">hinfnorm2(input_comp_sensitivity(sys, controller))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(3.0211911161351637, 6.672744977856102)</code></pre><div class="admonition is-info"><header class="admonition-header">Hover information</header><div class="admonition-body"><p>If you plot with the Plotly backend, activated by calling <code>plotly()</code> if you have Plotly.jl installed, you can hover the mouse over the Nyquist curve and the gain circles to see frequency information etc. This is not possible when using the default GR backend, used in this documentation.</p></div></div><p>Also the gang-of-four indicate rather poor margins:</p><pre><code class="language-julia hljs">gangoffourplot(sys, controller, w, xlabel=&quot;&quot;, sigma=false, titlefont=8)</code></pre><img src="f9b43adb.svg" alt="Example block output"/><h3 id="Robustification-using-Glover-McFarlane"><a class="docs-heading-anchor" href="#Robustification-using-Glover-McFarlane">Robustification using Glover-McFarlane</a><a id="Robustification-using-Glover-McFarlane-1"></a><a class="docs-heading-anchor-permalink" href="#Robustification-using-Glover-McFarlane" title="Permalink"></a></h3><p>In an attempt at improving this initial design, we call <a href="../api/#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a>. This can be seen as a semi-automatic approach to robustifying an initial design, and will yield us an updated controller <code>Kgmf</code> with, hopefully, improved robustness properties.</p><pre><code class="language-julia hljs">Kgmf, γ, info = glover_mcfarlane(sys, 1.05; W1=controller)
@assert isstable(Kgmf)
γ</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.339895597412645</code></pre><p>The γ is an indication of the achieved robustness. A value of <span>$γ &lt; 4$</span> is typically desired, this time we did not quite achieve that, but will nevertheless proceed and look deeper into the robustness using other means.</p><div class="admonition is-info"><header class="admonition-header">Controller order reduction</header><div class="admonition-body"><p>The Glover-McFarlane procedure often leads to high-order controllers. These controllers can sometimes be simplified by calling <a href="../api/#RobustAndOptimalControl.controller_reduction"><code>controller_reduction</code></a>, i.e., like this</p><pre><code class="language-julia hljs">Kgmfr, hs = controller_reduction(ExtendedStateSpace(sys), -Kgmf, 9) # Expects positive-feedback controller
Kgmfr = -Kgmfr # Flip sign again
Kgmfr.D .*= 0.0 # a hack to get better rolloff after reduction</code></pre></div></div><h3 id="Robustness-verification"><a class="docs-heading-anchor" href="#Robustness-verification">Robustness verification</a><a id="Robustness-verification-1"></a><a class="docs-heading-anchor-permalink" href="#Robustness-verification" title="Permalink"></a></h3><p>We will now verify these designs in a number of ways. We start by inspecting sensitivity functions at the input, this function tells you how a load disturbance at the plant input translates to total plant input (including control action)</p><pre><code class="language-julia hljs">f1 = bodeplot([controller*sys, Kgmf*sys], w, plot_title=&quot;Input Loop transfers&quot;, lab=[&quot;Pole placement&quot; &quot;&quot; &quot;GMF&quot; &quot;&quot;]); vline!([2*4.85], sp=1, lab=&quot;Fundamental limitation&quot;, l=(:dash, :black))
f2 = nyquistplot([controller*sys, Kgmf*sys], xlims=(-4, 4), ylims=(-1, 5), Ms_circles=[2.7], Mt_circles=[3], lab=[&quot;Pole placement&quot; &quot;GMF&quot;])
f3 = bodeplot(controller, w, lab=&quot;Pole placement&quot;)
bodeplot!(Kgmf, w, plot_title=&quot;Controllers&quot;, lab=&quot;GMF&quot;, legend=:bottomleft)
f4 = sigmaplot([
    input_sensitivity(sys, controller),
    input_sensitivity(sys, Kgmf)
    ], w, title=&quot;Input S&quot;, lab=[&quot;Pole placement&quot; &quot;GMF&quot;], legend=:bottomright)
plot(f1,f2,f3,f4, size=(1000,1000))</code></pre><img src="92bcbee9.svg" alt="Example block output"/><p>We see that the Glover-Mcfarlane method increased the gain crossover frequency <span>$\omega_{gc}$</span> slightly compared to the initial pole-placement controller, as well as lifted the phase even further. It also increased the roll-off, providing better filtering of high-frequency noise. However, it uses quite a bit more gain from the measurement of the pendulum angle.</p><p>The gang-of-four, shown below, looks slightly better for the GMF controller, shown in orange.</p><pre><code class="language-julia hljs">gangoffourplot(sys, [controller, Kgmf], w, xlabel=&quot;&quot;, sigma=false, titlefontsize=8)</code></pre><img src="9957c2ae.svg" alt="Example block output"/><p>The robustified controller has better disturbance rejection (<span>$P/(I + PC)$</span>) and slightly lower peaks in the sensitivity and complementary sensitivity functions.</p><p>Inspecting the singular values of the output sensitivity, we see that the GMF controller reduces the peak and improves the disturbance rejection for the lower singular value, while leaving the upper singular value more or less where it is for low frequencies.</p><pre><code class="language-julia hljs">sigmaplot(sensitivity.(Ref(sys), [controller, Kgmf]), w, lab=[&quot;Pole placement&quot; &quot;GMF&quot;], legend=:bottomright)</code></pre><img src="ded5ccec.svg" alt="Example block output"/><p>Further verification of robustness properties can be conducted by inspecting the diskmargins at inputs and at outputs</p><pre><code class="language-julia hljs">dmf1 = plot(diskmargin(sys*controller), title=&quot;Simultaneous Output diskmargin&quot;, lab=&quot;Pole placement&quot;)
dmf2 = plot(diskmargin(controller*sys), title=&quot;Input diskmargin&quot;, lab=&quot;Pole placement&quot;)
plot!(dmf1, diskmargin(sys*Kgmf), title=&quot;Simultaneous Output diskmargin&quot;, lab=&quot;GMF&quot;)
plot!(dmf2, diskmargin(Kgmf*sys), title=&quot;Input diskmargin&quot;, lab=&quot;GMF&quot;)
plot(dmf1, dmf2)</code></pre><img src="84240ada.svg" alt="Example block output"/><p>With the robustified controller, ee can tolerate a gain variation of about 1.6 at the plant input, but only 1.23 at the plant output. Please note that simultaneous margins can be quite conservative, it&#39;s much less likely that both outputs have equally large gain errors at the same time. One can also investigate the margins for one loop at a time using <a href="../api/#RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, LTISystem, Vararg{Any}}"><code>loop_diskmargin</code></a>.</p><h3 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h3><p>Finally, it&#39;s time to simulate the system. First we simulate the response to a reference step for the cart position, to make sure the cart takes a reasonalbe smooth step, keeping the pendulum angle within the validity range of the linearization, we let the step be a ramp from 0 to 1 over the course of one second, implemented by passing the input function <span>$u(x,t) \rightarrow [\operatorname{min}(t, 1)]$</span></p><pre><code class="language-julia hljs">rampsim(sys) = lsim(sys[:, 1], (x,t)-&gt;[min(t, 1)], 0:0.01:3.5, method=:zoh) # helper function to simulate ramp input
plot([
    rampsim(feedback(sys*controller)),
    rampsim(feedback(sys*Kgmf)),
], ylab=[&quot;Pos&quot; &quot;Angle&quot;], plot_title=&quot;Position command step response&quot;, lab=[&quot;Pole placement&quot; &quot;&quot; &quot;GMF&quot; &quot;&quot;], legend=:bottomright)</code></pre><img src="3f8528c5.svg" alt="Example block output"/><p>Then we simulate the response to an impulsive disturbance acting on the cart (i.e., someone hit it with a hammer)</p><pre><code class="language-julia hljs">plot([
    impulse(feedback(sys, controller), 8, method=:zoh),
    impulse(feedback(sys, Kgmf), 8, method=:zoh),
], ylab=[&quot;Pos&quot; &quot;Angle&quot;], plot_title=&quot;Disturbance step response&quot;, lab=[&quot;Pole placement&quot; &quot;&quot; &quot;GMF&quot; &quot;&quot;], legend=:bottomright)</code></pre><img src="0a63e90d.svg" alt="Example block output"/><p>This time, the controllers control also the cart position while keeping the pendulum stabilized. Interestingly, while the GMF controller appears a bit slower during the reference change, maintaining a more conservative maximum angle of the pendulum, it is <em>significantly</em> faster in recovering from the disturbance.</p><p>We can also animate the system:</p><pre><code class="language-julia hljs">sim_pp  = rampsim(feedback(sys*controller))
sim_gmf = rampsim(feedback(sys*Kgmf))
@gif for i in 1:3:length(sim_pp.t)
    p, a = sim_pp.y[:, i]
    plot([p; p - 0.5sin(a)], [0; 0.5cos(a)], lw = 1, markershape = :square, markersize=[8, 1], lab = &quot;PP&quot;, dpi = 200, size=(700, 200))

    p, a = sim_gmf.y[:, i]
    plot!([p; p - 0.5sin(a)], [0; 0.5cos(a)], lw = 1, markershape = :square, markersize=[8, 1], lab = &quot;GMF&quot;, xlims = (-1, 2.2),
        ylims = (-0.2, 0.6), title = &quot;Inverted pendulum control&quot;,
        dpi = 200, aspect_ratio = 1)
end</code></pre><img src="9e0c4ecd.gif" alt="Example block output"/><h2 id="Cascade-control"><a class="docs-heading-anchor" href="#Cascade-control">Cascade control</a><a id="Cascade-control-1"></a><a class="docs-heading-anchor-permalink" href="#Cascade-control" title="Permalink"></a></h2><p>The system considered in this example has a single input, but more than one output (position and angle). When we neglected the measurement of the position of the cart and closed the loop around the angle only, we got an unstable system when considering the cart position as well. However, we could add an &quot;outer controller&quot; in cascade with the inner PID controller we designed above, and let the outer controller control the position of the cart. This kind of control architecture is often called a <em>cascade controller</em>, and this is a common and simple way to design a controller for a SIMO system. Below, we add a PI controller for the cart position and simulate the same response to an input disturbance as we did above. It&#39;s important to not tune this outer controller too hard or it will start to destabilize the inner system.</p><pre><code class="language-julia hljs">Cp = pid(-1, 5; state_space=true) # Position controller
Gtotal = feedback(Gecl, Cp, Y1=[1]) # Indicate that the outer controller can only see the cart position (y1)
plot(step.([Gecl, Gtotal], 20), lab=[&quot;Only angle feedback&quot; &quot;&quot; &quot;Cascade control&quot; &quot;&quot;], legend=:bottomright, ylims=[(-5, 0.2) (-Inf, Inf)])</code></pre><img src="f2f674a6.svg" alt="Example block output"/><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>We started out designing a PID controller and used the Bode plot to guide the tuning. While we ended up with a controller with good robustness margins, we had completely forgotten about the cart position and the controller turned out to not stabilize this &quot;hidden state&quot;. We include this example here as an example of following a mostly sound procedure, leading to a robust controller, but failing to meet real-world constraints due to lack of observability. To stabilize also the cart position, we added an outer position controller in cascade with the inner angle controller.</p><p>The loop-shaping procedure yielded a controller that stabilized all states of the plant, but with questionable robustness margins. In practice, pole placement can be rather difficult and it&#39;s not always obvious where to place the poles to achieve a robust design. In this case, a robust design is very hard to achieve with a pole-placement controller without model augmentation, the poor robustness of the pole-placement controller compared to the PID controller is due to the low gain at low frequencies, indeed, the pole placement controller lacks integral action! See <a href="../lqg_disturbance/#Disturbance-modeling-and-rejection-with-LQG-controllers">Disturbance modeling and rejection with LQG controllers</a> for a tutorial on how to add integral action to state-feedback controllers by augmenting the system model with a disturbance model.</p><p>We looked at several different ways of quantifying robustness of a system with multiple outputs, and tried our luck with a procedure for automatic robustification, <a href="../api/#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a>. In this case, the procedure worked and we got a slightly more robust controller as a result, this controller also increased the gain for low frequencies significantly, further indicating that the low-frequency gain was a source of problems for the pole-placement controller. The result of the Glover-McFarlane procedure may either be used directly as the final controller, or to provide insight into how the procedure modifies the existing controller in order to improve robustness.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lqg_disturbance/">« LQG control with integral action</a><a class="docs-footer-nextpage" href="../measurable_disturbance/"><span>$H_2$</span> design with a known disturbance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 22 October 2024 15:37">Tuesday 22 October 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
