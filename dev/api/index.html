<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · RobustAndOptimalControl Documentation</title><meta name="title" content="API · RobustAndOptimalControl Documentation"/><meta property="og:title" content="API · RobustAndOptimalControl Documentation"/><meta property="twitter:title" content="API · RobustAndOptimalControl Documentation"/><meta name="description" content="Documentation for RobustAndOptimalControl Documentation."/><meta property="og:description" content="Documentation for RobustAndOptimalControl Documentation."/><meta property="twitter:description" content="Documentation for RobustAndOptimalControl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RobustAndOptimalControl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../uncertainty/">Uncertainty modeling</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../hinf_DC/">Simple mixed-sensitivity <span>$H_\infty$</span> design</a></li><li><a class="tocitem" href="../hinf_connection/">General <span>$H_\infty$</span> design</a></li><li><a class="tocitem" href="../lqg_disturbance/">LQG control with integral action</a></li><li><a class="tocitem" href="../cartpole/">Control design for a pendulum on a cart</a></li><li><a class="tocitem" href="../measurable_disturbance/"><span>$H_2$</span> design with a known disturbance</a></li><li><a class="tocitem" href="../similarity/">When are systems similar?</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-functions-and-types"><a class="docs-heading-anchor" href="#Exported-functions-and-types">Exported functions and types</a><a id="Exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#RobustAndOptimalControl.Disk"><code>RobustAndOptimalControl.Disk</code></a></li><li><a href="#RobustAndOptimalControl.Diskmargin"><code>RobustAndOptimalControl.Diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.ExtendedStateSpace"><code>RobustAndOptimalControl.ExtendedStateSpace</code></a></li><li><a href="#RobustAndOptimalControl.ExtendedStateSpace-Tuple{AbstractStateSpace}"><code>RobustAndOptimalControl.ExtendedStateSpace</code></a></li><li><a href="#RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.LQGProblem</code></a></li><li><a href="#RobustAndOptimalControl.LQGProblem"><code>RobustAndOptimalControl.LQGProblem</code></a></li><li><a href="#RobustAndOptimalControl.NamedStateSpace"><code>RobustAndOptimalControl.NamedStateSpace</code></a></li><li><a href="#RobustAndOptimalControl.UncertainSS"><code>RobustAndOptimalControl.UncertainSS</code></a></li><li><a href="#RobustAndOptimalControl.nyquistcircles"><code>RobustAndOptimalControl.nyquistcircles</code></a></li><li><a href="#RobustAndOptimalControl.δ"><code>RobustAndOptimalControl.δ</code></a></li><li><a href="#ControlSystemsBase.G_CS-Tuple{LQGProblem}"><code>ControlSystemsBase.G_CS</code></a></li><li><a href="#ControlSystemsBase.G_PS-Tuple{LQGProblem}"><code>ControlSystemsBase.G_PS</code></a></li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{LQGProblem}"><code>ControlSystemsBase.input_comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{LQGProblem}"><code>ControlSystemsBase.input_sensitivity</code></a></li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{LQGProblem}"><code>ControlSystemsBase.output_comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{LQGProblem}"><code>ControlSystemsBase.output_sensitivity</code></a></li><li><a href="#ControlSystemsBase.ss"><code>ControlSystemsBase.ss</code></a></li><li><a href="#DescriptorSystems.dss-Tuple{AbstractStateSpace}"><code>DescriptorSystems.dss</code></a></li><li><a href="#RobustAndOptimalControl.add_disturbance-Tuple{AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_input_differentiator"><code>RobustAndOptimalControl.add_input_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_input_integrator"><code>RobustAndOptimalControl.add_input_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{AbstractStateSpace, Integer}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_low_frequency_disturbance"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_measurement_disturbance-Tuple{AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_measurement_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_output_differentiator"><code>RobustAndOptimalControl.add_output_differentiator</code></a></li><li><a href="#RobustAndOptimalControl.add_output_integrator"><code>RobustAndOptimalControl.add_output_integrator</code></a></li><li><a href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{AbstractStateSpace, Any, Any, Integer}"><code>RobustAndOptimalControl.add_resonant_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{AbstractStateSpace, Any, Any, AbstractArray}"><code>RobustAndOptimalControl.add_resonant_disturbance</code></a></li><li><a href="#RobustAndOptimalControl.baltrunc2-Tuple{LTISystem}"><code>RobustAndOptimalControl.baltrunc2</code></a></li><li><a href="#RobustAndOptimalControl.baltrunc_coprime-Union{Tuple{Any}, Tuple{F}, Tuple{Any, Any}} where F"><code>RobustAndOptimalControl.baltrunc_coprime</code></a></li><li><a href="#RobustAndOptimalControl.baltrunc_unstab"><code>RobustAndOptimalControl.baltrunc_unstab</code></a></li><li><a href="#RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a></li><li><a href="#RobustAndOptimalControl.bilinearc2d-Tuple{StateSpace{Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a></li><li><a href="#RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a></li><li><a href="#RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a></li><li><a href="#RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilineard2c</code></a></li><li><a href="#RobustAndOptimalControl.bilineard2c-Tuple{StateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a></li><li><a href="#RobustAndOptimalControl.blocksort-Tuple{UncertainSS}"><code>RobustAndOptimalControl.blocksort</code></a></li><li><a href="#RobustAndOptimalControl.broken_feedback-Tuple{LTISystem, Any}"><code>RobustAndOptimalControl.broken_feedback</code></a></li><li><a href="#RobustAndOptimalControl.closedloop"><code>RobustAndOptimalControl.closedloop</code></a></li><li><a href="#RobustAndOptimalControl.connect-Tuple{Any, AbstractVector{&lt;:Pair}}"><code>RobustAndOptimalControl.connect</code></a></li><li><a href="#RobustAndOptimalControl.controller_reduction"><code>RobustAndOptimalControl.controller_reduction</code></a></li><li><a href="#RobustAndOptimalControl.controller_reduction_plot"><code>RobustAndOptimalControl.controller_reduction_plot</code></a></li><li><a href="#RobustAndOptimalControl.controller_reduction_weight-Tuple{ExtendedStateSpace, Any}"><code>RobustAndOptimalControl.controller_reduction_weight</code></a></li><li><a href="#RobustAndOptimalControl.dare3-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.dare3</code></a></li><li><a href="#RobustAndOptimalControl.diskmargin-Tuple{LTISystem, Real, AbstractArray}"><code>RobustAndOptimalControl.diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.diskmargin-Tuple{LTISystem, LTISystem, Any, AbstractVector, Vararg{Any}}"><code>RobustAndOptimalControl.diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.diskmargin"><code>RobustAndOptimalControl.diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}"><code>RobustAndOptimalControl.expand_symbol</code></a></li><li><a href="#RobustAndOptimalControl.extended_controller"><code>RobustAndOptimalControl.extended_controller</code></a></li><li><a href="#RobustAndOptimalControl.extended_controller-Tuple{AbstractStateSpace}"><code>RobustAndOptimalControl.extended_controller</code></a></li><li><a href="#RobustAndOptimalControl.feedback_control-Tuple{Any, Any}"><code>RobustAndOptimalControl.feedback_control</code></a></li><li><a href="#RobustAndOptimalControl.ff_controller"><code>RobustAndOptimalControl.ff_controller</code></a></li><li><a href="#RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any}, Tuple{StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any, F}} where {N, F}"><code>RobustAndOptimalControl.find_lft</code></a></li><li><a href="#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}"><code>RobustAndOptimalControl.fit_complex_perturbations</code></a></li><li><a href="#RobustAndOptimalControl.frequency_separation-Tuple{Any, Any}"><code>RobustAndOptimalControl.frequency_separation</code></a></li><li><a href="#RobustAndOptimalControl.frequency_weighted_reduction"><code>RobustAndOptimalControl.frequency_weighted_reduction</code></a></li><li><a href="#RobustAndOptimalControl.fudge_inv"><code>RobustAndOptimalControl.fudge_inv</code></a></li><li><a href="#RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}"><code>RobustAndOptimalControl.gain_and_delay_uncertainty</code></a></li><li><a href="#RobustAndOptimalControl.gainphaseplot"><code>RobustAndOptimalControl.gainphaseplot</code></a></li><li><a href="#RobustAndOptimalControl.glover_mcfarlane"><code>RobustAndOptimalControl.glover_mcfarlane</code></a></li><li><a href="#RobustAndOptimalControl.glover_mcfarlane"><code>RobustAndOptimalControl.glover_mcfarlane</code></a></li><li><a href="#RobustAndOptimalControl.glover_mcfarlane_2dof"><code>RobustAndOptimalControl.glover_mcfarlane_2dof</code></a></li><li><a href="#RobustAndOptimalControl.h2norm-Tuple{LTISystem}"><code>RobustAndOptimalControl.h2norm</code></a></li><li><a href="#RobustAndOptimalControl.h2synthesize"><code>RobustAndOptimalControl.h2synthesize</code></a></li><li><a href="#RobustAndOptimalControl.hankelnorm-Tuple{LTISystem}"><code>RobustAndOptimalControl.hankelnorm</code></a></li><li><a href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>RobustAndOptimalControl.hanus</code></a></li><li><a href="#RobustAndOptimalControl.hess_form-Tuple{Any}"><code>RobustAndOptimalControl.hess_form</code></a></li><li><a href="#RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfassumptions</code></a></li><li><a href="#RobustAndOptimalControl.hinfgrad-Tuple{Any, Any, Any}"><code>RobustAndOptimalControl.hinfgrad</code></a></li><li><a href="#RobustAndOptimalControl.hinfnorm2-Tuple{LTISystem}"><code>RobustAndOptimalControl.hinfnorm2</code></a></li><li><a href="#RobustAndOptimalControl.hinfpartition-NTuple{4, Any}"><code>RobustAndOptimalControl.hinfpartition</code></a></li><li><a href="#RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, LTISystem, LTISystem}"><code>RobustAndOptimalControl.hinfsignals</code></a></li><li><a href="#RobustAndOptimalControl.hinfsynthesize-Union{Tuple{ExtendedStateSpace{Continuous, T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.hinfsynthesize</code></a></li><li><a href="#RobustAndOptimalControl.hsvd-Tuple{AbstractStateSpace}"><code>RobustAndOptimalControl.hsvd</code></a></li><li><a href="#RobustAndOptimalControl.ispassive-Tuple{Any}"><code>RobustAndOptimalControl.ispassive</code></a></li><li><a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.loop_scale"><code>RobustAndOptimalControl.loop_scale</code></a></li><li><a href="#RobustAndOptimalControl.loop_scaling"><code>RobustAndOptimalControl.loop_scaling</code></a></li><li><a href="#RobustAndOptimalControl.lqr3-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.lqr3</code></a></li><li><a href="#RobustAndOptimalControl.makeweight-Tuple{Any, Number, Any}"><code>RobustAndOptimalControl.makeweight</code></a></li><li><a href="#RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}"><code>RobustAndOptimalControl.measure</code></a></li><li><a href="#RobustAndOptimalControl.modal_form-Tuple{Any}"><code>RobustAndOptimalControl.modal_form</code></a></li><li><a href="#RobustAndOptimalControl.muplot"><code>RobustAndOptimalControl.muplot</code></a></li><li><a href="#RobustAndOptimalControl.mvnyquistplot"><code>RobustAndOptimalControl.mvnyquistplot</code></a></li><li><a href="#RobustAndOptimalControl.named_ss-Union{Tuple{ExtendedStateSpace{T}}, Tuple{T}, Tuple{ExtendedStateSpace{T}, Any}} where T"><code>RobustAndOptimalControl.named_ss</code></a></li><li><a href="#RobustAndOptimalControl.named_ss-Tuple{AbstractStateSpace, Any}"><code>RobustAndOptimalControl.named_ss</code></a></li><li><a href="#RobustAndOptimalControl.named_ss-Union{Tuple{AbstractStateSpace{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.named_ss</code></a></li><li><a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>RobustAndOptimalControl.ncfmargin</code></a></li><li><a href="#RobustAndOptimalControl.neglected_delay-Tuple{Any}"><code>RobustAndOptimalControl.neglected_delay</code></a></li><li><a href="#RobustAndOptimalControl.neglected_lag-Tuple{Any}"><code>RobustAndOptimalControl.neglected_lag</code></a></li><li><a href="#RobustAndOptimalControl.noise_mapping"><code>RobustAndOptimalControl.noise_mapping</code></a></li><li><a href="#RobustAndOptimalControl.nu_reduction"><code>RobustAndOptimalControl.nu_reduction</code></a></li><li><a href="#RobustAndOptimalControl.nu_reduction_recursive"><code>RobustAndOptimalControl.nu_reduction_recursive</code></a></li><li><a href="#RobustAndOptimalControl.nugap-Tuple{LTISystem, LTISystem}"><code>RobustAndOptimalControl.nugap</code></a></li><li><a href="#RobustAndOptimalControl.nugap"><code>RobustAndOptimalControl.nugap</code></a></li><li><a href="#RobustAndOptimalControl.partition-Tuple{AbstractStateSpace}"><code>RobustAndOptimalControl.partition</code></a></li><li><a href="#RobustAndOptimalControl.partition-Tuple{AbstractStateSpace, Int64, Int64}"><code>RobustAndOptimalControl.partition</code></a></li><li><a href="#RobustAndOptimalControl.passivity_index-Tuple{Any}"><code>RobustAndOptimalControl.passivity_index</code></a></li><li><a href="#RobustAndOptimalControl.passivityplot"><code>RobustAndOptimalControl.passivityplot</code></a></li><li><a href="#RobustAndOptimalControl.performance_mapping"><code>RobustAndOptimalControl.performance_mapping</code></a></li><li><a href="#RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}"><code>RobustAndOptimalControl.robstab</code></a></li><li><a href="#RobustAndOptimalControl.schur_form-Tuple{Any}"><code>RobustAndOptimalControl.schur_form</code></a></li><li><a href="#RobustAndOptimalControl.show_construction-Tuple{IO, LTISystem}"><code>RobustAndOptimalControl.show_construction</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin-Tuple{LTISystem, Real, AbstractVector}"><code>RobustAndOptimalControl.sim_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a></li><li><a href="#RobustAndOptimalControl.specificationplot"><code>RobustAndOptimalControl.specificationplot</code></a></li><li><a href="#RobustAndOptimalControl.splitter"><code>RobustAndOptimalControl.splitter</code></a></li><li><a href="#RobustAndOptimalControl.ss2particles-Tuple{Vector{&lt;:AbstractStateSpace}}"><code>RobustAndOptimalControl.ss2particles</code></a></li><li><a href="#RobustAndOptimalControl.ssdata_e-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.ssdata_e</code></a></li><li><a href="#RobustAndOptimalControl.stab_unstab-Tuple{Any}"><code>RobustAndOptimalControl.stab_unstab</code></a></li><li><a href="#RobustAndOptimalControl.static_gain_compensation"><code>RobustAndOptimalControl.static_gain_compensation</code></a></li><li><a href="#RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.structured_singular_value</code></a></li><li><a href="#RobustAndOptimalControl.structured_singular_value-Tuple{LTISystem, AbstractVector}"><code>RobustAndOptimalControl.structured_singular_value</code></a></li><li><a href="#RobustAndOptimalControl.sumblock-Tuple{String}"><code>RobustAndOptimalControl.sumblock</code></a></li><li><a href="#RobustAndOptimalControl.sys_from_particles-Tuple{Any, Any}"><code>RobustAndOptimalControl.sys_from_particles</code></a></li><li><a href="#RobustAndOptimalControl.system_mapping"><code>RobustAndOptimalControl.system_mapping</code></a></li><li><a href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}"><code>RobustAndOptimalControl.uss</code></a></li><li><a href="#RobustAndOptimalControl.vec2sys"><code>RobustAndOptimalControl.vec2sys</code></a></li><li><a href="#RobustAndOptimalControl.δc"><code>RobustAndOptimalControl.δc</code></a></li><li><a href="#RobustAndOptimalControl.δr"><code>RobustAndOptimalControl.δr</code></a></li></ul><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.Disk" href="#RobustAndOptimalControl.Disk"><code>RobustAndOptimalControl.Disk</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Disk</code></pre><p>Represents a perturbation disc in the complex plane. <code>Disk(0.5, 2)</code> represents all perturbations in the circle centered at 1.25 with radius 0.75, or in other words, a gain margin of 2 and a pahse margin of 36.9 degrees.</p><p>A disk can be converted to a Nyquist exclusion disk by <code>nyquist(disk)</code> and plotted using <code>plot(disk)</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>γmin</code>: Lower intercept</li><li><code>γmax</code>: Upper intercept</li><li><code>c</code>: Center</li><li><code>r</code>: Radius</li><li><code>ϕm</code>: Angle of tangent line through origin.</li></ul><p>If γmax &lt; γmin the disk is inverted. See <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a> for disk margin computations. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/diskmargin.jl#L79-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.Diskmargin" href="#RobustAndOptimalControl.Diskmargin"><code>RobustAndOptimalControl.Diskmargin</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Diskmargin</code></pre><p>The notation follows &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet</p><p><strong>Fields:</strong></p><p><code>α</code>: The disk margin <code>ω0</code>: The worst-case frequency <code>f0</code>: The destabilizing perturbation <code>f0</code> is a complex number with simultaneous gain and phase variation. This critical perturbation causes an instability with closed-loop pole on the imaginary axis at the critical frequency ω0  <code>δ0</code>: The uncertain element generating f0. <code>γmin</code>: The lower real-axis intercept of the disk (analogous to classical lower gain margin). <code>γmax</code>: The upper real-axis intercept of the disk (analogous to classical upper gain margin). <code>ϕm</code>: is analogous to the classical phase margin. <code>σ</code>: The skew parameter that was used to calculate the margin</p><p>Note, <code>γmax</code> and <code>ϕm</code> are in smaller than the classical gain and phase margins sicne the classical margins do not consider simultaneous perturbations in gain and phase. </p><p>The &quot;disk&quot; margin becomes a half plane for <code>α = 2</code> and an inverted circle for <code>α &gt; 2</code>. In this case, the upper gain margin is infinite. See the paper for more details, in particular figure 6.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/diskmargin.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.ExtendedStateSpace" href="#RobustAndOptimalControl.ExtendedStateSpace"><code>RobustAndOptimalControl.ExtendedStateSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtendedStateSpace{TE, T} &lt;: AbstractStateSpace{TE}</code></pre><p>A type that represents the two-input, two-output system</p><pre><code class="nohighlight hljs">z  ┌─────┐  w
◄──┤     │◄──
   │  P  │
◄──┤     │◄──
y  └─────┘  u</code></pre><p>where</p><ul><li><code>z</code> denotes controlled outputs (sometimes called performance outputs)</li><li><code>y</code> denotes measured outputs</li><li><code>w</code> denotes external inputs, such as disturbances or references</li><li><code>u</code> denotes control inputs</li></ul><p>The call <code>lft(P, K)</code> forms the (lower) linear fractional transform </p><pre><code class="nohighlight hljs">z  ┌─────┐  w
◄──┤     │◄──
   │  P  │
┌──┤     │◄─┐
│y └─────┘ u│
│           │
│  ┌─────┐  │
│  │     │  │
└─►│  K  ├──┘
   │     │
   └─────┘</code></pre><p>i.e., closing the lower loop around <code>K</code>.</p><p>An <code>ExtendedStateSpace</code> can be converted to a standard <code>StateSpace</code> by <code>ss(P)</code>, this will keep all inputs and outputs, effectively removing the partitioning only.</p><p>When <a href="@ref"><code>feedback</code></a> is called on this type, defaults are automatically set for the feedback indices. Other functions defined for this type include</p><ul><li><a href="#RobustAndOptimalControl.system_mapping"><code>system_mapping</code></a></li><li><a href="#RobustAndOptimalControl.performance_mapping"><code>performance_mapping</code></a></li><li><a href="#RobustAndOptimalControl.noise_mapping"><code>noise_mapping</code></a></li><li><a href="@ref"><code>lft</code></a></li><li><a href="@ref"><code>feedback</code></a> has special overloads that sets defaults connections for <code>ExtendedStateSpace</code>.</li></ul><p>and the following design functions expect <code>ExtendedStateSpace</code> as inputs</p><ul><li><a href="#RobustAndOptimalControl.hinfsynthesize-Union{Tuple{ExtendedStateSpace{Continuous, T}}, Tuple{T}} where T"><code>hinfsynthesize</code></a></li><li><a href="#RobustAndOptimalControl.h2synthesize"><code>h2synthesize</code></a></li><li><a href="#RobustAndOptimalControl.LQGProblem"><code>LQGProblem</code></a> (also accepts other types)</li></ul><p>A video tutorial on how to use this type is available <a href="https://youtu.be/huYRrn--AKc">here</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/ExtendedStateSpace.jl#L4-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.ExtendedStateSpace-Tuple{AbstractStateSpace}" href="#RobustAndOptimalControl.ExtendedStateSpace-Tuple{AbstractStateSpace}"><code>RobustAndOptimalControl.ExtendedStateSpace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">se = ExtendedStateSpace(s::AbstractStateSpace; kwargs...)</code></pre><p>The conversion from a regular statespace object to an <code>ExtendedStateSpace</code> creates the following system by default</p><p class="math-container">\[\begin{bmatrix}
    A &amp; B &amp; B \\
    C &amp; D &amp; D \\
    C &amp; D &amp; D
\end{bmatrix}\]</p><p>i.e., the system and performance mappings are identical, <code>system_mapping(se) == performance_mapping(se) == s</code>. However, all matrices <code>B1, B2, C1, C2; D11, D12, D21, D22</code> are overridable by a corresponding keyword argument. In this case, the controlled outputs are the same as measured outputs.</p><p>Related: <code>se = convert(ExtendedStateSpace, s::StateSpace)</code> produces an <code>ExtendedStateSpace</code> with empty <code>performance_mapping</code> from w-&gt;z such that <code>ss(se) == s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/ExtendedStateSpace.jl#L588-L603">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.LQGProblem" href="#RobustAndOptimalControl.LQGProblem"><code>RobustAndOptimalControl.LQGProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G = LQGProblem(sys::ExtendedStateSpace, Q1, Q2, R1, R2; qQ=0, qR=0, SQ=nothing, SR=nothing)</code></pre><p>Return an LQG object that describes the closed control loop around the process <code>sys=ss(A,B,C,D)</code> where the controller is of LQG-type. The controller is specified by weight matrices <code>Q1,Q2</code> that penalizes state deviations and control signal variance respectively, and covariance matrices <code>R1,R2</code> which specify state drift and measurement covariance respectively.</p><p><code>sys</code> is an extended statespace object where the upper channel corresponds to disturbances to performance variables (w→z), and the lower channel corresponds to inputs to outputs (u→y), such that <code>lft(sys, K)</code> forms the closed-loop transfer function from external inputs/disturbances to performance variables. </p><p><code>qQ</code> and <code>qR</code> can be set to incorporate loop-transfer recovery, i.e.,</p><pre><code class="language-julia hljs">L = lqr(A, B, Q1+qQ*C&#39;C, Q2)
K = kalman(A, C, R1+qR*B*B&#39;, R2)</code></pre><p>Increasing <code>qQ</code> will add more cost in output direction, e.g., encouraging the use of cheap control, while increasing <code>qR</code> adds fictious dynamics noise, makes the observer faster in the direction we control.</p><p><strong>Example</strong></p><p>In this example we will control a MIMO system with one unstable pole and one unstable zero. When the system has both unstable zeros and poles, there are fundamental limitations on performance. The unstable zero is in this case faster than the unstable pole, so the system is controllable. For good performance, we want as large separation between the unstable zero dynamics and the unstable poles as possible. </p><pre><code class="language-julia hljs">s = tf(&quot;s&quot;)
P = [1/(s+1) 2/(s+2); 1/(s+3) 1/(s-1)]
sys = ExtendedStateSpace(ss(P)) # Controlled outputs same as measured outputs and state noise affects at inputs only. 
eye(n) = Matrix{Float64}(I,n,n) # For convinience

qQ = 0
qR = 0
Q1 = 10eye(2)
Q2 = 1eye(2)
R1 = 1eye(2)
R2 = 1eye(2)

G = LQGProblem(sys, Q1, Q2, R1, R2, qQ=qQ, qR=qR)

T = comp_sensitivity(G)
S = sensitivity(G)
Gcl = closedloop(G)*static_gain_compensation(G)
plot(
    sigmaplot([S,T, Gcl],exp10.(range(-3, stop=3, length=1000)), lab=[&quot;S&quot; &quot;T&quot; &quot;Gry&quot;]),
    plot(step(Gcl, 5))
)</code></pre><p><strong>Extended help</strong></p><p>Several functions are defined for instances of <code>LQGProblem</code></p><ul><li><a href="#RobustAndOptimalControl.closedloop"><code>closedloop</code></a></li><li><a href="#RobustAndOptimalControl.extended_controller"><code>extended_controller</code></a></li><li><a href="#RobustAndOptimalControl.ff_controller"><code>ff_controller</code></a></li><li><a href="@ref"><code>gangoffour</code></a></li><li><a href="#ControlSystemsBase.G_CS-Tuple{LQGProblem}"><code>G_CS</code></a></li><li><a href="#ControlSystemsBase.G_PS-Tuple{LQGProblem}"><code>G_PS</code></a></li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{LQGProblem}"><code>input_comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{LQGProblem}"><code>input_sensitivity</code></a></li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{LQGProblem}"><code>output_comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{LQGProblem}"><code>output_sensitivity</code></a></li><li><a href="#RobustAndOptimalControl.system_mapping"><code>system_mapping</code></a></li><li><a href="#RobustAndOptimalControl.performance_mapping"><code>performance_mapping</code></a></li><li><a href="#RobustAndOptimalControl.static_gain_compensation"><code>static_gain_compensation</code></a></li><li><a href="@ref"><code>gangoffourplot</code></a></li><li><a href="@ref"><code>kalman</code></a></li><li><a href="@ref"><code>lft</code></a></li><li><a href="@ref"><code>lqr</code></a></li><li><a href="@ref"><code>observer_controller</code></a></li></ul><p>A video tutorial on how to use the LQG interface is available <a href="https://youtu.be/NuAxN1mGCPs">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L5-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.LQGProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LQGProblem(P::ExtendedStateSpace)</code></pre><p>If only an <code>ExtendedStateSpace</code> system is provided, e.g. from <code>hinfpartition</code>, the system <code>P</code> is assumed to correspond to the H₂ optimal control problem with</p><pre><code class="nohighlight hljs">C1&#39;C1    = Q1
D12&#39;D12  = Q2
SQ       = C1&#39;D12 # Cross term

B1*B1&#39;   = R1
D21*D21&#39; = R2
SR       = B1*D21&#39; # Cross term</code></pre><p>and an <code>LQGProblem</code> with the above covariance matrices is returned. The system description in the returned LQGProblem will have <code>B1 = C1 = I</code>. See Ch. 14 in Robust and optimal control for reference. </p><p><strong>Example:</strong></p><p>All the following ways of obtaining the H2 optimal controller are (almost) equivalent</p><pre><code class="language-julia hljs">using Test
G = ss(tf(1, [10, 1]))
WS = tf(1, [1, 1e-6]) 
WU = makeweight(1e-2, 0.1, 100) 
Gd = hinfpartition(G, WS, WU, [])

K, Gcl = h2synthesize(Gd)              # First option, using H2 formulas
K2, Gcl2 = h2synthesize(Gd, 1000)      # Second option, using H∞ formulas with large γ

lqg = LQGProblem(Gd)                   # Third option, convert to an LQGProblem and obtain controller
K3 = -observer_controller(lqg)

@test h2norm(lft(Gd, K )) ≈ 3.0568 atol=1e-3
@test h2norm(lft(Gd, K2)) ≈ 3.0568 atol=1e-3
@test h2norm(lft(Gd, K3)) ≈ 3.0568 atol=1e-3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L119-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.NamedStateSpace" href="#RobustAndOptimalControl.NamedStateSpace"><code>RobustAndOptimalControl.NamedStateSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <code>named_ss</code> for a convenient constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/named_systems2.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.UncertainSS" href="#RobustAndOptimalControl.UncertainSS"><code>RobustAndOptimalControl.UncertainSS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UncertainSS{TE} &lt;: AbstractStateSpace{TE}</code></pre><p>Represents LFT_u(M, Diagonal(Δ))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.nyquistcircles" href="#RobustAndOptimalControl.nyquistcircles"><code>RobustAndOptimalControl.nyquistcircles</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nyquistcircles(w, centers, radii)</code></pre><p>Plot the nyquist curve with circles. It only makes sense to call this function if the circles represent additive uncertainty, i.e., were calculated with <code>relative=false</code>.</p><p>See also <a href="#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}"><code>fit_complex_perturbations</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/weights.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.δ" href="#RobustAndOptimalControl.δ"><code>RobustAndOptimalControl.δ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">δ(N=32)</code></pre><p>Create an uncertain element of <code>N</code> uniformly distributed samples ∈ [-1, 1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/find_lft.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.G_CS-Tuple{LQGProblem}" href="#ControlSystemsBase.G_CS-Tuple{LQGProblem}"><code>ControlSystemsBase.G_CS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G_CS(l::LQGProblem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L422-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.G_PS-Tuple{LQGProblem}" href="#ControlSystemsBase.G_PS-Tuple{LQGProblem}"><code>ControlSystemsBase.G_PS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G_PS(l::LQGProblem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L415-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.input_comp_sensitivity-Tuple{LQGProblem}" href="#ControlSystemsBase.input_comp_sensitivity-Tuple{LQGProblem}"><code>ControlSystemsBase.input_comp_sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">input_comp_sensitivity(l::LQGProblem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L456-L458">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.input_sensitivity-Tuple{LQGProblem}" href="#ControlSystemsBase.input_sensitivity-Tuple{LQGProblem}"><code>ControlSystemsBase.input_sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">input_sensitivity(l::LQGProblem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L446-L448">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.output_comp_sensitivity-Tuple{LQGProblem}" href="#ControlSystemsBase.output_comp_sensitivity-Tuple{LQGProblem}"><code>ControlSystemsBase.output_comp_sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">output_comp_sensitivity(l::LQGProblem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L461-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.output_sensitivity-Tuple{LQGProblem}" href="#ControlSystemsBase.output_sensitivity-Tuple{LQGProblem}"><code>ControlSystemsBase.output_sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">output_sensitivity(l::LQGProblem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L451-L453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.ss" href="#ControlSystemsBase.ss"><code>ControlSystemsBase.ss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ss(A, B1, B2, C1, C2, D11, D12, D21, D22 [, Ts])</code></pre><p>Create an <a href="#RobustAndOptimalControl.ExtendedStateSpace"><code>ExtendedStateSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/ExtendedStateSpace.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.dss-Tuple{AbstractStateSpace}" href="#DescriptorSystems.dss-Tuple{AbstractStateSpace}"><code>DescriptorSystems.dss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DescriptorSystems.dss(sys::AbstractStateSpace)</code></pre><p>Convert <code>sys</code> to a descriptor statespace system from <a href="https://andreasvarga.github.io/DescriptorSystems.jl/dev/index.html">DescriptorSystems.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/descriptor.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_disturbance-Tuple{AbstractStateSpace, AbstractMatrix, AbstractMatrix}" href="#RobustAndOptimalControl.add_disturbance-Tuple{AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_disturbance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_disturbance(sys::StateSpace, Ad::Matrix, Cd::Matrix)</code></pre><p>See CCS pp. 144</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: System to augment</li><li><code>Ad</code>: The dynamics of the disturbance</li><li><code>Cd</code>: How the disturbance states affect the states of <code>sys</code>. This matrix has the shape (sys.nx, size(Ad, 1))</li></ul><p>See also <a href="#RobustAndOptimalControl.add_low_frequency_disturbance"><code>add_low_frequency_disturbance</code></a>, <a href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{AbstractStateSpace, Any, Any, AbstractArray}"><code>add_resonant_disturbance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_input_differentiator" href="#RobustAndOptimalControl.add_input_differentiator"><code>RobustAndOptimalControl.add_input_differentiator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_input_differentiator(sys::StateSpace, ui = 1:sys.nu; goodwin=false)</code></pre><p>Augment the output of <code>sys</code> with the difference <code>u(k+1)-u(k)</code></p><p><strong>Arguments:</strong></p><ul><li><code>ui</code>: An index or vector of indices indicating which inputs to differentiate.</li><li><code>goodwin</code>: If true, the difference operator will use the Goodwin δ operator, i.e., <code>(u(k+1)-u(k)) / sys.Ts</code>.</li></ul><p>The augmented system will have the matrices</p><pre><code class="nohighlight hljs">[A 0; 0 0]  [B; I]  [C 0; 0 -I]  [D; I]</code></pre><p>with <code>length(ui)</code> added states and outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L215-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_input_integrator" href="#RobustAndOptimalControl.add_input_integrator"><code>RobustAndOptimalControl.add_input_integrator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_input_integrator(sys::StateSpace, ui = 1, ϵ = 0)</code></pre><p>Augment the output of <code>sys</code> with the integral of input at index <code>ui</code>, i.e.,  <code>y_aug = [y; ∫u[ui]]</code> See also <a href="#RobustAndOptimalControl.add_low_frequency_disturbance"><code>add_low_frequency_disturbance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L187-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_low_frequency_disturbance" href="#RobustAndOptimalControl.add_low_frequency_disturbance"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_low_frequency_disturbance(sys::StateSpace; ϵ = 0, measurement = false)
add_low_frequency_disturbance(sys::StateSpace, Cd; ϵ = 0, measurement = false)</code></pre><p>Augment <code>sys</code> with a low-frequency (integrating if <code>ϵ=0</code>) disturbance model. If an integrating input disturbance is used together with an observer, the controller will have integral action.</p><ul><li><code>Cd</code>: If adding an input disturbance. this matrix indicates how the disturbance states affect the states of <code>sys</code>, and defaults to <code>sys.B</code>. If <code>measurement=true</code>, this matrix indicates how the disturbance states affect the outputs of <code>sys</code>, and defaults to <code>I(sys.ny)</code>.</li></ul><p><strong>Arguments:</strong></p><ul><li><code>ϵ</code>: Move the integrator pole <code>ϵ</code> into the stable region.</li><li><code>measurement</code>: If true, the disturbance is a measurement disturbance, otherwise it&#39;s an input diturbance. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L60-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{AbstractStateSpace, Integer}" href="#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{AbstractStateSpace, Integer}"><code>RobustAndOptimalControl.add_low_frequency_disturbance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_low_frequency_disturbance(sys::StateSpace, Ai::Integer; ϵ = 0)</code></pre><p>A disturbance affecting only state <code>Ai</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_measurement_disturbance-Tuple{AbstractStateSpace, AbstractMatrix, AbstractMatrix}" href="#RobustAndOptimalControl.add_measurement_disturbance-Tuple{AbstractStateSpace, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.add_measurement_disturbance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_measurement_disturbance(sys::StateSpace{Continuous}, Ad::Matrix, Cd::Matrix)</code></pre><p>Create the system</p><pre><code class="nohighlight hljs">Ae = [A 0; 0 Ad]
Be = [B; 0]
Ce = [C Cd]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_output_differentiator" href="#RobustAndOptimalControl.add_output_differentiator"><code>RobustAndOptimalControl.add_output_differentiator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_differentiator(sys::StateSpace{&lt;:Discrete})</code></pre><p>Augment the output of <code>sys</code> with the numerical difference (discrete-time derivative) of output, i.e., <code>y_aug = [y; (y-y_prev)/sys.Ts]</code> To add both an integrator and a differentiator to a SISO system, use</p><pre><code class="language-julia hljs">Gd = add_output_integrator(add_output_differentiator(G), 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L131-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_output_integrator" href="#RobustAndOptimalControl.add_output_integrator"><code>RobustAndOptimalControl.add_output_integrator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_output_integrator(sys::StateSpace{&lt;:Discrete}, ind = 1; ϵ = 0)</code></pre><p>Augment the output of <code>sys</code> with the integral of output at index <code>ind</code>, i.e.,  <code>y_aug = [y; ∫y[ind]]</code> To add both an integrator and a differentiator to a SISO system, use</p><pre><code class="language-julia hljs">Gd = add_output_integrator(add_output_differentiator(G), 1)</code></pre><p>Note: numerical integration is subject to numerical drift. If the output of the system corresponds to, e.g., a velocity reference and the integral to position reference, consider methods for mitigating this drift.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L157-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_resonant_disturbance-Tuple{AbstractStateSpace, Any, Any, AbstractArray}" href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{AbstractStateSpace, Any, Any, AbstractArray}"><code>RobustAndOptimalControl.add_resonant_disturbance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_resonant_disturbance(sys::AbstractStateSpace, ω, ζ, Bd::AbstractArray)</code></pre><ul><li><code>Bd</code>: The disturbance input matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.add_resonant_disturbance-Tuple{AbstractStateSpace, Any, Any, Integer}" href="#RobustAndOptimalControl.add_resonant_disturbance-Tuple{AbstractStateSpace, Any, Any, Integer}"><code>RobustAndOptimalControl.add_resonant_disturbance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_resonant_disturbance(sys::StateSpace{Continuous}, ω, ζ, Ai::Int; measurement = false)</code></pre><p>Augment <code>sys</code> with a resonant disturbance model.</p><p><strong>Arguments:</strong></p><ul><li><code>ω</code>: Frequency</li><li><code>ζ</code>: Relative damping.</li><li><code>Ai</code>: The affected state</li><li><code>measurement</code>: If true, the disturbace is acting on the output, this will cause the controller to have zeros at ω (roots of poly s² + 2ζωs + ω²). If false, the disturbance is acting on the input, this will cause the controller to have poles at ω (roots of poly s² + 2ζωs + ω²).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/model_augmentation.jl#L88-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.baltrunc2-Tuple{LTISystem}" href="#RobustAndOptimalControl.baltrunc2-Tuple{LTISystem}"><code>RobustAndOptimalControl.baltrunc2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysr, hs = baltrunc2(sys::LTISystem; residual=false, n=missing, kwargs...)</code></pre><p>Compute the a balanced truncation of order <code>n</code> and the hankel singular values</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.gbalmr</code>, reproduced below</p><pre><code class="nohighlight hljs">gbalmr(sys, balance = false, matchdc = false, ord = missing, offset = √ϵ,
       atolhsv = 0, rtolhsv = nϵ, atolmin = atolhsv, rtolmin = rtolhsv, 
       atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true) -&gt; (sysr, hs)</code></pre><p>Compute for a proper and stable descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, a reduced order realization <code>sysr = (Ar-λEr,Br,Cr,Dr)</code> and the vector <code>hs</code> of decreasingly  ordered Hankel singular values of the system <code>sys</code>. If <code>balance = true</code>, a balancing-based approach is used to determine a reduced order minimal realization  of the form <code>sysr = (Ar-λI,Br,Cr,Dr)</code>. For a continuous-time system <code>sys</code>, the resulting realization <code>sysr</code> is balanced, i.e., the controllability and observability grammians are equal and diagonal.  If additonally <code>matchdc = true</code>, the resulting <code>sysr</code> is computed using state rezidualization formulas  (also known as <em>singular perturbation approximation</em>) which additionally preserves the DC-gain of <code>sys</code>.  In this case, the resulting realization <code>sysr</code> is balanced (for both continuous- and discrete-time systems). If <code>balance = false</code>, an enhanced accuracy balancing-free approach is used to determine the  reduced order system <code>sysr</code>. </p><p>If <code>ord = nr</code>, the resulting order of <code>sysr</code> is <code>min(nr,nrmin)</code>, where <code>nrmin</code> is the order of a minimal   realization of <code>sys</code> determined as the number of Hankel singular values exceeding <code>max(atolmin,rtolmin*HN)</code>, with <code>HN</code>, the Hankel norm of <code>G(λ)</code>. If <code>ord = missing</code>, the resulting order is chosen as the number of Hankel  singular values exceeding <code>max(atolhsv,rtolhsv*HN)</code>. </p><p>To check the stability of the eigenvalues of the pencil <code>A-λE</code>, the real parts of eigenvalues must be less than <code>-β</code> for a continuous-time system or  the moduli of eigenvalues must be less than <code>1-β</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset.   The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>nϵ</code>, where <code>ϵ</code> is the working <em>machine epsilon</em>  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>If <code>E</code> is singular, the uncontrollable infinite eigenvalues of the pair <code>(A,E)</code> and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>. </p><p>Method:  For the order reduction of a standard system, the balancing-free method of [1] or  the balancing-based method of [2] are used. For a descriptor system the balancing related order reduction  methods of [3] are used. To preserve the DC-gain of the original system, the singular perturbation  approximation method of [4] is used in conjunction with the balancing-based or balancing-free approach of [5]. </p><p>References</p><p>[1] A. Varga.      Efficient minimal realization procedure based on balancing.     In A. El Moudni, P. Borne, and S.G. Tzafestas (Eds.),      Prepr. of the IMACS Symp. on Modelling and Control of Technological      Systems, Lille, France, vol. 2, pp.42-47, 1991.</p><p>[2] M. S. Tombs and I. Postlethwaite.      Truncated balanced realization of a stable non-minimal state-space      system. Int. J. Control, vol. 46, pp. 1319–1330, 1987.</p><p>[3] T. Stykel.      Gramian based model reduction for descriptor systems.      Mathematics of Control, Signals, and Systems, 16:297–319, 2004.</p><p>[4] Y. Liu Y. and B.D.O. Anderson      Singular Perturbation Approximation of Balanced Systems,     Int. J. Control, Vol. 50, pp. 1379-1405, 1989.</p><p>[5] Varga A.     Balancing-free square-root algorithm for computing singular perturbation approximations.     Proc. 30-th IEEE CDC,  Brighton, Dec. 11-13, 1991, Vol. 2, pp. 1062-1065.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/descriptor.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.baltrunc_coprime-Union{Tuple{Any}, Tuple{F}, Tuple{Any, Any}} where F" href="#RobustAndOptimalControl.baltrunc_coprime-Union{Tuple{Any}, Tuple{F}, Tuple{Any, Any}} where F"><code>RobustAndOptimalControl.baltrunc_coprime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysr, hs, info = baltrunc_coprime(sys; residual = false, n = missing, factorization::F = DescriptorSystems.gnlcf, kwargs...)</code></pre><p>Compute a balanced truncation of the left coprime factorization of <code>sys</code>. See <a href="#RobustAndOptimalControl.baltrunc2-Tuple{LTISystem}"><code>baltrunc2</code></a> for additional keyword-argument help.</p><p>Coprime-factor reduction performs a coprime factorization of the model into <span>$P(s) = M(s)^{-1}N(s)$</span> where <span>$M$</span> and <span>$N$</span> are stable factors even if <span>$P$</span> contains unstable modes. After this, the system <span>$NM = \begin{bmatrix}N &amp; M \end{bmatrix}$</span> is reduced using balanced truncation and the final reduced-order model is formed as <span>$P_r(s) = M_r(s)^{-1}N_r(s)$</span>. For this method, the Hankel signular values of <span>$NM$</span> are reported and the reported errors are <span>$||NM - N_rM_r||_\infty$</span>. This method is of particular interest in closed-loop situations, where a model-reduction error <span>$||NM - N_rM_r||_\infty$</span> no greater than the normalized-coprime margin of the plant and the controller, guaratees that the closed loop remains stable when either <span>$P$</span> or <span>$K$</span> are reduced. The normalized-coprime margin can be computed with <code>ncfmargin(P, K)</code> (<a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>).</p><p><strong>Arguments:</strong></p><ul><li><code>factorization</code>: The function to perform the coprime factorization. A non-normalized factorization may be used by passing <code>RobustAndOptimalControl.DescriptorSystems.glcf</code>.</li><li><code>kwargs</code>: Are passed to <code>DescriptorSystems.gbalmr</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/descriptor.jl#L93-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.baltrunc_unstab" href="#RobustAndOptimalControl.baltrunc_unstab"><code>RobustAndOptimalControl.baltrunc_unstab</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">baltrunc_unstab(sys::LTISystem; residual = false, n = missing, kwargs...)</code></pre><p>Balanced truncation for unstable models. An additive decomposition of sys into <code>sys = sys_stable + sys_unstable</code> is performed after which <code>sys_stable</code> is reduced. The order <code>n</code> must not be less than the number of unstable poles.</p><p>See <code>baltrunc2</code> for other keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/descriptor.jl#L132-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}" href="#RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bilinearc2d(Ac::AbstractArray, Bc::AbstractArray, Cc::AbstractArray, Dc::AbstractArray, Ts::Number; tolerance=1e-12)</code></pre><p>Balanced Bilinear transformation in State-Space. This method computes a discrete time equivalent of a continuous-time system, such that</p><p class="math-container">\[G_d(z) = s2z[G_c(s)]\]</p><p>in a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that <span>$||B||_2=||C||_2$</span>   (iii) Satisfies <span>$G_c(s) = z2s[s2z[G_c(s)]]$</span> for some map z2s[]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L1067-L1079">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{Continuous}, Number}" href="#RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bilinearc2d(sys::ExtendedStateSpace, Ts::Number)</code></pre><p>Applies a Balanced Bilinear transformation to a discrete-time extended statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L1140-L1144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.bilinearc2d-Tuple{StateSpace{Continuous}, Number}" href="#RobustAndOptimalControl.bilinearc2d-Tuple{StateSpace{Continuous}, Number}"><code>RobustAndOptimalControl.bilinearc2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bilinearc2d(sys::StateSpace, Ts::Number)</code></pre><p>Applies a Balanced Bilinear transformation to a discrete-time statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L1124-L1128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}" href="#RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}"><code>RobustAndOptimalControl.bilineard2c</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bilineard2c(Ad::AbstractArray, Bd::AbstractArray, Cd::AbstractArray, Dd::AbstractArray, Ts::Number; tolerance=1e-12)</code></pre><p>Balanced Bilinear transformation in State-Space. This method computes a continuous time equivalent of a discrete time system, such that</p><pre><code class="nohighlight hljs">G_c(z) = z2s[G_d(z)]</code></pre><p>in a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||<em>2=||C||</em>2   (iii) Satisfies G<em>d(z) = s2z[z2s[G</em>d(z)]] for some map s2z[]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L963-L975">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bilineard2c(sys::ExtendedStateSpace)</code></pre><p>Applies a Balanced Bilinear transformation to continuous-time extended statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L1031-L1035">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.bilineard2c-Tuple{StateSpace}" href="#RobustAndOptimalControl.bilineard2c-Tuple{StateSpace}"><code>RobustAndOptimalControl.bilineard2c</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bilineard2c(sys::StateSpace)</code></pre><p>Applies a Balanced Bilinear transformation to continuous-time statespace object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L1014-L1018">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.blocksort-Tuple{UncertainSS}" href="#RobustAndOptimalControl.blocksort-Tuple{UncertainSS}"><code>RobustAndOptimalControl.blocksort</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">blocks, M = blocksort(P::UncertainSS)</code></pre><p>Returns the block structure of <code>P.Δ</code> as well as <code>P.M</code> permuted according to the sorted block structure. <code>blocks</code> is a vector of vectors with the block structure of perturbation blocks as described by μ-tools, i.e.</p><ul><li><code>[-N, 0]</code> denotes a repeated real block of size <code>N</code></li><li><code>[N, 0]</code> denotes a repeated complex block of size <code>N</code></li><li><code>[ny, nu]</code> denotes a full complex block of size <code>ny × nu</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L622-L629">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.broken_feedback-Tuple{LTISystem, Any}" href="#RobustAndOptimalControl.broken_feedback-Tuple{LTISystem, Any}"><code>RobustAndOptimalControl.broken_feedback</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">broken_feedback(L, i)</code></pre><p>Closes all loops in square MIMO system <code>L</code> except for loops <code>i</code>. Forms L1 in fig 14. of <a href="https://arxiv.org/abs/2003.04771">&quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L353-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.closedloop" href="#RobustAndOptimalControl.closedloop"><code>RobustAndOptimalControl.closedloop</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">closedloop(l::LQGProblem, L = lqr(l), K = kalman(l))</code></pre><p>Closed-loop system as defined in Glad and Ljung eq. 8.28. Note, this definition of closed loop is not the same as lft(P, K), which has B1 instead of B2 as input matrix. Use <code>lft(l)</code> to get the system from disturbances to controlled variables <code>w -&gt; z</code>.</p><p>The return value will be the closed loop from reference only, other disturbance signals (B1) are ignored. See <a href="@ref"><code>feedback</code></a> for a more advanced option.</p><p>Use <code>static_gain_compensation</code> to adjust the gain from references acting on the input B2, <code>dcgain(closedloop(l))*static_gain_compensation(l) ≈ I</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L353-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.connect-Tuple{Any, AbstractVector{&lt;:Pair}}" href="#RobustAndOptimalControl.connect-Tuple{Any, AbstractVector{&lt;:Pair}}"><code>RobustAndOptimalControl.connect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connect(systems, connections; w1, z1 = (:), verbose = true, unique = true, kwargs...)</code></pre><p>Create block connections using named inputs and outputs.</p><p>Addition and subtraction nodes are achieved by creating a linear combination node, i.e., a system with a <code>D</code> matrix only.</p><p><strong>Arguments:</strong></p><ul><li><code>systems</code>: A vector of named systems to be connected</li><li><code>connections</code>: a vector of pairs output =&gt; input, where each pair maps an output to an input. Each output must appear as an output in one of <code>systems</code>, and similarly each input must appear as an input in one of <code>systems</code>. All inputs must have unique names and so must all outputs, but an input may have the same name as an output. In the example below the connection <code>:uP =&gt; :uP</code> connects the output <code>:uP</code> of the <code>addP</code> block to <code>P</code>&#39;s input <code>:uP</code></li><li><code>w1</code>: external signals to be used as inputs in the constructed system. Use <code>(:)</code> to indicate all signals</li><li><code>z1</code>: outputs of the constructed system. Use <code>(:)</code> to indicate all signals</li><li><code>verbose</code>: Issue warnings for signals that have no connection</li><li><code>unique</code>: If <code>true</code>, all input names must be unique. If <code>false</code>, a single external input signal may be connected to multiple input ports with the same name.</li></ul><p>Note: Positive feedback is used, controllers that are intended to be connected with negative feedback must thus be negated.</p><p>Example: The following complicated feedback interconnection</p><pre><code class="nohighlight hljs">                 yF
               ┌────────────────────────────────┐
               │                                │
    ┌───────┐  │  ┌───────┐        ┌───────┐    │    ┌───────┐
uF  │       │  │  │       | yR     │       │ yC │ uP │       │   yP
────►   F   ├──┴──►   R   │────+───►   C   ├────+────►   P   ├───┬────►
    │       │     │       │    │   │       │         │       │   │
    └───────┘     └───────┘    │   └───────┘         └───────┘   │
                               │                                 │
                               └─────────────────────────────────┘</code></pre><p>can be created by</p><pre><code class="nohighlight hljs">F = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)
R = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)
C = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)
P = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)

addP = sumblock(&quot;uP = yF + yC&quot;) # Sum node before P
addC = sumblock(&quot;uC = yR - yP&quot;) # Sum node before C

connections = [
    :yP =&gt; :yP # Output to input
    :uP =&gt; :uP
    :yC =&gt; :yC
    :yF =&gt; :yF
    :yF =&gt; :uR
    :uC =&gt; :uC
    :yR =&gt; :yR
]
w1 = [:uF] # External inputs

G = connect([F, R, C, P, addP, addC], connections; w1)</code></pre><p>If an external input is to be connected to multiple points, use a <code>splitter</code> to split up the signal into a set of unique names which are then used in the connections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/named_systems2.jl#L441-L498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.controller_reduction" href="#RobustAndOptimalControl.controller_reduction"><code>RobustAndOptimalControl.controller_reduction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">controller_reduction(P::ExtendedStateSpace, K, r, out=true; kwargs...)</code></pre><p>Minimize    ||(K-Kᵣ) W||∞ if out=false             ||W (K-Kᵣ)||∞ if out=true See Robust and Optimal Control Ch 19.1 out indicates if the weight will be applied as output or input weight.</p><p>This function expects a *positive feedback controller <code>K</code>.</p><p>This method corresponds to the methods labelled SW1/SW2(SPA) in  Andreas Varga, &quot;Controller Reduction Using Accuracy-Enhancing Methods&quot; SW1 is the default method, corresponding to <code>out=true</code>.</p><p>This method does not support unstable controllers. See the reference above for alternatives. See also <a href="#RobustAndOptimalControl.stab_unstab-Tuple{Any}"><code>stab_unstab</code></a> and <a href="#RobustAndOptimalControl.baltrunc_unstab"><code>baltrunc_unstab</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/reduction.jl#L163-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.controller_reduction_plot" href="#RobustAndOptimalControl.controller_reduction_plot"><code>RobustAndOptimalControl.controller_reduction_plot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">controller_reduction_plot(G, K)</code></pre><p>Plot the normalized-coprime margin (<a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>) as a function of controller order when <a href="#RobustAndOptimalControl.baltrunc_coprime-Union{Tuple{Any}, Tuple{F}, Tuple{Any, Any}} where F"><code>baltrunc_coprime</code></a> is used to reduce the controller. Red, orange and green bands correspond to rules of thumb for bad, okay and good coprime uncertainty margins. A value of 0 indicate an unstable closed loop.</p><p>If <code>G</code> is an ExtendedStateSpace system, a second plot will be shown indicating the <span>$H_∞$</span> norm between inputs and performance outputs <span>$||T_{zw}||_\infty$</span> when the function <a href="#RobustAndOptimalControl.controller_reduction"><code>controller_reduction</code></a> is used to reduce the controller.</p><p>The order of the controller can safely be reduced as long as the normalized coprime margin remains sufficiently large. If the controller contains integrators, it may be advicable to protect the integrators from the reduction, e.g., if the controller is obtained using <a href="#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a>, perform the reduction on <code>info.Gs, info.Ks</code> rather than on <code>K</code>, and form <code>Kr</code> using the reduced <code>Ks</code>.</p><p>See <a href="#RobustAndOptimalControl.glover_mcfarlane"><code>glover_mcfarlane</code></a> or <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#Example-of-controller-reduction:">the docs</a> for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/reduction.jl#L261-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.controller_reduction_weight-Tuple{ExtendedStateSpace, Any}" href="#RobustAndOptimalControl.controller_reduction_weight-Tuple{ExtendedStateSpace, Any}"><code>RobustAndOptimalControl.controller_reduction_weight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">controller_reduction_weight(P::ExtendedStateSpace, K)</code></pre><p>Lemma 19.1 See Robust and Optimal Control Ch 19.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/reduction.jl#L141-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.dare3-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, AbstractMatrix, AbstractMatrix}" href="#RobustAndOptimalControl.dare3-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.dare3</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dare3(P::AbstractStateSpace, Q1::AbstractMatrix, Q2::AbstractMatrix, Q3::AbstractMatrix; full=false)</code></pre><p>Solve the discrete-time algebraic Riccati equation for a discrete LQR cost augmented with control differences</p><p class="math-container">\[x^{T} Q_1 x + u^{T} Q_2 u + Δu^{T} Q_3 Δu, \quad
Δu = u(k) - u(k-1)\]</p><p>If <code>full</code>, the returned matrix will include the state <code>u(k-1)</code>, otherwise the returned matrix will be of the same size as <code>Q1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L204-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.diskmargin" href="#RobustAndOptimalControl.diskmargin"><code>RobustAndOptimalControl.diskmargin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diskmargin(L, σ = 0)
diskmargin(L, σ::Real, ω)</code></pre><p>Calculate the disk margin of LTI system <code>L</code>. <code>L</code> is supposed to be a loop-transfer function, i.e., it should be square. If <code>L = PC</code> the disk margin for output perturbations is computed, whereas if <code>L = CP</code>, input perturbations are considered. If the method <code>diskmargin(P, C, args...)</code> is used, both are computed. Note, if <code>L</code> is MIMO, a simultaneous margin is computed, see <a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, LTISystem, Vararg{Any}}"><code>loop_diskmargin</code></a> for single loop margins of MIMO systems.</p><p>The implementation and notation follows <a href="https://arxiv.org/abs/2003.04771">&quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet</a>.</p><p>The margins are aviable as fields of the returned objects, see <a href="#RobustAndOptimalControl.Diskmargin"><code>Diskmargin</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>L</code>: A loop-transfer function.</li><li><code>σ</code>: If little is known about the distribution of gain variations then σ = 0 is a reasonable choice as it allows for a gain increase or decrease by the same relative amount. <em>The choice σ &lt; 0</em> is justified if the gain can decrease by a larger factor than it can increase. Similarly, <em>the choice σ &gt; 0</em> is justified when the gain can increase by a larger factor than it can decrease. <em>If σ = −1</em> then the disk margin condition is αmax = inv(MT). This margin is related to the robust stability condition for models with multiplicative uncertainty of the form P (1 + δ). If σ = +1 then the disk margin condition is αmax = inv(MS)</li><li><code>kwargs</code>: Are sent to the <a href="@ref"><code>hinfnorm</code></a> calculation</li><li><code>ω</code>: If a vector of frequencies is supplied, the frequency-dependent disk margin will be computed, see example below.</li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">L = tf(25, [1,10,10,10])
dm = diskmargin(L, 0)
plot(dm) # Plot the disk margin to illustrate maximum allowed simultaneous gain and phase variations.

nyquistplot(L)
plot!(dm, nyquist=true) # plot a nyquist exclusion disk. The Nyquist curve will be tangent to this disk at `dm.ω0`
nyquistplot!(dm.f0*L) # If we perturb the system with the worst-case perturbation `f0`, the curve will pass through the critical point -1.

## Frequency-dependent margin
w = exp10.(LinRange(-2, 2, 500))
dms = diskmargin(L, 0, w)
plot(dms; lower=true, phase=true)</code></pre><p><strong>Example: relation to Ms and Mt</strong></p><pre><code class="nohighlight hljs">Ms, wMs = hinfnorm(input_sensitivity(P, C)) # Input Ms
dm = diskmargin(C*P, 1) # Input diskmargin, skew = +1
isapprox(Ms/(Ms-1), dm.gainmargin[2], rtol=1e-2) # Guaranteed gain margin based on Ms
isapprox(inv(Ms), dm.margin, rtol=1e-2)
isapprox(dm.ω0, wMs, rtol=1e-1)


Mt, wMt = hinfnorm(input_comp_sensitivity(P, C)) # Input Mt
dm = diskmargin(C*P, -1) # Input diskmargin, skew = -1
isapprox(inv(Mt), dm.margin, rtol=1e-2)
isapprox(dm.ω0, wMt, rtol=1e-1)</code></pre><p>See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a> and <a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, LTISystem, Vararg{Any}}"><code>loop_diskmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/diskmargin.jl#L138-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.diskmargin-Tuple{LTISystem, LTISystem, Any, AbstractVector, Vararg{Any}}" href="#RobustAndOptimalControl.diskmargin-Tuple{LTISystem, LTISystem, Any, AbstractVector, Vararg{Any}}"><code>RobustAndOptimalControl.diskmargin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diskmargin(P::LTISystem, C::LTISystem, σ, w::AbstractVector, args...; kwargs...)</code></pre><p>Simultaneuous diskmargin at outputs, inputs and input/output simultaneously of <code>P</code>.  Returns a named tuple with the fields <code>input, output, simultaneous_input, simultaneous_output, simultaneous</code> where <code>input</code> and <code>output</code> represent loop-at-a-time margins, <code>simultaneous_input</code> is the margin for simultaneous perturbations on all inputs and <code>simultaneous</code> is the margin for perturbations on all inputs and outputs simultaneously.</p><p>Note: simultaneous margins are more conservative than single-loop margins and are likely to be much lower than the single-loop margins. Indeed, with several simultaneous perturbations, it&#39;s in general easier to make the system unstable. It&#39;s not uncommon for a simultaneous margin involving two signals to be on the order of half the size of the single-loop margins.</p><p>See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a> and <a href="#RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, LTISystem, Vararg{Any}}"><code>loop_diskmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L297-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.diskmargin-Tuple{LTISystem, Real, AbstractArray}" href="#RobustAndOptimalControl.diskmargin-Tuple{LTISystem, Real, AbstractArray}"><code>RobustAndOptimalControl.diskmargin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diskmargin(L::LTISystem, σ::Real, ω)</code></pre><p>Calculate the diskmargin at a particular frequency or vector of frequencies. If <code>ω</code> is a vector, you get a frequency-dependent diskmargin plot if you plot the returned value. See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/diskmargin.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}" href="#RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}"><code>RobustAndOptimalControl.expand_symbol</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expand_symbol(s::Symbol, n::Int)</code></pre><p>Takes a symbol and an integer and returns a vector of symbols with increasing numbers appended to the end. E.g., (:x, 3) -&gt; [:x1, :x2, :x3]</p><p>The short-hand syntax <code>s^n</code> is also available, e.g., <code>:x^3 == expand_symbol(:x, 3)</code>.</p><p>Useful to create signal names for named systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/named_systems2.jl#L107-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.extended_controller" href="#RobustAndOptimalControl.extended_controller"><code>RobustAndOptimalControl.extended_controller</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extended_controller(l::LQGProblem, L = lqr(l), K = kalman(l))</code></pre><p>Returns an expression for the controller that is obtained when state-feedback <code>u = -L(xᵣ-x̂)</code> is combined with a Kalman filter with gain <code>K</code> that produces state estimates x̂. The controller is an instance of <code>ExtendedStateSpace</code> where <code>C2 = -L, D21 = L</code> and <code>B2 = K</code>.</p><p>The returned system has <em>inputs</em> <code>[xᵣ; y]</code> and outputs the control signal <code>u</code>. If a reference model <code>R</code> is used to generate state references <code>xᵣ</code>, the controller from <code>e = ry - y -&gt; u</code> is given by</p><pre><code class="language-julia hljs">Ce = extended_controller(l)
Ce = named_ss(Ce; x = :xC, y = :u, u = [R.y; :y^l.ny]) # Name the inputs of Ce the same as the outputs of `R`.
connect([R, Ce]; u1 = R.y, y1 = R.y, w1 = [:ry^l.ny, :y^l.ny], z1=[:u])</code></pre><p>Since the negative part of the feedback is built into the returned system, we have</p><pre><code class="language-julia hljs">C = observer_controller(l)
Ce = extended_controller(l)
system_mapping(Ce) == -C</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L268-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.extended_controller-Tuple{AbstractStateSpace}" href="#RobustAndOptimalControl.extended_controller-Tuple{AbstractStateSpace}"><code>RobustAndOptimalControl.extended_controller</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extended_controller(K::AbstractStateSpace)</code></pre><p>Takes a controller and returns an <code>ExtendedStateSpace</code> version which has augmented input <code>[r; y]</code> and output <code>y</code> (<code>z</code> output is 0-dim).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.feedback_control-Tuple{Any, Any}" href="#RobustAndOptimalControl.feedback_control-Tuple{Any, Any}"><code>RobustAndOptimalControl.feedback_control</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G = feedback_control(P, K)</code></pre><p>Return the (negative feedback) closed-loop system from input of <code>K</code> to output of <code>P</code> while outputing also the control signal (output of <code>K</code>), i.e., <code>G</code> maps references to <code>[y; u]</code></p><p><strong>Example:</strong></p><p>The following are two equivalent ways of achieving the same thing</p><pre><code class="language-julia hljs">G = ssrand(3,4,2)
K = ssrand(4,3,2)

Gcl1 = feedback_control(G, K) # First option

# Second option using named systems and connect
G = named_ss(G, :G)
K = named_ss(K, :K)
S = sumblock(&quot;Ku = r - Gy&quot;, n=3) # Create a sumblock that computes r - Gy for vectors of length 3

z1 = [G.y; K.y] # Output both plant and controller outputs
w1 = :r^3       # Extenal inputs are the three references into the sum block
connections = [K.y .=&gt; G.u; G.y .=&gt; G.y; K.u .=&gt; K.u] # Since the sumblock uses the same names as the IO signals of G,K, we can reuse these names here
Gcl2 = connect([G, K, S], connections; z1, w1)

@test linfnorm(minreal(Gcl1 - Gcl2.sys))[1] &lt; 1e-10 # They are the same</code></pre><p>To include also an input disturbance, use</p><pre><code class="nohighlight hljs">Gcl = feedback(K, P, W2=:, Z2=:, Zperm=[(1:ny).+nu; 1:nu]) # y,u from r,d</code></pre><p>See also <a href="@ref"><code>extended_gangoffour</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L466-L500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.ff_controller" href="#RobustAndOptimalControl.ff_controller"><code>RobustAndOptimalControl.ff_controller</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ff_controller(l::LQGProblem, L = lqr(l), K = kalman(l))</code></pre><p>Return the feedforward controller <span>$C_{ff}$</span> that maps references to plant inputs: <span>$u = C_{fb}y + C_{ff}r$</span></p><p>See also <a href="@ref"><code>observer_controller</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L336-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any}, Tuple{StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any, F}} where {N, F}" href="#RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any}, Tuple{StateSpace{&lt;:Any, &lt;:MonteCarloMeasurements.AbstractParticles{&lt;:Any, N}}, Any, F}} where {N, F}"><code>RobustAndOptimalControl.find_lft</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">l, res = find_lft(sys::StateSpace{&lt;:Any, &lt;:StaticParticles{&lt;:Any, N}}, δ) where N</code></pre><p>NOTE: This function is experimental. </p><p>Given an systems <code>sys</code> with uncertain coefficients in the form of <code>StaticParticles</code>, search for a lower linear fractional transformation <code>M</code> such that <code>lft(M, δ) ≈ sys</code>. </p><p><code>δ</code> can be either the source of uncertainty in <code>sys</code>, i.e., a vector of the unique uncertain parameters that were used to create <code>sys</code>. These should be constructed as uniform randomly distributed particles for most robust-control theory to be applicable.  <code>δ</code> can also be an integer, in which case a numer of <code>δ</code> sources of uncertainty are automatically created. This could be used for order reduction if the number of uncertainty sources in <code>sys</code> is large.</p><p>Note, uncertainty in <code>sys</code> is only supported in <code>A</code> and <code>B</code>, <code>C</code> and <code>D</code> must be deterministic.</p><p>Returns <code>l::LFT</code> that internaly contains all four blocks of <code>M</code> as well as <code>δ</code>. Call <code>ss(l,sys)</code> do obtain <code>lft(M, δ) ≈ sys</code>.</p><p>Call <code>Matrix(l)</code> to obtain <code>M = [M11 M12; M21 M22]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/find_lft.jl#L57-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}" href="#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}"><code>RobustAndOptimalControl.fit_complex_perturbations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centers, radii = fit_complex_perturbations(P, w; relative=true, nominal=:mean)</code></pre><p>For each frequency in <code>w</code>, fit a circle in the complex plane that contains all models in the model set <code>P</code>, represented as an <code>LTISystem</code> with <code>Particles</code> coefficients. Note, the resulting radii can be quite unstable if the number of particles is small, in particular if the particles are normally distributed instead of uniformly.</p><p>If <code>realtive = true</code>, circles encompassing <code>|(P - Pn)/Pn|</code> will be returned (multiplicative/relative uncertainty). If <code>realtive = false</code>, circles encompassing <code>|P - Pn|</code> will be returned (additive uncertainty).</p><p>If <code>nominal = :mean</code>, the mean of <code>P</code> will be used as nominal model. If <code>nominal = :first</code>, the first particle will be used. See <code>MonteCarloMeasurements.with_nominal</code> to set the nominal value in the first particle. If <code>nominal = :center</code>, the middle point <code>(pmaximum(ri)+pminimum(ri))/2</code> will be used. This typically gives the smallest circles.</p><p>See also <a href="#RobustAndOptimalControl.nyquistcircles"><code>nyquistcircles</code></a> to plot circles (only if relative=false).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/weights.jl#L113-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.frequency_separation-Tuple{Any, Any}" href="#RobustAndOptimalControl.frequency_separation-Tuple{Any, Any}"><code>RobustAndOptimalControl.frequency_separation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frequency_separation(sys, ω)</code></pre><p>Decomponse <code>sys</code> into <code>sys = sys_slow + sys_fast</code>, where <code>sys_slow</code> contain all modes with eigenvalues with absolute value less than <code>ω</code> and <code>sys_fast</code> contain all modes with eigenvalues with absolute value greater than or equal to <code>ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/canonical.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.frequency_weighted_reduction" href="#RobustAndOptimalControl.frequency_weighted_reduction"><code>RobustAndOptimalControl.frequency_weighted_reduction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysr, hs = frequency_weighted_reduction(G, Wo, Wi, r=nothing; residual=true)</code></pre><p>Find Gr such that <span>$||Wₒ(G-Gr)Wᵢ||∞$</span> is minimized. For a realtive reduction, set Wo = inv(G) and Wi = I.</p><p>If <code>residual = true</code>, matched static gain is achieved through &quot;residualization&quot;, i.e., setting</p><p class="math-container">\[0 = A_{21}x_{1} + A_{22}x_{2} + B_{2}u\]</p><p>where indices 1/2 correspond to the remaining/truncated states respectively. This choice typically results in a better match in the low-frequency region and a smaller overall error.</p><p>Ref: <a href="https://elib.dlr.de/11746/1/varga_cdc01p2.pdf">Andras Varga and Brian D.O. Anderson, &quot;Accuracy enhancing methods for the frequency-weighted balancing related model reduction&quot;</a></p><p>Note: This function only handles exponentially stable models. To reduce unstable  and marginally stable models, decompose the system into stable and unstable parts using <a href="#RobustAndOptimalControl.stab_unstab-Tuple{Any}"><code>stab_unstab</code></a>, reduce the stable part and then add the unstable part back.</p><p><strong>Example:</strong></p><p>The following example performs reduction with a frequency focus between frequencies <code>w1</code> and <code>w2</code>.</p><pre><code class="language-julia hljs">using DSP
w1 = 1e-4
w2 = 1e-1
wmax = 1
fc = DSP.analogfilter(DSP.Bandpass(w1, w2, fs=wmax), DSP.Butterworth(2))
tfc = DSP.PolynomialRatio(fc)
W = tf(DSP.coefb(tfc), DSP.coefa(tfc))
rsys, hs = frequency_weighted_reduction(sys, W, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/reduction.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.fudge_inv" href="#RobustAndOptimalControl.fudge_inv"><code>RobustAndOptimalControl.fudge_inv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fudge_inv(s::AbstractStateSpace, ε = 0.001)</code></pre><p>Allow inverting a proper statespace system by adding a tiny (ε) feedthrough term to the <code>D</code> matrix. The system must still be square.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L1175-L1179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}" href="#RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}"><code>RobustAndOptimalControl.gain_and_delay_uncertainty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gain_and_delay_uncertainty(kmin, kmax, Lmax)</code></pre><p>Return a multiplicative weight to represent the uncertainty coming from neglecting the dynamics <code>k*exp(-s*L)</code> where <code>k ∈ [kmin, kmax]</code> and <code>L ≤ Lmax</code>. This weight is slightly optimistic, an expression for a more exact weight appears in eq (7.27), &quot;Multivariable Feedback Control: Analysis and Design&quot;</p><p>See also <a href="#RobustAndOptimalControl.neglected_lag-Tuple{Any}"><code>neglected_lag</code></a> and <a href="#RobustAndOptimalControl.neglected_delay-Tuple{Any}"><code>neglected_delay</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">a = 10
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0) # Plant
W0 = gain_and_delay_uncertainty(0.5, 2, 0.005) |&gt; ss # Weight
W = I(2) + W0*I(2) * uss([δc(), δc()]) # Create a diagonal real uncertainty weighted in frequency by W0
Ps = P*W # Uncertain plant
Psamples = rand(Ps, 500) # Sample the uncertain plant for plotting
w = exp10.(LinRange(-1, 3, 300)) # Frequency vector
bodeplot(Psamples, w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/weights.jl#L59-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.gainphaseplot" href="#RobustAndOptimalControl.gainphaseplot"><code>RobustAndOptimalControl.gainphaseplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gainphaseplot(P)
gainphaseplot(P, re, im)</code></pre><p>Plot complex perturbantions to the plant <code>P</code> and indicate whether or not the closed-loop system is stable. The diskmargin is the largest disk that can be fit inside the green region that only contains stable variations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/diskmargin.jl#L427-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.glover_mcfarlane" href="#RobustAndOptimalControl.glover_mcfarlane"><code>RobustAndOptimalControl.glover_mcfarlane</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">K, γ, info = glover_mcfarlane(G::AbstractStateSpace{&lt;:Discrete}, γ = 1.1; W1=1, W2=1, strictly_proper=false)</code></pre><p>For discrete systems, the <code>info</code> tuple contains also feedback gains <code>F, L</code> and observer gain <code>Hkf</code> such that the controller on observer form is given by</p><p class="math-container">\[x^+ = Ax + Bu + H_{kf} (Cx - y)\\
u = Fx + L (Cx - y)\]</p><p>Note, this controller is <em>not</em> strictly proper, i.e., it has a non-zero D matrix. The controller can be transformed to observer form for the scaled plant (<code>info.Gs</code>) by <code>Ko = observer_controller(info)</code>, in which case the following holds <code>G*K == info.Gs*Ko</code> (realizations are different).</p><p>If <code>strictly_proper = true</code>, the returned controller <code>K</code> will have <code>D == 0</code>. This can be advantageous in implementations where computational delays are present. In this case, <code>info.L == 0</code> as well.</p><p>Ref discrete version: Iglesias, &quot;The Strictly Proper Discrete-Time Controller for the Normalized Left-Coprime Factorization Robust Stabilization Problem&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/glover_mcfarlane.jl#L168-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.glover_mcfarlane" href="#RobustAndOptimalControl.glover_mcfarlane"><code>RobustAndOptimalControl.glover_mcfarlane</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">K, γ, info = glover_mcfarlane(G::AbstractStateSpace, γ = 1.1; W1=1, W2=1)</code></pre><p>Design a controller for <code>G</code> that maximizes the stability margin ϵ = 1/γ with normalized coprime factor uncertainty using the method of Glover and McFarlane</p><pre><code class="nohighlight hljs">γ = 1/ϵ = ||[K;I] inv(I-G*K)*inv(M)||∞
G = inv(M + ΔM)*(N + ΔN)</code></pre><p>γ is given as a relative factor above γmin and must be greater than 1, i.e., if γ = 1.1, the controller will be designed for γ = 1.1*γmin.</p><p>We want γmin (which is always ≥ 1) as small as possible, and we usually require that γmin is less than 4, corresponding to 25% allowed coprime uncertainty.</p><p>Performance modeling is incorporated in the design by calling <code>glover_mcfarlane</code> on the shaped system <code>Gs = W2*G*W1</code> and then forming the controller as <code>K = W1*Ks*W2</code>. Using this formulation, traditional loop shaping can be done on <code>Gs = W2*G*W1</code>. The plant shaping is handled internally if keyword arguments <code>W1, W2</code> are used and the returned controller is already scaled. In this case, <code>Gs</code> and <code>Ks</code> are included in the <code>info</code> named tuple for inspection. </p><p>See also <a href="#RobustAndOptimalControl.glover_mcfarlane_2dof"><code>glover_mcfarlane_2dof</code></a> to design a feedforward filter as well and <a href="#RobustAndOptimalControl.baltrunc_coprime-Union{Tuple{Any}, Tuple{F}, Tuple{Any, Any}} where F"><code>baltrunc_coprime</code></a> for controller order reduction. When reducing the order of the calculated controller, reduce the order of <code>info.Ks</code> and form <code>Kr=W1*Ksred*W2</code>. Verify the robustness using <code>ncfmargin(info.Gs, Ksred)</code> as well as <code>ncfmargin(G, Kr)</code>.</p><p><strong>Example:</strong></p><p>Example 9.3 from the reference below.</p><pre><code class="language- hljs">using RobustAndOptimalControl, ControlSystemsBase, Plots, Test
G = tf(200, [10, 1])*tf(1, [0.05, 1])^2     |&gt; ss
Gd = tf(100, [10, 1])                       |&gt; ss
W1 = tf([1, 2], [1, 1e-6])                  |&gt; ss
K, γ, info = glover_mcfarlane(G, 1.1; W1)
@test info.γmin ≈ 2.34 atol=0.005
Gcl = extended_gangoffour(G, K) # Form closed-loop system

fig1 = bodeplot([G, info.Gs, G*K], lab=[&quot;G&quot; &quot;&quot; &quot;G scaled&quot; &quot;&quot; &quot;Loop transfer&quot;])
fig2 = bodeplot(Gcl, lab=[&quot;S&quot; &quot;KS&quot; &quot;PS&quot; &quot;T&quot;], plotphase=false) # Plot gang of four

fig3 = plot(step(Gd*feedback(1, info.Gs), 3), lab=&quot;Initial controller&quot;)
plot!(step(Gd*feedback(1, G*K), 3), lab=&quot;Robustified&quot;)
fig4 = nyquistplot([info.Gs, G*K], ylims=(-2,1), xlims=(-2, 1),
    Ms_circles = 1.5,
    lab = [&quot;Initial controller&quot; &quot;Robustified&quot;],
    title = &quot;Loop transfers with and without robustified controller&quot;
)
plot(fig1, fig2, fig3, fig4)</code></pre><p>Example of controller reduction: The order of the controller designed above can be reduced maintaining at least 2/3 of the robustness margin like this</p><pre><code class="language- hljs">e,_ = ncfmargin(info.Gs, info.Ks)
Kr, hs, infor = baltrunc_coprime(info.Ks, n=info.Ks.nx)
n = findlast(RobustAndOptimalControl.error_bound(hs) .&gt; 2e/3) # 2/3 e sets the robustness margin
Ksr, hs, infor = baltrunc_coprime(info.Ks; n)
@test ncfmargin(info.Gs, Ksr)[1] &gt;= 2/3 * e
Kr = W1*Ksr
bodeplot([G*K, G*Kr], lab=[&quot;L original&quot; &quot;&quot; &quot;L Reduced&quot; &quot;&quot;])</code></pre><p>This gives a final controller <code>Kr</code> of order 3 instead of order 5, but a very similar robustness margin. You may also call</p><pre><code class="language- hljs">controller_reduction_plot(info.Gs, info.Ks)</code></pre><p>to help you select the controller order.</p><p>Ref: Sec 9.4.1 of Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;</p><p><strong>Extended help</strong></p><p>Skogestad gives the following general advice:</p><ol><li><p>Scale the plant outputs and inputs. This is very important for most design  procedures and is sometimes forgotten. In general, scaling improves the  conditioning of the design problem, it enables meaningful analysis to be made  of the robustness properties of the feedback system in the frequency domain,  and for loop-shaping it can simplify the selection of weights. There are a variety  of methods available including normalization with respect to the magnitude of  the maximum or average value of the signal in question. If one is to go straight to a design the following variation has  proved useful in practice:</p><ul><li>The outputs are scaled such that equal magnitudes of cross-coupling into each   of the outputs is equally undesirable.</li><li>Each input is scaled by a given percentage (say 10%) of its expected range   of operation. That is, the inputs are scaled to reflect the relative actuator   capabilities.</li></ul></li><li><p>Order the inputs and outputs so that the plant is as diagonal as possible. The  relative gain array <a href="@ref"><code>relative_gain_array</code></a> can be useful here. The purpose of this pseudo-diagonalization  is to ease the design of the pre- and post-compensators which, for simplicity, will  be chosen to be diagonal.</p><p>Next, we discuss the selection of weights to obtain the shaped plant <span>$G_s = W_2 G W_1$</span>  where <span>$W_1 = W_p W_a W_g$</span></p></li><li><p>Select the elements of diagonal pre- and post-compensators <span>$W_p$</span> and <span>$W_2$</span> so that  the singular values of <span>$W_2 G W_p$</span> are desirable. This would normally mean high  gain at low frequencies, roll-off rates of approximately 20 dB/decade (a slope of  about 1) at the desired bandwidth(s), with higher rates at high frequencies. Some  trial and error is involved here. <span>$W_2$</span> is usually chosen as a constant, reflecting the  relative importance of the outputs to be controlled and the other measurements  being fed back to the controller. For example, if there are feedback measurements  of two outputs to be controlled and a velocity signal, then <span>$W_2$</span> might be chosen  to be <code>diag([1, 1, 0.1])</code>, where 0.1 is in the velocity signal channel. <span>$W_p$</span> contains the  dynamic shaping. Integral action, for low frequency performance; phase-advance  for reducing the roll-off rates at crossover, and phase-lag to increase the roll-off  rates at high frequencies should all be placed in <span>$W_p$</span> if desired. The weights should  be chosen so that no unstable hidden modes are created in <span>$G_s$</span>.</p></li><li><p>Optional: Introduce an additional gain matrix <span>$W_g$</span> cascaded with <span>$W_a$</span> to provide  control over actuator usage. <span>$W_g$</span> is diagonal and is adjusted so that actuator rate  limits are not exceeded for reference demands and typical disturbances on the  scaled plant outputs. This requires some trial and error.</p></li><li><p>Robustly stabilize the shaped plant <span>$G_s = W_2 G W_1$</span> , where <span>$W_1 = W_p W_a W_g$</span>,  using <code>glover_mcfarlane</code>. First, the maximum stability  margin <span>$ϵ_{max} = 1/γ_{min}$</span> is calculated. If the margin is too small, <span>$ϵmax &lt; 0.25$</span>, then go back and modify the weights. Otherwise, a γ-suboptimal controller is synthesized. There is usually no advantage to be gained by using the optimal controller. When <span>$ϵ_{max}$</span> &gt; 0.25  (respectively <span>$γ_{min}$</span> &lt; 4) the design is usually successful. In this case, at least  25% coprime factor uncertainty is allowed, and we also find that the shape of the  open-loop singular values will not have changed much after robust stabilization.  A small value of ϵmax indicates that the chosen singular value loop-shapes are  incompatible with robust stability requirements. That the loop-shapes do not  change much following robust stabilization if γ is small (ϵ large), is justified  theoretically in McFarlane and Glover (1990).</p></li><li><p>Analyze the design and if all the specifications are not met make further  modifications to the weights.</p></li><li><p>Implement the controller. The configuration shown in below has been found  useful when compared with the conventional set up. This is because  the references do not directly excite the dynamics of <span>$K$</span>, which can result in large amounts of overshoot (classical derivative kick). The constant prefilter ensures a steady-state gain of 1 between r and y, assuming integral action in <span>$W_1$</span> or <span>$G$</span> (note, the K returned by this function has opposite sign compared to that of Skogestad, so we use negative feedback here).</p></li></ol><p>Anti-windup can be added to <span>$W_1$</span> but putting <span>$W_1$</span> on Hanus form after the synthesis, see <a href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>hanus</code></a>.</p><pre><code class="nohighlight hljs">       ┌─────────┐      ┌────────┐      ┌────────┐
    r  │         │    us│        │  u   │        │  y
   ───►│(K*W2)(0)├──+──►│   W1   ├─────►│   G    ├────┬──►
       │         │  │-  │        │      │        │    │
       └─────────┘  │   └────────┘      └────────┘    │
                    │                                 │
                    │                                 │
                    │   ┌────────┐      ┌────────┐    │
                    │   │        │  ys  │        │    │
                    └───┤   K    │◄─────┤   W2   │◄───┘
                        │        │      │        │
                        └────────┘      └────────┘</code></pre><p>Keywords: <code>nfcsyn</code>, <code>coprimeunc</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/glover_mcfarlane.jl#L1-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.glover_mcfarlane_2dof" href="#RobustAndOptimalControl.glover_mcfarlane_2dof"><code>RobustAndOptimalControl.glover_mcfarlane_2dof</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">K, γ, info = glover_mcfarlane_2dof(G::AbstractStateSpace{Continuous}, Tref::AbstractStateSpace{Continuous}, γ = 1.1, ρ = 1.1;
W1 = 1, Wo = I, match_dc = true, kwargs...)</code></pre><p>Joint design of feedback and feedforward compensators</p><p class="math-container">\[K = \begin{bmatrix} K_1 &amp; K_2 \end{bmatrix}\]</p><pre><code class="nohighlight hljs">   ┌──────┐   ┌──────┐        ┌──────┐    ┌─────┐
r  │      │   │      │        │      │    │     │
──►│  Wi  ├──►│  K1  ├───+───►│  W1  ├───►│  G  ├─┐y
   │      │   │      │   │    │      │    │     │ │
   └──────┘   └──────┘   │    └──────┘    └─────┘ │
                         │                        │
                         │    ┌──────┐            │
                         │    │      │            │
                         └────┤  K2  ◄────────────┘
                              │      │
                              └──────┘</code></pre><p>Where the returned controller <code>K</code> takes the measurement vector <code>[r; y]</code> (positive feedback),  i.e., it includes all blocks <code>Wi, K1, K2, W1</code>. If <code>match_dc = true</code>, <code>Wi</code> is automatically computed to make sure the static gain matches <code>Tref</code> exactly, otherwise <code>Wi</code> is set to <code>I</code>. The <code>info</code> named tuple contains the feedforward filter for inspection (<code>info.K1 = K1*Wi</code>).</p><p><strong>Arguments:</strong></p><ul><li><code>G</code>: Plant model</li><li><code>Tref</code>: Reference model</li><li><code>γ</code>: Relative γ</li><li><code>ρ</code>: Design parameter, typically 1 &lt; ρ &lt; 3. Increase to emphasize model matching at the expense of robustness.</li><li><code>W1</code>: Pre-compensator for loop shaping.</li><li><code>Wo</code>: Output selction matrix. If there are more measurements than controlled variables, this matrix let&#39;s you select which measurements are to be controlled. </li><li><code>kwargs</code>: Are sent to <a href="#RobustAndOptimalControl.hinfsynthesize-Union{Tuple{ExtendedStateSpace{Continuous, T}}, Tuple{T}} where T"><code>hinfsynthesize</code></a>.</li></ul><p>Ref: Sec. 9.4.3 of Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;. The reference contains valuable pointers regarding gain-scheduling implementation of the designed controller as an observer with feedback from estimated states. In order to get anti-windup protection when <code>W1</code> contains an integrator, transform <code>W1</code> to self-conditioned Hanus form (using <a href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>hanus</code></a>) and implement the controller like this</p><pre><code class="language-julia hljs">W1h = hanus(W1)             # Perform outside loop

# Each iteration
us = filter(Ks, [r; y])     # filter inputs through info.Ks (filter is a fictive function that applies the transfer function)
u  = filter(W1h, [us; ua])  # filter us and u-actual (after input saturation) through W1h
ua = clamp(u, lower, upper) # Calculate ua for next iteration as the saturated value of u</code></pre><p><strong>Example:</strong></p><pre><code class="language- hljs">using RobustAndOptimalControl, Plots
P = tf([1, 5], [1, 2, 10]) # Plant
W1 = tf(1,[1, 0]) |&gt; ss    # Loop shaping controller

Tref = tf(1, [1, 1])^2 |&gt; ss # Reference model (preferably of same order as P)

K1dof, γ1, info1 = glover_mcfarlane(ss(P), 1.1; W1)
K2dof, γ2, info2 = glover_mcfarlane_2dof(ss(P), Tref, 1.1, 1.1; W1)

G1 = feedback(P*K1dof)
G2 = info2.Gcl

w = exp10.(LinRange(-2, 2, 200))
bodeplot(info2.K1, w, lab=&quot;Feedforward filter&quot;)
plot([step(G1, 15), step(G2, 15), step(Tref, 15)], lab=[&quot;1-DOF&quot; &quot;2-DOF&quot; &quot;Tref&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/glover_mcfarlane.jl#L297-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.h2norm-Tuple{LTISystem}" href="#RobustAndOptimalControl.h2norm-Tuple{LTISystem}"><code>RobustAndOptimalControl.h2norm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n = h2norm(sys::LTISystem; kwargs...)</code></pre><p>A numerically robust version of <code>norm</code> using DescriptorSystems.jl</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.gh2norm</code>, reproduced below</p><pre><code class="nohighlight hljs">gh2norm(sys, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atolinf = atol, rtol = n*ϵ)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> the <code>H2</code> norm of its transfer function  matrix <code>G(λ)</code>. The <code>H2</code> norm is infinite, if <code>G(λ)</code> has unstable poles, or, for a continuous-time, the system has nonzero gain at infinity. If the pencil <code>A-λE</code> has uncontrollable and/or unobservable unstable eigenvalues on the boundary of the stability domain, then a reduced order realization is determined first (see below) to eliminate these eigenvalues. </p><p>To check the stability, the eigenvalues of the <em>pole pencil</em> <code>A-λE</code> must have real parts less  than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset. The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable finite and infinite eigenvalues of the pencil <code>A-λE</code>.  For a discrete-time system or for a system with invertible <code>E</code>, a reduced order realization is determined first, without  uncontrollable and unobservable finite eigenvalues of the pencil <code>A-λE</code>. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The keyword argument <code>atolinf</code> is the absolute tolerance for the gain of <code>G(λ)</code> at <code>λ = ∞</code>.  The used default value is <code>atolinf = 0</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/descriptor.jl#L40-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.h2synthesize" href="#RobustAndOptimalControl.h2synthesize"><code>RobustAndOptimalControl.h2synthesize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">K, Cl = h2synthesize(P::ExtendedStateSpace, γ = nothing)</code></pre><p>Synthesize H₂-optimal controller K and calculate the closed-loop transfer function from <code>w</code> to <code>z</code>. Ref: Cha. 14.5 in Robust and Optimal Control.</p><p>If <code>γ = nothing</code>, use the formulas for H₂ in Ch 14.5. If γ is a large value, the H∞ formulas are used. As γ → ∞, these two are equivalent. The h∞ formulas do a coordinate transfromation that handles slightly more general systems so if you run into an error, it might be worth trying setting γ to something large, e.g., 1000.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/h2_design.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hankelnorm-Tuple{LTISystem}" href="#RobustAndOptimalControl.hankelnorm-Tuple{LTISystem}"><code>RobustAndOptimalControl.hankelnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n, hsv = hankelnorm(sys::LTISystem; kwargs...)</code></pre><p>Compute the hankelnorm and the hankel singular values</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.ghanorm</code>, reproduced below</p><pre><code class="nohighlight hljs">ghanorm(sys, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (hanorm, hs)</code></pre><p>Compute for a proper and stable descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, the Hankel norm <code>hanorm =</code> <span>$\small ||G(\lambda)||_H$</span> and  the vector of Hankel singular values <code>hs</code> of the minimal realizatioj of the system.</p><p>For a non-minimal system, the uncontrollable and unobservable finite and infinite eigenvalues of the pair <code>(A,E)</code> and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/descriptor.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hanus-Tuple{Any}" href="#RobustAndOptimalControl.hanus-Tuple{Any}"><code>RobustAndOptimalControl.hanus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Wh = hanus(W)</code></pre><p>Return <code>Wh</code> on Hanus form. <code>Wh</code> has twice the number of inputs, where the second half of the inputs are &quot;actual inputs&quot;, e.g., potentially saturated. This is used to endow <code>W</code> with anti-windup protection. <code>W</code> must have an invertable <code>D</code> matrix and be minimum phase.</p><p>Ref: Sec 9.4.5 of Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/glover_mcfarlane.jl#L427-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hess_form-Tuple{Any}" href="#RobustAndOptimalControl.hess_form-Tuple{Any}"><code>RobustAndOptimalControl.hess_form</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysm, T, HF = hess_form(sys)</code></pre><p>Bring <code>sys</code> to Hessenberg form form.</p><p>The Hessenberg form is characterized by <code>A</code> having upper Hessenberg structure. <code>T</code> is the similarity transform applied to the system such that </p><pre><code class="language-julia hljs">sysm ≈ similarity_transform(sys, T)</code></pre><p><code>HF</code> is the Hessenberg-factorization of <code>A</code>.</p><p>See also <a href="#RobustAndOptimalControl.modal_form-Tuple{Any}"><code>modal_form</code></a> and <a href="#RobustAndOptimalControl.schur_form-Tuple{Any}"><code>schur_form</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/canonical.jl#L138-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.hinfassumptions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flag = hinfassumptions(P::ExtendedStateSpace; verbose=true)</code></pre><p>Check the assumptions for using the γ-iteration synthesis in Theorem 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hinfgrad-Tuple{Any, Any, Any}" href="#RobustAndOptimalControl.hinfgrad-Tuple{Any, Any, Any}"><code>RobustAndOptimalControl.hinfgrad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∇A, ∇B, ∇C, ∇D, hn, ω = hinfgrad(sys; rtolinf=1e-8, kwargs...)
∇A, ∇B, ∇C, ∇D        = hinfgrad(sys, hn, ω)</code></pre><p>Compute the gradient of the H∞ norm w.r.t. the statespace matrices <code>A,B,C,D</code>. If only a system is provided, the norm <code>hn</code> and the peak frequency <code>ω</code> are automatically calculated. <code>kwargs</code> are sent to <a href="#RobustAndOptimalControl.hinfnorm2-Tuple{LTISystem}"><code>hinfnorm2</code></a>. Note, the default tolerance to which the norm is calculated is set smaller than default for <a href="#RobustAndOptimalControl.hinfnorm2-Tuple{LTISystem}"><code>hinfnorm2</code></a>, gradients will be discontinuous with any non-finite tolerance, and sensitive optimization algorithms may require even tighter tolerance.</p><p>In cases where the maximum singular value is reached at more than one frequency, a random frequency is used.</p><p>If the system is unstable, the gradients are <code>NaN</code>. Strategies to find an initial stabilizing controllers are outlined in Apkarian and D. Noll, &quot;Nonsmooth H∞ Synthesis&quot; in IEEE Transactions on Automatic Control.</p><p>An <code>rrule</code> for ChainRules is defined using this function, so <code>hn</code> is differentiable with any AD package that derives its rules from ChainRules (only applies to the <code>hn</code> return value, not <code>ω</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L1194-L1207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hinfnorm2-Tuple{LTISystem}" href="#RobustAndOptimalControl.hinfnorm2-Tuple{LTISystem}"><code>RobustAndOptimalControl.hinfnorm2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n, ω = hinfnorm2(sys::LTISystem; kwargs...)</code></pre><p>A numerically robust version of <code>hinfnorm</code> using DescriptorSystems.jl</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.ghinfnorm</code>, reproduced below</p><pre><code class="nohighlight hljs">ghinfnorm(sys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (hinfnorm, fpeak)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function  matrix <code>G(λ)</code>  the <code>H∞</code> norm <code>hinfnorm</code> (i.e.,  the peak gain of <code>G(λ)</code>) and  the corresponding peak frequency <code>fpeak</code>, where the peak gain is achieved.  The <code>H∞</code> norm is infinite if <code>G(λ)</code> has unstable poles.  If the pencil <code>A-λE</code> has uncontrollable and/or unobservable unstable eigenvalues, then a reduced order realization is determined first (see below) to eliminate these eigenvalues. </p><p>To check the stability, the eigenvalues of the pencil <code>A-λE</code> must have real parts less than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset. The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy for the computed infinity norm.  The  default value used for <code>rtolinf</code> is <code>0.001</code>.</p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable finite and infinite eigenvalues of the pencil <code>A-λE</code>.  For a discrete-time system or for a system with invertible <code>E</code>, a reduced order realization is determined first, without  uncontrollable and unobservable finite eigenvalues of the pencil <code>A-λE</code>. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon   and <code>n</code> is the order of the system <code>sys</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/descriptor.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hinfpartition-NTuple{4, Any}" href="#RobustAndOptimalControl.hinfpartition-NTuple{4, Any}"><code>RobustAndOptimalControl.hinfpartition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">P = hinfpartition(G, WS, WU, WT)</code></pre><p>Transform a SISO or MIMO system <span>$G$</span>, with weighting functions <span>$W_S, W_U, W_T$</span> into an LFT with an isolated controller, and write the resulting system, <span>$P(s)$</span>, on a state-space form. Valid inputs for <span>$G$</span> are transfer functions (with dynamics, can be both MIMO and SISO, both in tf and ss forms). Valid inputs for the weighting functions are empty arrays, numbers (static gains), and <code>LTISystem</code>s.</p><p>Note, <code>system_mapping(P)</code> is equal to <code>-G</code>.</p><p><strong>Extended help</strong></p><p>For ill-conditioned MIMO plants, the <span>$S, CS, T$</span> weighting may result in controllers that &quot;invert&quot; the plant, which may result in poor robustness. For such systems, penalizing <span>$GS$</span> and <span>$T$</span> may be more appropriate. Ref: &quot;Inverting and noninverting H∞ controllers&quot;, Urs Christen, Hans Geering</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L627-L643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, LTISystem, LTISystem}" href="#RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, LTISystem, LTISystem}"><code>RobustAndOptimalControl.hinfsignals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hinfsignals(P::ExtendedStateSpace, G::LTISystem, C::LTISystem)</code></pre><p>Use the extended state-space model, a plant and the found controller to extract the closed loop transfer functions.</p><ul><li><code>Pcl : w → z</code> : From input to the weighted functions</li><li><code>S   : w → e</code> : From input to error</li><li><code>CS  : w → u</code> : From input to control</li><li><code>T   : w → y</code> : From input to output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L898-L908">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hinfsynthesize-Union{Tuple{ExtendedStateSpace{Continuous, T}}, Tuple{T}} where T" href="#RobustAndOptimalControl.hinfsynthesize-Union{Tuple{ExtendedStateSpace{Continuous, T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.hinfsynthesize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">K, γ, mats = hinfsynthesize(P::ExtendedStateSpace; gtol = 1e-4, interval = (0, 20), verbose = false, tolerance = 1.0e-10, γrel = 1.01, transform = true, ftype = Float64, check = true)</code></pre><p>Computes an H-infinity optimal controller <code>K</code> for an extended plant <code>P</code> such that <span>$||F_l(P, K)||∞ &lt; γ$</span>(<code>lft(P, K)</code>) for the smallest possible γ given <code>P</code>. The routine is known as the γ-iteration, and is based on the paper &quot;State-space formulae for all stabilizing controllers that satisfy an H∞-norm bound and relations to risk sensitivity&quot; by Glover and Doyle.</p><p><strong>Arguments:</strong></p><ul><li><code>gtol</code>: Tolerance for γ.</li><li><code>interval</code>: The starting interval for the bisection.</li><li><code>verbose</code>: Print progress?</li><li><code>tolerance</code>: For detecting eigenvalues on the imaginary axis.</li><li><code>γrel</code>: If <code>γrel &gt; 1</code>, the optimal γ will be found by γ iteration after which a controller will be designed for <code>γ = γopt * γrel</code>. It is often a good idea to design a slightly suboptimal controller, both for numerical reasons, but also since the optimal controller may contain very fast dynamics. If <code>γrel → ∞</code>, the computed controller will approach the 𝑯₂ optimal controller. Getting a mix between 𝑯∞ and 𝑯₂ properties is another reason to choose <code>γrel &gt; 1</code>.</li><li><code>transform</code>: Apply coordiante transform in order to tolerate a wider range or problem specifications.</li><li><code>ftype</code>: construct problem matrices in higher precision for increased numerical robustness. If the calculated controller achieves </li><li><code>check</code>: Perform a post-design check of the γ value achieved by the calculated controller. A warning is issued if the achieved γ differs from the γ calculated during design. If this warning is issued, consider using a higher-precision number type like <code>ftype = BigFloat</code>.</li></ul><p>See the example folder for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/hinfinity_design.jl#L112-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.hsvd-Tuple{AbstractStateSpace}" href="#RobustAndOptimalControl.hsvd-Tuple{AbstractStateSpace}"><code>RobustAndOptimalControl.hsvd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hsvd(sys::AbstractStateSpace)</code></pre><p>Return the Hankel singular values of <code>sys</code>, computed as the eigenvalues of <code>QP</code> Where <code>Q</code> and <code>P</code> are the Gramians of <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/reduction.jl#L189-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.ispassive-Tuple{Any}" href="#RobustAndOptimalControl.ispassive-Tuple{Any}"><code>RobustAndOptimalControl.ispassive</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ispassive(P; kwargs...)</code></pre><p>Determine if square system <code>P</code> is passive, i.e., <span>$P(s) + Pᴴ(s) &gt; 0$</span>.</p><p>A passive system has a Nyquist curve that lies completely in the right half plane, and satisfies the following inequality (dissipation of energy)</p><p class="math-container">\[\int_0^T y^T u dt &gt; 0 ∀ T\]</p><p>The negative feedback-interconnection of two passive systems is stable and  parallel connections of two passive systems as well as the inverse of a passive system are also passive. A passive controller will thus always yeild a stable feedback loop for a passive system. A series connection of two passive systems <em>is not</em> always passive.</p><p>See also <a href="#RobustAndOptimalControl.passivityplot"><code>passivityplot</code></a>, <a href="#RobustAndOptimalControl.passivity_index-Tuple{Any}"><code>passivity_index</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/diskmargin.jl#L463-L475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, LTISystem, Vararg{Any}}" href="#RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loop_diskmargin(P, C, args...; kwargs...)</code></pre><p>Calculate the loop-at-a-time diskmargin for each output and input of <code>P</code>. See also <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>, <a href="#RobustAndOptimalControl.sim_diskmargin"><code>sim_diskmargin</code></a>. Ref: <a href="https://arxiv.org/abs/2003.04771">&quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L340-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, Vararg{Any}}" href="#RobustAndOptimalControl.loop_diskmargin-Tuple{LTISystem, Vararg{Any}}"><code>RobustAndOptimalControl.loop_diskmargin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loop_diskmargin(L, args...; kwargs...)</code></pre><p>Calculate the loop-at-a-time diskmargin for each output of <code>L</code>.</p><p>See also <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>, <a href="#RobustAndOptimalControl.sim_diskmargin"><code>sim_diskmargin</code></a>. Ref: <a href="https://arxiv.org/abs/2003.04771">&quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L324-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.loop_scale" href="#RobustAndOptimalControl.loop_scale"><code>RobustAndOptimalControl.loop_scale</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loop_scale(L::LTISystem, w = 0)</code></pre><p>Find the optimal diagonal scaling matrix <code>D</code> such that <code>D\L(iw)*D</code> has a minimized condition number at frequency <code>w</code>. Applicable to square <code>L</code> only. Use <a href="#RobustAndOptimalControl.loop_scaling"><code>loop_scaling</code></a> to obtain <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L421-L426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.loop_scaling" href="#RobustAndOptimalControl.loop_scaling"><code>RobustAndOptimalControl.loop_scaling</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loop_scaling(M0::Matrix, tol = 0.0001)</code></pre><p>Find the optimal diagonal scaling matrix <code>D</code> such that <code>D\M0*D</code> has a minimized condition number. Applicable to square <code>M0</code> only. See also <a href="#RobustAndOptimalControl.structured_singular_value-Tuple{LTISystem, AbstractVector}"><code>structured_singular_value</code></a> with option <code>dynamic=true</code>. Use <a href="#RobustAndOptimalControl.loop_scale"><code>loop_scale</code></a> to find and apply the scaling to a loop-transfer function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L377-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.lqr3-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, AbstractMatrix, AbstractMatrix}" href="#RobustAndOptimalControl.lqr3-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, AbstractMatrix, AbstractMatrix}"><code>RobustAndOptimalControl.lqr3</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lqr3(P::AbstractStateSpace, Q1::AbstractMatrix, Q2::AbstractMatrix, Q3::AbstractMatrix)</code></pre><p>Calculate the feedback gain of the discrete LQR cost function augmented with control differences</p><p class="math-container">\[x^{T} Q_1 x + u^{T} Q_2 u + Δu^{T} Q_3 Δu, \quad
Δu = u(k) - u(k-1)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L187-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.makeweight-Tuple{Any, Number, Any}" href="#RobustAndOptimalControl.makeweight-Tuple{Any, Number, Any}"><code>RobustAndOptimalControl.makeweight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeweight(low, f_mid, high)
makeweight(low, (f_mid, gain_mid), high)</code></pre><p>Create a weighting function that goes from gain <code>low</code> at zero frequency, through gain <code>gain_mid</code> to gain <code>high</code> at ∞</p><p><strong>Arguments:</strong></p><ul><li><code>low</code>: A number specifying the DC gain </li><li><code>mid</code>: A number specifying the frequency at which the gain is 1, or a tuple <code>(freq, gain)</code>. If <code>gain_mid</code> is not specified, the geometric mean of <code>high</code> and <code>low</code> is used.</li><li><code>high</code>: A number specifying the gain at ∞</li></ul><pre><code class="language- hljs">using ControlSystemsBase, Plots
W = makeweight(10, (5,2), 1/10)
bodeplot(W)
hline!([10, 2, 1/10], l=(:black, :dash), primary=false)
vline!([5], l=(:black, :dash), primary=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/weights.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}" href="#RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}"><code>RobustAndOptimalControl.measure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure(s::NamedStateSpace, names)</code></pre><p>Return a system with specified states as measurement outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/named_systems2.jl#L324-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.modal_form-Tuple{Any}" href="#RobustAndOptimalControl.modal_form-Tuple{Any}"><code>RobustAndOptimalControl.modal_form</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysm, T, E = modal_form(sys; C1 = false)</code></pre><p>Bring <code>sys</code> to modal form.</p><p>The modal form is characterized by being tridiagonal with the real values of eigenvalues of <code>A</code> on the main diagonal and the complex parts on the first sub and super diagonals. <code>T</code> is the similarity transform applied to the system such that </p><pre><code class="language-julia hljs">sysm ≈ similarity_transform(sys, T)</code></pre><p>If <code>C1</code>, then an additional convention for SISO systems is used, that the <code>C</code>-matrix coefficient of real eigenvalues is 1. If <code>C1 = false</code>, the <code>B</code> and <code>C</code> coefficients are chosen in a balanced fashion.</p><p><code>E</code> is an eigen factorization of <code>A</code>.</p><p>See also <a href="#RobustAndOptimalControl.hess_form-Tuple{Any}"><code>hess_form</code></a> and <a href="#RobustAndOptimalControl.schur_form-Tuple{Any}"><code>schur_form</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/canonical.jl#L65-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.muplot" href="#RobustAndOptimalControl.muplot"><code>RobustAndOptimalControl.muplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">muplot(sys, args...; hz=false)
muplot(LTISystem[sys1, sys2...], args...; hz=false)</code></pre><p>Plot the structured singular values (assuming time-varying diagonal complex uncertainty) of the frequency response of the <code>LTISystem</code>(s). This plot is similar to <code>sigmaplot</code>, but scales the loop-transfer function to minimize the maximum singular value. Only applicable to square systems. A frequency vector <code>w</code> can be optionally provided.</p><p>If <code>hz=true</code>, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.</p><p><code>kwargs</code> is sent as argument to Plots.plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/plotting.jl#L212-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.mvnyquistplot" href="#RobustAndOptimalControl.mvnyquistplot"><code>RobustAndOptimalControl.mvnyquistplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fig = mvnyquistplot(sys, w;  unit_circle=true, hz = false, kwargs...)</code></pre><p>Create a Nyquist plot of the <code>LTISystem</code>. A frequency vector <code>w</code> must be provided.</p><ul><li><code>unit_circle</code>: if the unit circle should be displayed</li></ul><p>If <code>hz=true</code>, the hover information will be displayed in Hertz, the input frequency vector is still treated as rad/s.</p><p><code>kwargs</code> is sent as argument to plot.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">w = 2π .* exp10.(LinRange(-2, 2, 500))
W = makeweight(0.40, 15, 3) # frequency weight for uncertain dynamics
Pn = tf(1, [1/60, 1]) |&gt; ss # nominal plant
d = δss(1,1)                # Uncertain dynamics

Pd = Pn*(I(1) + W*d)        # weighted dynamic uncertainty on the input of Pn
Pp = rand(Pd, 200)          # sample the uncertain plant
Gcl = lft(Pd, ss(-1))       # closed loop system
structured_singular_value(Gcl) # larger than 1 =&gt; not robustly stable
unsafe_comparisons(true)
mvnyquistplot(Pp, w, points=true) # MV Nyquist plot encircles origin for some samples =&gt; not robustly stable</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/plotting.jl#L126-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.named_ss-Tuple{AbstractStateSpace, Any}" href="#RobustAndOptimalControl.named_ss-Tuple{AbstractStateSpace, Any}"><code>RobustAndOptimalControl.named_ss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">named_ss(sys::AbstractStateSpace, name; x, y, u)</code></pre><p>If a single name of the system is provided, the outputs, inputs and states will be automatically named <code>y,u,x</code> with <code>name</code> as prefix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/named_systems2.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.named_ss-Union{Tuple{AbstractStateSpace{T}}, Tuple{T}} where T" href="#RobustAndOptimalControl.named_ss-Union{Tuple{AbstractStateSpace{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.named_ss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">named_ss(sys::AbstractStateSpace{T}; x, u, y)</code></pre><p>Create a <code>NamedStateSpace</code> system. This kind of system uses names rather than integer indices to refer to states, inputs and outputs.</p><ul><li>If a single name is provided but a vector of names is expected, this name will be used as prefix followed by a numerical index.</li><li>If no name is provided, default names (<code>x,y,u</code>) will be used.</li></ul><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: A system to add names to.</li><li><code>x</code>: A list of symbols with names of the states.</li><li><code>u</code>: A list of symbols with names of the inputs.</li><li><code>y</code>: A list of symbols with names of the outputs.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">G1 = ss(1,1,1,0)
G2 = ss(1,1,1,0)
s1 = named_ss(G1, x = :x, u = :u1, y=:y1)
s2 = named_ss(G2, x = :z, u = :u2, y=:y2)

s1[:y1, :u1] # Index using symbols. Uses prefix matching if no exact match is found.

fb = feedback(s1, s2, r = :r) # </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/named_systems2.jl#L121-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.named_ss-Union{Tuple{ExtendedStateSpace{T}}, Tuple{T}, Tuple{ExtendedStateSpace{T}, Any}} where T" href="#RobustAndOptimalControl.named_ss-Union{Tuple{ExtendedStateSpace{T}}, Tuple{T}, Tuple{ExtendedStateSpace{T}, Any}} where T"><code>RobustAndOptimalControl.named_ss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">named_ss(sys::ExtendedStateSpace;       kwargs...)
named_ss(sys::ExtendedStateSpace, name; kwargs...)</code></pre><p>Assign names to an ExtendedStateSpace. If no specific names are provided for signals <code>z,y,w,u</code> and states<code>x</code>, names will be generated automatically.</p><p><strong>Arguments:</strong></p><ul><li><code>name</code>: Prefix to add to all automatically generated names.</li><li><code>x</code></li><li><code>u</code></li><li><code>y</code></li><li><code>w</code></li><li><code>z</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/named_systems2.jl#L655-L669">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}" href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>RobustAndOptimalControl.ncfmargin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">m, ω = ncfmargin(P, K)</code></pre><p>Normalized coprime factor margin, defined has the <em>inverse</em> of</p><p class="math-container">\[\begin{Vmatrix}
\begin{bmatrix}
I \\ K
\end{bmatrix} (I + PK)^{-1} \begin{bmatrix}
I &amp; P
\end{bmatrix}
\end{Vmatrix}_\infty\]</p><p>A margin ≥ 0.25-0.3 is a reasonable for robustness. </p><p>If controller <code>K</code> stabilizes <code>P</code> with margin <code>m</code>, then <code>K</code> will also stabilize <code>P̃</code> if <code>nugap(P, P̃) &lt; m</code>.</p><p>See also <a href="@ref"><code>extended_gangoffour</code></a>, <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>, <a href="#RobustAndOptimalControl.controller_reduction_plot"><code>controller_reduction_plot</code></a>.</p><p><strong>Extended help</strong></p><ul><li>Robustness with respect to coprime factor uncertainty does not necessarily imply robustness with respect to input uncertainty. Skogestad p. 96 remark 4</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/glover_mcfarlane.jl#L447-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.neglected_delay-Tuple{Any}" href="#RobustAndOptimalControl.neglected_delay-Tuple{Any}"><code>RobustAndOptimalControl.neglected_delay</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neglected_delay(Lmax)</code></pre><p>Return a multiplicative weight to represent the uncertainty coming from neglecting the dynamics <code>exp(-s*L)</code> where <code>L ≤ Lmax</code>. &quot;Multivariable Feedback Control: Analysis and Design&quot; Ch 7.4.5</p><p>See also <a href="#RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}"><code>gain_and_delay_uncertainty</code></a> and <a href="#RobustAndOptimalControl.neglected_lag-Tuple{Any}"><code>neglected_lag</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">a = 10
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0) # Plant
W0 = neglected_delay(0.005) |&gt; ss # Weight
W = I(2) + W0*I(2) * uss([δc(), δc()]) # Create a diagonal real uncertainty weighted in frequency by W0
Ps = P*W # Uncertain plant
Psamples = rand(Ps, 500) # Sample the uncertain plant for plotting
w = exp10.(LinRange(-1, 3, 300)) # Frequency vector
bodeplot(Psamples, w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/weights.jl#L34-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.neglected_lag-Tuple{Any}" href="#RobustAndOptimalControl.neglected_lag-Tuple{Any}"><code>RobustAndOptimalControl.neglected_lag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neglected_lag(τmax)</code></pre><p>Return a multiplicative weight to represent the uncertainty coming from neglecting the dynamics <code>1/(s*τ + 1)</code> where <code>τ ≤ τmax</code>. &quot;Multivariable Feedback Control: Analysis and Design&quot; Ch 7.4.5</p><p>See also <a href="#RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}"><code>gain_and_delay_uncertainty</code></a> and <a href="#RobustAndOptimalControl.neglected_delay-Tuple{Any}"><code>neglected_delay</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">a = 10
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0) # Plant
W0 = neglected_lag(0.05) |&gt; ss # Weight
W = I(2) + W0*I(2) * uss([δc(), δc()]) # Create a diagonal real uncertainty weighted in frequency by W0
Ps = P*W # Uncertain plant
Psamples = rand(Ps, 100) # Sample the uncertain plant for plotting
w = exp10.(LinRange(-1, 3, 300)) # Frequency vector
sigmaplot(Psamples, w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/weights.jl#L86-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.noise_mapping" href="#RobustAndOptimalControl.noise_mapping"><code>RobustAndOptimalControl.noise_mapping</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">noise_mapping(P::ExtendedStateSpace)</code></pre><p>Return the system from w -&gt; y See also <a href="#RobustAndOptimalControl.performance_mapping"><code>performance_mapping</code></a>, <a href="#RobustAndOptimalControl.system_mapping"><code>system_mapping</code></a>, <a href="#RobustAndOptimalControl.noise_mapping"><code>noise_mapping</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/ExtendedStateSpace.jl#L705-L710">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.nu_reduction" href="#RobustAndOptimalControl.nu_reduction"><code>RobustAndOptimalControl.nu_reduction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nu_reduction(G, g=0.1; gap = nugap(G))</code></pre><p>Reduce the number of particles in an uncertain system <code>G</code> by removing all particles that are within the νgap <code>g</code> of the nominal system <code>Gₙ</code>.</p><p>Note: If <code>G</code> has a stochastic interpretation, i.e., the coefficients come from some distribution, this interpretation will be lost after reduction, mean values and standard deviations will not be preserved. The reduced system should instead be interpreted as preserving worst-case uncertainty.</p><p>If the <code>gap = nugap(G)</code> has already been precomputed, it can be supplied as an argument to avoid potentially costly recomputaiton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mcm_nugap.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.nu_reduction_recursive" href="#RobustAndOptimalControl.nu_reduction_recursive"><code>RobustAndOptimalControl.nu_reduction_recursive</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nu_reduction_recursive(G, g = 0.1; gap = nugap(G), keepinds = Set{Int}(1), verbose = false)</code></pre><p>Find a νgap cover of balls of radius <code>g</code> (in the νgap metric) that contain all realizations in <code>G</code>. </p><p>If the <code>gap = nugap(G)</code> has already been precomputed, it can be supplied as an argument to avoid potentially costly recomputaiton. If a manually computed <code>gap</code> is supplied, you must also supply <code>keepinds=Set{Int}(index)</code> where <code>index</code> is the index of the nominal system in <code>G</code> used to compute <code>gap</code>.</p><p>The returned cover <code>Gr</code> is of the same type as <code>G</code>, but with a smaller number of particles. A controller designed for <code>Gr</code> that achieves a <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a> of at least <code>g</code> for all realizations in <code>Gr</code> will stabilize all realizations in the original <code>G</code>. The extreme case cover where <code>Gr = Gnominal</code> is a single realization only can be computed by calling <code>g = nugap(G, i)</code> where <code>i</code> is the index of the nominal system in <code>G</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>G</code>: An uncertain model in the form of a <code>StateSpace{TE, Particles}</code> (a multi-model).</li><li><code>g</code>: The radius of the balls in the νgap cover.</li><li><code>gap</code>: An optional precomputed gap</li><li><code>verbose</code>: Print progress</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mcm_nugap.jl#L46-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.nugap" href="#RobustAndOptimalControl.nugap"><code>RobustAndOptimalControl.nugap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nugap(G; map = map)</code></pre><p>Compute the νgap between the nominal system <code>Gₙ</code> represented by the first particle index in <code>G</code>, and all other systems in <code>G</code>. Returns a <code>Particles</code> object with the νgap for each system in <code>G</code>.</p><p>See <code>with_nominal</code> to endow uncertain values with a nominal value, and <code>nominal</code> to extract the nominal value.</p><p>The value returned by this function, <code>νᵧ</code> is useful for robust synthesis, by designing a controller for the nominal system <code>Gₙ</code>, that achieves an <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a> of at least <code>νᵧ</code> is guaranteed to stabilize all realizations within <code>G</code>. </p><p>To speed up computation for large systems, a threaded or distributed <code>map</code> function can be supplied, e.g., <code>ThreadTools.tmap</code> or <code>Distributed.pmap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mcm_nugap.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.nugap-Tuple{LTISystem, LTISystem}" href="#RobustAndOptimalControl.nugap-Tuple{LTISystem, LTISystem}"><code>RobustAndOptimalControl.nugap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nugap(sys0::LTISystem, sys1::LTISystem; kwargs...)</code></pre><p>Compute the ν-gap metric between two systems. See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p><p>For keyword arguments, see the docstring of <code>DescriptorSystems.gnugap</code>, reproduced below</p><pre><code class="nohighlight hljs">gnugap(sys1, sys2; freq = ω, rtolinf = 0.00001, fast = true, offset = sqrt(ϵ), 
       atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (nugapdist, fpeak)</code></pre><p>Compute the ν-gap distance <code>nugapdist</code> between two descriptor systems <code>sys1 = (A1-λE1,B1,C1,D1)</code> and  <code>sys2 = (A2-λE2,B2,C2,D2)</code> and the corresponding frequency <code>fpeak</code> (in rad/TimeUnit), where the ν-gap  distance achieves its peak value. </p><p>If <code>freq = missing</code>, the resulting <code>nugapdist</code> satisfies <code>0 &lt;= nugapdist &lt;= 1</code>.  The value <code>nugapdist = 1</code> results, if the winding number is different of zero in which case <code>fpeak = []</code>. </p><p>If <code>freq = ω</code>, where <code>ω</code> is a given vector of real frequency values, the resulting <code>nugapdist</code> is a vector  of pointwise ν-gap distances of the dimension of <code>ω</code>, whose components satisfies <code>0 &lt;= maximum(nugapdist) &lt;= 1</code>.  In this case, <code>fpeak</code> is the frequency for which the pointwise distance achieves its peak value.  All components of <code>nugapdist</code> are set to 1 if the winding number is different of zero in which case <code>fpeak = []</code>.</p><p>The stability boundary offset, <code>β</code>, to be used to assess the finite zeros which belong to the boundary of the stability domain can be specified via the keyword parameter <code>offset = β</code>. Accordingly, for a continuous-time system, these are the finite zeros having  real parts within the interval <code>[-β,β]</code>, while for a discrete-time system,  these are the finite zeros having moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>Pencil reduction algorithms are employed to compute range and coimage spaces  which perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code> and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A1</code>, <code>A2</code>, <code>B1</code>, <code>B2</code>, <code>C1</code>, <code>C2</code>, <code>D1</code> and <code>D2</code>, the absolute tolerance for the nonzero elements of <code>E1</code> and <code>E2</code>,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximum of the orders of the systems <code>sys1</code> and <code>sys2</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy to be used  to compute the ν-gap as the infinity norm of the relevant system according to [1].  The default value used for <code>rtolinf</code> is <code>0.00001</code>.</p><p><em>Method:</em> The evaluation of ν-gap uses the definition proposed in [1], extended to generalized LTI (descriptor) systems. The computation of winding number is based on enhancements covering zeros on the boundary of the  stability domain and infinite zeros.</p><p><em>References:</em></p><p>[1] G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/descriptor.jl#L64-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.partition-Tuple{AbstractStateSpace, Int64, Int64}" href="#RobustAndOptimalControl.partition-Tuple{AbstractStateSpace, Int64, Int64}"><code>RobustAndOptimalControl.partition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partition(P::AbstractStateSpace, nw::Int, nz::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/ExtendedStateSpace.jl#L679-L681">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.partition-Tuple{AbstractStateSpace}" href="#RobustAndOptimalControl.partition-Tuple{AbstractStateSpace}"><code>RobustAndOptimalControl.partition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partition(P::AbstractStateSpace; u, y, w=!u, z=!y)</code></pre><p>Partition <code>P</code> into an <a href="#RobustAndOptimalControl.ExtendedStateSpace"><code>ExtendedStateSpace</code></a>.</p><ul><li><code>u</code> indicates the indices of the controllable inputs.</li><li><code>y</code> indicates the indices of the measurable outputs.</li><li><code>w</code> indicates the indices of the disturbance inputs (uncontrollable), by default <code>w</code> is the complement of <code>u</code>.</li><li><code>z</code> indicates the indices of the performance outputs (not neccesarily measurable), by default <code>z</code> is the complement of <code>y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/ExtendedStateSpace.jl#L646-L654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.passivity_index-Tuple{Any}" href="#RobustAndOptimalControl.passivity_index-Tuple{Any}"><code>RobustAndOptimalControl.passivity_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">passivity_index(P; kwargs...)</code></pre><p>Return</p><p class="math-container">\[γ = \begin{Vmatrix}
(I-P)(I+P)^{-1}
\end{Vmatrix}_∞\]</p><p>If <span>$γ ≤ 1$</span>, the system is passive. If the system has unstable zeros, <span>$γ = ∞$</span></p><p>The negative feedback interconnection of two systems with passivity indices γ₁ and γ₂ is stable if <span>$γ₁γ₂ &lt; 1$</span>.</p><p>A passive system has a Nyquist curve that lies completely in the right half plane, and satisfies the following inequality (dissipation of energy)</p><p class="math-container">\[\int_0^T y^T u dt &gt; 0 ∀ T\]</p><p>The negative feedback-interconnection of two passive systems is stable and  parallel connections of two passive systems as well as the inverse of a passive system are also passive. A passive controller will thus always yeild a stable feedback loop for a passive system. A series connection of two passive systems <em>is not</em> always passive.</p><p>See also <a href="#RobustAndOptimalControl.ispassive-Tuple{Any}"><code>ispassive</code></a>, <a href="#RobustAndOptimalControl.passivityplot"><code>passivityplot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/diskmargin.jl#L436-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.passivityplot" href="#RobustAndOptimalControl.passivityplot"><code>RobustAndOptimalControl.passivityplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">passivityplot(sys, args...; hz=false)
passivityplot(LTISystem[sys1, sys2...], args...; hz=false)</code></pre><p>Plot the passivity index of a <code>LTISystem</code>(s). The system is passive for frequencies where the index is &lt; 0.</p><p>A frequency vector <code>w</code> can be optionally provided.</p><p>If <code>hz=true</code>, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.</p><p><code>kwargs</code> is sent as argument to Plots.plot.</p><p>See <a href="#RobustAndOptimalControl.passivity_index-Tuple{Any}"><code>passivity_index</code></a> for additional details. See also <a href="#RobustAndOptimalControl.ispassive-Tuple{Any}"><code>ispassive</code></a>, <a href="#RobustAndOptimalControl.passivity_index-Tuple{Any}"><code>passivity_index</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/diskmargin.jl#L479-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.performance_mapping" href="#RobustAndOptimalControl.performance_mapping"><code>RobustAndOptimalControl.performance_mapping</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">performance_mapping(P::ExtendedStateSpace)</code></pre><p>Return the system from w -&gt; z See also <a href="#RobustAndOptimalControl.performance_mapping"><code>performance_mapping</code></a>, <a href="#RobustAndOptimalControl.system_mapping"><code>system_mapping</code></a>, <a href="#RobustAndOptimalControl.noise_mapping"><code>noise_mapping</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/ExtendedStateSpace.jl#L695-L700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}" href="#RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}"><code>RobustAndOptimalControl.robstab</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">robstab(M0::UncertainSS, w=exp10.(LinRange(-3, 3, 1500)); kwargs...)</code></pre><p>Return the robust stability margin of an uncertain model, defined as the inverse of the structured singular value. Currently, only diagonal complex perturbations supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L222-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.schur_form-Tuple{Any}" href="#RobustAndOptimalControl.schur_form-Tuple{Any}"><code>RobustAndOptimalControl.schur_form</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysm, T, SF = schur_form(sys)</code></pre><p>Bring <code>sys</code> to Schur form.</p><p>The Schur form is characterized by <code>A</code> being Schur with the real values of eigenvalues of <code>A</code> on the main diagonal. <code>T</code> is the similarity transform applied to the system such that </p><pre><code class="language-julia hljs">sysm ≈ similarity_transform(sys, T)</code></pre><p><code>SF</code> is the Schur-factorization of <code>A</code>.</p><p>See also <a href="#RobustAndOptimalControl.modal_form-Tuple{Any}"><code>modal_form</code></a> and <a href="#RobustAndOptimalControl.hess_form-Tuple{Any}"><code>hess_form</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/canonical.jl#L117-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.show_construction-Tuple{IO, LTISystem}" href="#RobustAndOptimalControl.show_construction-Tuple{IO, LTISystem}"><code>RobustAndOptimalControl.show_construction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">show_construction([io::IO,] sys::LTISystem; name = &quot;temp&quot;, letb = true)</code></pre><p>Print code to <code>io</code> that reconstructs <code>sys</code>.</p><ul><li><code>letb</code>: If true, the code is surrounded by a let block.</li></ul><pre><code class="language- hljs">julia&gt; sys = ss(tf(1, [1, 1]))
StateSpace{Continuous, Float64}
A = 
 -1.0
B = 
 1.0
C = 
 1.0
D = 
 0.0

Continuous-time state-space model

julia&gt; show_construction(sys, name=&quot;Jörgen&quot;)
Jörgen = let
    JörgenA = [-1.0;;]
    JörgenB = [1.0;;]
    JörgenC = [1.0;;]
    JörgenD = [0.0;;]
    ss(JörgenA, JörgenB, JörgenC, JörgenD)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/utils.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.sim_diskmargin" href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_diskmargin(P::LTISystem, C::LTISystem, σ::Real = 0)</code></pre><p>Simultaneuous diskmargin at both outputs and inputs of <code>P</code>. Ref: &quot;An Introduction to Disk Margins&quot;, Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771 See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L272-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.sim_diskmargin" href="#RobustAndOptimalControl.sim_diskmargin"><code>RobustAndOptimalControl.sim_diskmargin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_diskmargin(L, σ::Real = 0, l=1e-3, u=1e3)</code></pre><p>Return the smallest simultaneous diskmargin over the grid l:u See also <a href="#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L285-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.sim_diskmargin-Tuple{LTISystem, Real, AbstractVector}" href="#RobustAndOptimalControl.sim_diskmargin-Tuple{LTISystem, Real, AbstractVector}"><code>RobustAndOptimalControl.sim_diskmargin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_diskmargin(L, σ::Real, w::AbstractVector)
sim_diskmargin(L, σ::Real = 0)</code></pre><p>Simultaneuous diskmargin at the outputs of <code>L</code>.  Users should consider using <a href="#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L255-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.specificationplot" href="#RobustAndOptimalControl.specificationplot"><code>RobustAndOptimalControl.specificationplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">specificationplot([S,CS,T], [WS,WU,WT])</code></pre><p>This function visualizes the control synthesis using the <a href="#RobustAndOptimalControl.hinfsynthesize-Union{Tuple{ExtendedStateSpace{Continuous, T}}, Tuple{T}} where T"><code>hinfsynthesize</code></a> with the three weighting functions <span>$W_S(s), W_U(s), W_T(s)$</span> inverted and scaled by γ, against the corresponding transfer functions <span>$S(s), C(s)S(s), T(s)$</span>, to verify visually that the specifications are met. This may be run using both MIMO and SISO systems.</p><p><strong>Keyword args</strong></p><ul><li><code>wint</code>: <code>(-3, 5)</code> frequency range (log10)</li><li><code>wnum</code>: 201 number of frequency points</li><li><code>hz</code>: true</li><li><code>nsigma</code>: typemax(Int) number of singular values to show</li><li><code>s_labels</code>: `[   &quot;σ(S)&quot;,   &quot;σ(CS)&quot;,   &quot;σ(T)&quot;,</li></ul><p>]`</p><ul><li><code>w_labels</code>: `[   &quot;γ σ(Wₛ⁻¹)&quot;,   &quot;γ σ(Wᵤ⁻¹)&quot;,   &quot;γ σ(Wₜ⁻¹)&quot;,</li></ul><p>]`</p><ul><li><code>colors</code>: <code>[:blue, :red, :green]</code> colors for <span>$S$</span>, <span>$CS$</span> and <span>$T$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/plotting.jl#L4-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.splitter" href="#RobustAndOptimalControl.splitter"><code>RobustAndOptimalControl.splitter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">splitter(u::Symbol, n::Int, timeevol = Continuous())</code></pre><p>Return a named system that splits an input signal into <code>n</code> signals. This is useful when an external signal entering a block diagram is to be connected to multiple inputs. See the tutorial  https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/hinf_connection/ for example usage. An alternative way of connecting an external input to several input ports with the same name is to pass <code>connect(..., unique=false)</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>u</code>: Named of the signal to split</li><li><code>n</code>: Number of splits</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/named_systems2.jl#L504-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.ss2particles-Tuple{Vector{&lt;:AbstractStateSpace}}" href="#RobustAndOptimalControl.ss2particles-Tuple{Vector{&lt;:AbstractStateSpace}}"><code>RobustAndOptimalControl.ss2particles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ss2particles(G::Vector{&lt;:AbstractStateSpace})</code></pre><p>Converts a vector of state space models to a single state space model with coefficient type <code>MonteCarloMeasurements.Particles</code>.</p><p>See also <a href="#RobustAndOptimalControl.sys_from_particles-Tuple{Any, Any}"><code>sys_from_particles</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L533-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.ssdata_e-Tuple{ExtendedStateSpace}" href="#RobustAndOptimalControl.ssdata_e-Tuple{ExtendedStateSpace}"><code>RobustAndOptimalControl.ssdata_e</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">A, B1, B2, C1, C2, D11, D12, D21, D22 = ssdata_e(sys)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/ExtendedStateSpace.jl#L234-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.stab_unstab-Tuple{Any}" href="#RobustAndOptimalControl.stab_unstab-Tuple{Any}"><code>RobustAndOptimalControl.stab_unstab</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stab, unstab = stab_unstab(sys; kwargs...)</code></pre><p>Decompose <code>sys</code> into <code>sys = stab + unstab</code> where <code>stab</code> contains all stable poles and <code>unstab</code> contains unstable poles. See <code>gsdec(sys; job = &quot;finite&quot;, prescale, smarg, fast = true,         atol = 0,  atol1 = atol, atol2 = atol, rtol = nϵ) -&gt; (sys1, sys2)</code></p><p>Compute for the descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, the additive spectral decomposition <code>G(λ) = G1(λ) + G2(λ)</code> such that <code>G1(λ)</code>,  the transfer function matrix of the descriptor system <code>sys1 = (A1-λE1,B1,C1,D1)</code>,  has only poles in a certain domain of interest <code>Cg</code> of the complex plane and <code>G2(λ)</code>,  the transfer function matrix of the descriptor system <code>sys2 = (A2-λE2,B2,C2,0)</code>, has only poles outside of <code>Cg</code>. </p><p>If <code>prescale = true</code>, a preliminary balancing of the descriptor system pair <code>(A,E)</code> is performed. The default setting is <code>prescale = MatrixPencils.balqual(sys.A,sys.E) &gt; 10000</code>,  where the function <code>pbalqual</code> from the <a href="https://github.com/andreasvarga/MatrixPencils.jl">MatrixPencils</a>  package evaluates the scaling quality of the linear pencil <code>A-λE</code>. </p><p>The keyword argument <code>smarg</code>, if provided, specifies the stability margin for the stable eigenvalues of <code>A-λE</code>, such that, in the continuous-time case,  the stable eigenvalues have real parts less than or equal to <code>smarg</code>, and in the discrete-time case, the stable eigenvalues have moduli less than or equal to <code>smarg</code>. If <code>smarg = missing</code>, the used default values  are: <code>smarg = -sqrt(ϵ)</code>, for a continuous-time system, and <code>smarg = 1-sqrt(ϵ)</code>,  for a discrete-time system), where <code>ϵ</code> is the machine precision of the working accuracy. </p><p>The keyword argument <code>job</code>, in conjunction with <code>smarg</code>, defines the domain of  interest <code>Cg</code>, as follows:</p><p>for <code>job = &quot;finite&quot;</code>, <code>Cg</code> is the whole complex plane without the point at infinity, and     <code>sys1</code> has only finite poles and <code>sys2</code> has only infinite poles (default);     the resulting <code>A2</code> is nonsingular and upper triangular, while the    resulting <code>E2</code> is nilpotent and upper triangular;   </p><p>for <code>job = &quot;infinite&quot;</code>, <code>Cg</code> is the point at infinity, and     <code>sys1</code> has only infinite poles and <code>sys2</code> has only finite poles and     is the strictly proper part of <code>sys</code>;     the resulting <code>A1</code> is nonsingular and upper triangular, while the    resulting <code>E1</code> is nilpotent and upper triangular;   </p><p>for <code>job = &quot;stable&quot;</code>, <code>Cg</code> is the stability domain of eigenvalues defined by <code>smarg</code>, and       <code>sys1</code> has only stable poles and <code>sys2</code> has only unstable and infinite poles;         the resulting pairs <code>(A1,E1)</code> and <code>(A2,E2)</code> are in generalized Schur form with     <code>E1</code> upper triangular and nonsingular and <code>E2</code> upper triangular;   </p><p>for <code>job = &quot;unstable&quot;</code>, <code>Cg</code> is the complement of the stability domain of the      eigenvalues defined by <code>smarg</code>, and       <code>sys1</code> has only unstable and infinite poles and <code>sys2</code> has only stable poles;         the resulting pairs <code>(A1,E1)</code> and <code>(A2,E2)</code> are in generalized Schur form with     <code>E1</code> upper triangular and <code>E2</code> upper triangular  and nonsingular.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The separation of the finite and infinite eigenvalues is performed using  rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.  for keyword arguments (argument <code>job</code> is set to <code>&quot;stable&quot;</code> in this function).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/descriptor.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.static_gain_compensation" href="#RobustAndOptimalControl.static_gain_compensation"><code>RobustAndOptimalControl.static_gain_compensation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">static_gain_compensation(l::LQGProblem, L = lqr(l))
static_gain_compensation(A, B, C, D, L)</code></pre><p>Find <span>$L_r$</span> such that</p><pre><code class="nohighlight hljs">dcgain(closedloop(G)*Lr) ≈ I</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/lqg.jl#L230-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.structured_singular_value-Tuple{LTISystem, AbstractVector}" href="#RobustAndOptimalControl.structured_singular_value-Tuple{LTISystem, AbstractVector}"><code>RobustAndOptimalControl.structured_singular_value</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">structured_singular_value(M0::UncertainSS, [w::AbstractVector]; kwargs...)</code></pre><ul><li><code>w</code>: Frequency vector, if none is provided, the maximum μ over a grid 1e-3 : 1e3 will be returned.</li></ul><p><a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/uncertainty/#Robust-stability-and-performance">An example is provided in the documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L230-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T" href="#RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>RobustAndOptimalControl.structured_singular_value</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">μ = structured_singular_value(M; tol=1e-4, scalings=false, dynamic=false)</code></pre><p>Compute (an upper bound of) the structured singular value μ for diagonal Δ of complex perturbations (other structures of Δ are not yet supported). <code>M</code> is assumed to be an (n × n × N_freq) array or a matrix.</p><p>We currently don&#39;t have any methods to compute a lower bound, but if all perturbations are complex the spectral radius <code>ρ(M)</code> is always a lower bound (usually not a good one).</p><p>If <code>scalings = true</code>, return also a <code>n × nf</code> matrix <code>Dm</code> with the diagonal scalings <code>D</code> such that</p><pre><code class="nohighlight hljs">D = Diagonal(Dm[:, i])
σ̄(D\M[:,:,i]*D)</code></pre><p>is minimized.</p><p>If <code>dynamic = true</code>, the perturbations are assumed to be time-varying <code>Δ(t)</code>. In this case, the same scaling is used for all frequencies and the returned <code>D</code> if <code>scalings=true</code> is a vector <code>d</code> such that <code>D = Diagonal(d)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/mimo_diskmargin.jl#L144-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.sumblock-Tuple{String}" href="#RobustAndOptimalControl.sumblock-Tuple{String}"><code>RobustAndOptimalControl.sumblock</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sumblock(ex::String; Ts = 0, n = 1)</code></pre><p>Create a summation node (named statespace system) that sums (or subtracts) vectors of length <code>n</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>Ts</code>: Sample time</li><li><code>n</code>: The length of the input and output vectors. Set <code>n=1</code> for scalars.</li></ul><p>When using <code>sumblock</code> to form block diagrams, note how the system returned from <code>sumblock</code> has input names corresponding to the right-hand side of the expression and output names corresponding to the variable on the left-hand side. You will thus typically list connections like <code>:y =&gt; :y</code> in the connection list to the <a href="#RobustAndOptimalControl.connect-Tuple{Any, AbstractVector{&lt;:Pair}}"><code>connect</code></a> function. See the tutorials</p><ul><li>https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/hinf_connection/</li><li>https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/api/#RobustAndOptimalControl.connect-Tuple{Any}</li></ul><p>for example usage</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; sumblock(&quot;uP = vf + yL&quot;)
NamedStateSpace{Continuous, Int64}
D = 
 1  1

With state  names: 
     input  names: vf yL
     output names: uP


julia&gt; sumblock(&quot;x_diff = xr - xh&quot;; n=3)
NamedStateSpace{Continuous, Int64}
D = 
 1  0  0  -1   0   0
 0  1  0   0  -1   0
 0  0  1   0   0  -1

With state  names: 
     input  names: xr1 xr2 xr3 xh1 xh2 xh3
     output names: x_diff1 x_diff2 x_diff3
     

julia&gt; sumblock(&quot;a = b + c - d&quot;)
NamedStateSpace{Continuous, Int64}
D = 
 1  1  -1

With state  names: 
     input  names: b c d
     output names: a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/named_systems2.jl#L529-L577">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.sys_from_particles-Tuple{Any, Any}" href="#RobustAndOptimalControl.sys_from_particles-Tuple{Any, Any}"><code>RobustAndOptimalControl.sys_from_particles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sys_from_particles(P, i)
sys_from_particles(P)</code></pre><p>Return the <code>i</code>th system from a system <code>P</code> with <code>Particles</code> coefficients.</p><p>If called without an index, return a vector of systems, one for each possibly <code>i</code>.</p><p>This function is used to convert from an uncertain representation using <code>Particles</code> to a &quot;multi-model&quot; representation using multiple <code>StateSpace</code> models.</p><p>See also <a href="#RobustAndOptimalControl.ss2particles-Tuple{Vector{&lt;:AbstractStateSpace}}"><code>ss2particles</code></a> and <code>MonteCarloMeasurements.nominal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L474-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.system_mapping" href="#RobustAndOptimalControl.system_mapping"><code>RobustAndOptimalControl.system_mapping</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">system_mapping(P::ExtendedStateSpace)</code></pre><p>Return the system from u -&gt; y See also <a href="#RobustAndOptimalControl.performance_mapping"><code>performance_mapping</code></a>, <a href="#RobustAndOptimalControl.system_mapping"><code>system_mapping</code></a>, <a href="#RobustAndOptimalControl.noise_mapping"><code>noise_mapping</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/ExtendedStateSpace.jl#L685-L690">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.uss" href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uss(d::AbstractVector{&lt;:δ}, Ts = nothing)</code></pre><p>Create a diagonal uncertain statespace object with the uncertain elements <code>d</code> on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L201-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.uss" href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uss(D::AbstractArray, Δ, Ts = nothing)</code></pre><p>If only a single <code>D</code> matrix is provided, it&#39;s treated as <code>D11</code> if Δ is given, and as <code>D22</code> if no Δ is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.uss" href="#RobustAndOptimalControl.uss"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uss(D11, D12, D21, D22, Δ, Ts = nothing)</code></pre><p>Create an uncertain statespace object with only gin matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}" href="#RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}"><code>RobustAndOptimalControl.uss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uss(d::δ{C, F}, Ts = nothing)</code></pre><p>Convert a δ object to an UncertainSS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.vec2sys" href="#RobustAndOptimalControl.vec2sys"><code>RobustAndOptimalControl.vec2sys</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vec2sys(v::AbstractArray, ny::Int, nu::Int, ts = nothing)</code></pre><p>Create a statespace system from the parameters</p><pre><code class="language-julia hljs">v = vec(sys) = [vec(sys.A); vec(sys.B); vec(sys.C); vec(sys.D)]</code></pre><p>Use <code>vec(sys)</code> to create <code>v</code>.</p><p>This can be useful in order to convert to and from vectors for, e.g., optimization.</p><pre><code class="language- hljs">julia&gt; sys  = ss(tf(1, [1, 1]))
StateSpace{Continuous, Float64}
A = 
 -1.0
B = 
 1.0
C = 
 1.0
D = 
 0.0

Continuous-time state-space model

julia&gt; v    = vec(sys)
4-element Vector{Float64}:
 -1.0
  1.0
  1.0
  0.0

julia&gt; sys2 = vec2sys(v, sys.ny, sys.nu)
StateSpace{Continuous, Float64}
A = 
 -1.0
B = 
 1.0
C = 
 1.0
D = 
 0.0

Continuous-time state-space model</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/utils.jl#L56-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.δc" href="#RobustAndOptimalControl.δc"><code>RobustAndOptimalControl.δc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">δc(val::Complex = complex(0.0), radius::Real = 1.0, name)</code></pre><p>Create a complex, uncertain parameter. If no name is given, a boring name will be generated automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustAndOptimalControl.δr" href="#RobustAndOptimalControl.δr"><code>RobustAndOptimalControl.δr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">δr(val::Real = 0.0, radius::Real = 1.0, name)</code></pre><p>Create a real, uncertain parameter. If no name is given, a boring name will be generated automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/e95213eaa774db24baf710d95a61552c978ecd7e/src/uncertainty_interface.jl#L20-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../similarity/">« When are systems similar?</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 26 September 2024 11:50">Thursday 26 September 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
