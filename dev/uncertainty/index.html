<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Uncertainty modeling · RobustAndOptimalControl Documentation</title><meta name="title" content="Uncertainty modeling · RobustAndOptimalControl Documentation"/><meta property="og:title" content="Uncertainty modeling · RobustAndOptimalControl Documentation"/><meta property="twitter:title" content="Uncertainty modeling · RobustAndOptimalControl Documentation"/><meta name="description" content="Documentation for RobustAndOptimalControl Documentation."/><meta property="og:description" content="Documentation for RobustAndOptimalControl Documentation."/><meta property="twitter:description" content="Documentation for RobustAndOptimalControl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RobustAndOptimalControl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Uncertainty modeling</a><ul class="internal"><li><a class="tocitem" href="#Uncertainty-API"><span>Uncertainty API</span></a></li><li><a class="tocitem" href="#Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/MonteCarloMeasurements.jl)"><span>Parametric uncertainty using MonteCarloMeasurements.jl</span></a></li><li><a class="tocitem" href="#Model-order-reduction-for-uncertain-models"><span>Model-order reduction for uncertain models</span></a></li><li><a class="tocitem" href="#Using-the-M\\Delta-framework"><span>Using the <span>$M\Delta$</span> framework</span></a></li><li><a class="tocitem" href="#Uncertain-time-delays"><span>Uncertain time delays</span></a></li><li><a class="tocitem" href="#Models-of-uncertain-dynamics"><span>Models of uncertain dynamics</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../hinf_DC/">Simple mixed-sensitivity <span>$H_\infty$</span> design</a></li><li><a class="tocitem" href="../hinf_connection/">General <span>$H_\infty$</span> design</a></li><li><a class="tocitem" href="../lqg_disturbance/">LQG control with integral action</a></li><li><a class="tocitem" href="../cartpole/">Control design for a pendulum on a cart</a></li><li><a class="tocitem" href="../measurable_disturbance/"><span>$H_2$</span> design with a known disturbance</a></li><li><a class="tocitem" href="../similarity/">When are systems similar?</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Uncertainty modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Uncertainty modeling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/docs/src/uncertainty.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Uncertainty-modeling"><a class="docs-heading-anchor" href="#Uncertainty-modeling">Uncertainty modeling</a><a id="Uncertainty-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-modeling" title="Permalink"></a></h1><p>We provide two general means of modeling uncertainty, the traditional <span>$M\Delta$</span> framework <sup class="footnote-reference"><a id="citeref-Skogestad" href="#footnote-Skogestad">[Skogestad]</a></sup><sup class="footnote-reference"><a id="citeref-Doyle91" href="#footnote-Doyle91">[Doyle91]</a></sup>, and using parametric uncertainty. Support for parametric uncertainty is almost universal in Julia, not only in ControlSystems.jl, by means of computing with uncertain number types. In this tutorial, we will use a Monte-Carlo approach using uncertain number types from <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a>.</p><p>Both the <span>$M\Delta$</span> framework and parametric-uncertainty approaches are illustrated below.</p><ul><li><a href="#Uncertainty-modeling">Uncertainty modeling</a></li><li class="no-marker"><ul><li><a href="#Uncertainty-API">Uncertainty API</a></li><li><a href="#Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/MonteCarloMeasurements.jl)">Parametric uncertainty using MonteCarloMeasurements.jl</a></li><li class="no-marker"><ul><li><a href="#Basic-example">Basic example</a></li><li><a href="#Example:-Spinning-satellite">Example: Spinning satellite</a></li><li><a href="#Example:-Distillation-Process">Example: Distillation Process</a></li></ul></li><li><a href="#Model-order-reduction-for-uncertain-models">Model-order reduction for uncertain models</a></li><li class="no-marker"><ul><li><a href="#\\nu-gap-approach"><span>$\nu$</span>-gap approach</a></li><li><a href="#Balanced-truncation">Balanced truncation</a></li></ul></li><li><a href="#Using-the-M\\Delta-framework">Using the <span>$M\Delta$</span> framework</a></li><li class="no-marker"><ul><li><a href="#Robust-stability-and-performance">Robust stability and performance</a></li><li><a href="#Examples">Examples</a></li><li><a href="#Internals-of-the-M\\Delta-framework">Internals of the <span>$M\Delta$</span> framework</a></li></ul></li><li><a href="#Uncertain-time-delays">Uncertain time delays</a></li><li><a href="#Models-of-uncertain-dynamics">Models of uncertain dynamics</a></li></ul></li></ul><h2 id="Uncertainty-API"><a class="docs-heading-anchor" href="#Uncertainty-API">Uncertainty API</a><a id="Uncertainty-API-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-API" title="Permalink"></a></h2><ul><li><a href="../api/#RobustAndOptimalControl.δc"><code>δc</code></a> Creates an uncertain complex parameter.</li><li><a href="../api/#RobustAndOptimalControl.δr"><code>δr</code></a> Creates an uncertain real parameter.</li><li><a href="@ref"><code>δss</code></a> (Experimental) Creates an uncertain statespace model.</li><li><a href="../api/#RobustAndOptimalControl.neglected_delay-Tuple{Any}"><code>neglected_delay</code></a> Create a multiplicative weight that represents uncertainty from an unmodeled delay.</li><li><a href="../api/#RobustAndOptimalControl.neglected_lag-Tuple{Any}"><code>neglected_lag</code></a> Create a multiplicative weight that represents uncertainty from an unmodeled lag (pole).</li><li><a href="../api/#RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}"><code>gain_and_delay_uncertainty</code></a> Create a multiplicative weight that represents uncertainty from uncertain gains and delay.</li><li><a href="../api/#RobustAndOptimalControl.makeweight-Tuple{Any, Number, Any}"><code>makeweight</code></a> Create a custom weighting function.</li><li><a href="../api/#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}"><code>fit_complex_perturbations</code></a></li><li>See <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable/">MonteCarloMeasurements.jl</a> to create uncertain parameters that are represented by samples.</li><li><a href="../api/#RobustAndOptimalControl.sys_from_particles-Tuple{Any, Any}"><code>sys_from_particles</code></a> Convert from an uncertain representation using <code>Particles</code> to a &quot;multi-model&quot; representation using multiple <code>StateSpace</code> models.</li><li><a href="../api/#RobustAndOptimalControl.ss2particles-Tuple{Vector{&lt;:AbstractStateSpace}}"><code>ss2particles</code></a> Convert a vector of state-space models to a single state-space model with coefficient type <code>MonteCarloMeasurements.Particles</code>.</li></ul><p>See example <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/examples/uncertain.jl"><code>uncertain.jl</code></a>.</p><h2 id="Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/MonteCarloMeasurements.jl)"><a class="docs-heading-anchor" href="#Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/MonteCarloMeasurements.jl)">Parametric uncertainty using <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a></a><a id="Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/MonteCarloMeasurements.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/MonteCarloMeasurements.jl)" title="Permalink"></a></h2><p>The most straightforward way to model uncertainty is to use uncertain parameters, using tools such as <a href="https://github.com/JuliaIntervals/IntervalArithmetic.jl">IntervalArithmetic</a> (strict, worst case guarantees) or <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements</a> (less strict worst-case analysis or probabilistic). In the following, we show an example with MIMO systems with both parametric uncertainty and diagonal, complex uncertainty, adapted from 8.11.3 in Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;. This example is also available as a julia script in <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/examples/uncertain.jl"><code>uncertain.jl</code></a>.</p><p>We will create uncertain parameters using the <a href="../api/#RobustAndOptimalControl.δr"><code>δr</code></a> constructor from this package. One may alternatively create uncertain parameters directly using any of the constructors from MonteCarloMeasurements.jl. Most functions from ControlSystemsBase.jl should work with systems containing parameters from MonteCarloMeasurements.jl.</p><h3 id="Basic-example"><a class="docs-heading-anchor" href="#Basic-example">Basic example</a><a id="Basic-example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-example" title="Permalink"></a></h3><p>This example shows how to use MonteCarloMeasurements directly to build uncertain systems.</p><pre><code class="language-julia hljs">using ControlSystemsBase, MonteCarloMeasurements, Plots
ω = 1 ± 0.1 # Create an uncertain Gaussian parameter</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0 ± 0.1 MonteCarloMeasurements.Particles{Float64, 2000}
</code></pre><pre><code class="language-julia hljs">ζ = 0.3..0.4 # Create an uncertain uniform parameter</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.35 ± 0.0289 MonteCarloMeasurements.Particles{Float64, 2000}
</code></pre><pre><code class="language-julia hljs">G = tf(ω^2, [1, 2ζ*ω, ω^2]) # systems accept uncertain parameters</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TransferFunction{Continuous, ControlSystemsBase.SisoRational{MonteCarloMeasurements.Particles{Float64, 2000}}}
           1.01 ± 0.2
---------------------------------
1.0s^2 + 0.7 ± 0.09s + 1.01 ± 0.2

Continuous-time transfer function model</code></pre><pre><code class="language-julia hljs">w = exp10.(-2:0.02:2)
bodeplot(G, w)</code></pre><img src="78389912.png" alt="Example block output"/><pre><code class="language-julia hljs">plot(step(G, 0:0.1:20))</code></pre><img src="34703cb5.png" alt="Example block output"/><h3 id="Example:-Spinning-satellite"><a class="docs-heading-anchor" href="#Example:-Spinning-satellite">Example: Spinning satellite</a><a id="Example:-Spinning-satellite-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Spinning-satellite" title="Permalink"></a></h3><p>This example makes use of real-valued uncertain parameters created using <a href="../api/#RobustAndOptimalControl.δr"><code>δr</code></a>, it comes from section 3.7.1 of Skogestad&#39;s book.</p><pre><code class="language-julia hljs">using RobustAndOptimalControl, ControlSystemsBase, MonteCarloMeasurements, Plots, LinearAlgebra
unsafe_comparisons(true)

a = 10
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)
K = ss(1.0I(2))

w = 2π .* exp10.(LinRange(-2, 2, 500))
S, PS, CS, T = gangoffour(P, K)
sigmaplot(S, w, lab=&quot;S&quot;)
sigmaplot!(T, w, c=2, lab=&quot;T&quot;, ylims=(0.01, 45))</code></pre><img src="c9c31881.svg" alt="Example block output"/><p>Both sensitivity functions are very large, expect a non-robust system!</p><p>Next, we add parametric uncertainty</p><pre><code class="language-julia hljs">a = 10*(1 + 0.1δr(100)) # Create an uncertain parameter with nominal value 10 and 10% uncertainty, represented by 100 samples
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)

Sp, PSp, CSp, Tp = gangoffour(P, K)
sigmaplot(Sp, w, lab=&quot;S&quot;)
sigmaplot!(Tp, w, c=2, lab=&quot;T&quot;, ylims=(0.01, 100))</code></pre><img src="0a4f14c3.png" alt="Example block output"/><p>Not only are sensitivity functions large, they vary a lot under the considered uncertainty. We can also plot a step response of one of the sensitivity functions to check how the system behaves</p><pre><code class="language-julia hljs">plot(step(c2d(Tp, 0.01), 10))</code></pre><img src="9ac6d9fa.png" alt="Example block output"/><p>This kind of plot is quite useful, it immediately tells you that this transfer function appears stable, and that there is uncertainty in the static gain etc.</p><p>Next, we add complex diagonal multiplicative input uncertainty. With input uncertainty of magnitude <span>$ϵ &lt; \dfrac{1}{σ̄(T)}$</span> we are guaranteed robust stability (even for “full-block complex perturbations&quot;)</p><pre><code class="language-julia hljs">a = 10
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)

W0 = makeweight(0.2, (20,1), 2)
W = I(2) + W0 .* diagm([δc(100), δc(100)]) # Create a diagonal complex uncertainty weighted in frequency by W0, use 100 samples
Ps = P*W
Ss, PSs, CSs, Ts = gangoffour(Ps, K)
sigmaplot(Ss, w, lab=&quot;S&quot;)
sigmaplot!(Ts, w, c=2, lab=&quot;T&quot;, ylims=(0.01, 100))</code></pre><img src="7601ab0c.png" alt="Example block output"/><p>Under this uncertainty, the sensitivity could potentially be sky high., note how some of the 100 realizations peak much higher than the others. This is an indication that the system might be unstable.</p><p>With complex entries in the system model, we can&#39;t really plot the step response, but we can plot, e.g., the absolute value</p><pre><code class="language-julia hljs">res = step(c2d(Ts, 0.01), 10)
plot(res.t, [abs.(res.y)[1,:,1] abs.(res.y)[2,:,2]]) # plot only the diagonal response</code></pre><img src="fc95d5bf.png" alt="Example block output"/><p>Looks unstable to me. The analysis using <span>$M\Delta$</span> methodology below will also reach this conclusion.</p><h3 id="Example:-Distillation-Process"><a class="docs-heading-anchor" href="#Example:-Distillation-Process">Example: Distillation Process</a><a id="Example:-Distillation-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Distillation-Process" title="Permalink"></a></h3><p>This example comes from section 3.7.2 of Skogestad&#39;s book. In this example, we&#39;ll explore also complex uncertainties, created using <a href="../api/#RobustAndOptimalControl.δc"><code>δc</code></a>.</p><pre><code class="language-julia hljs">using RobustAndOptimalControl, ControlSystemsBase, MonteCarloMeasurements, Plots, LinearAlgebra
unsafe_comparisons(true)

M = [87.8 -86.4; 108.2 -109.6]
G = Ref(ss(tf(1, [75, 1]))) .* M
RGA = relative_gain_array(G, 0)
sum(abs, RGA) # A good estimate of the true condition number, which is 141.7</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">138.2752186588932</code></pre><p>large elements in the RGA indicate a process that is difficult to control</p><p>We consider the following inverse-based controller, which may also be looked upon as a steady-state decoupler with a PI controller</p><pre><code class="language-julia hljs">k1 = 0.7
Kinv = Ref(ss(tf(k1*[75, 1], [1, 0]))) .* inv(M)

# reference filter
F = tf(1, [5, 1]) .* I(2)

w = 2π .* exp10.(LinRange(-2, 2, 500))
sigmaplot(input_sensitivity(G, Kinv), w)
sigmaplot!(output_sensitivity(G, Kinv), w, c=2)</code></pre><img src="ce90bbb5.svg" alt="Example block output"/><p>Sensitivity looks nice, how about step response</p><pre><code class="language-julia hljs">plot(step(feedback(G*Kinv)*F, 20))</code></pre><img src="c367f08f.svg" alt="Example block output"/><p>Looks excellent..</p><p>We consider again the input gain uncertainty as in the previous example, and we manually select the perturbations to be <span>$ϵ_1 = 0.2$</span> and <span>$ϵ_2 = 0.2$</span>. We then have</p><pre><code class="language-julia hljs">G′ = G * diagm([1 + 0.2, 1 - 0.2])
plot!(step(feedback(G′*Kinv)*F, 20), l=:dash)</code></pre><img src="97aa44a2.svg" alt="Example block output"/><p>Looks very poor! The system was not robust to simultaneous input uncertainty!</p><p>We can also do this with a real, diagonal input uncertainty that grows with frequency</p><pre><code class="language-julia hljs">W0 = makeweight(0.2, 1, 2.0) # uncertainty goes from 20% at low frequencies to 200% at high frequencies
W = I(2) + W0 .* diagm([δr(100), δr(100)])
Gs = G*W

plot(step(feedback(G*Kinv)*F, 20))
plot!(step(feedback(G′*Kinv)*F, 20), l=:dash)
res = step(c2d(feedback(Gs*Kinv)*F, 0.01), 20)
mcplot!(res.t, abs.(res.y[:, :, 1]&#39;), alpha=0.3)
mcplot!(res.t, abs.(res.y[:, :, 2]&#39;), alpha=0.3)</code></pre><img src="515dfe96.png" alt="Example block output"/><p>The system is very sensitive to real input uncertainty!</p><p>With a complex, diagonal uncertainty, modeling both gain and phase variations, it looks slightly worse, but not much worse than with real uncertainty.</p><pre><code class="language-julia hljs">W = I(2) + W0 .* diagm([δc(100), δc(100)]) # note δc instead of δr above
Gs = G*W
res = step(c2d(feedback(Gs*Kinv)*F, 0.01), 20)
mcplot!(res.t, abs.(res.y[:, :, 1]&#39;), alpha=0.3)
mcplot!(res.t, abs.(res.y[:, :, 2]&#39;), alpha=0.3)</code></pre><img src="b40ccaa5.png" alt="Example block output"/><p>How about the sensitivity functions?</p><pre><code class="language-julia hljs">Si = input_sensitivity(Gs, Kinv)
sigmaplot(Si, w, c=1, lab=&quot;Si&quot;)
So = output_sensitivity(Gs, Kinv)
sigmaplot!(So, w, c=2, lab=&quot;So&quot;)</code></pre><img src="9a82158e.png" alt="Example block output"/><p>The sensitivity at the plant output is enormous. A low sensitivity with the nominal system does not guarantee robustness!</p><h2 id="Model-order-reduction-for-uncertain-models"><a class="docs-heading-anchor" href="#Model-order-reduction-for-uncertain-models">Model-order reduction for uncertain models</a><a id="Model-order-reduction-for-uncertain-models-1"></a><a class="docs-heading-anchor-permalink" href="#Model-order-reduction-for-uncertain-models" title="Permalink"></a></h2><h3 id="\\nu-gap-approach"><a class="docs-heading-anchor" href="#\\nu-gap-approach"><span>$\nu$</span>-gap approach</a><a id="\\nu-gap-approach-1"></a><a class="docs-heading-anchor-permalink" href="#\\nu-gap-approach" title="Permalink"></a></h3><p>The <span>$\nu$</span>-gap metric is a measure of distance between models when they are used in a feedback loop. This metric has the nice property that a controller designed for a process <span>$P$</span> that achieves a normalized coprime factor margin (<a href="../api/#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a>) of <span>$m$</span>, will stabilize all models that are within a <span>$\nu$</span>-gap distance of <span>$m$</span> from <span>$P$</span>. This can be used to reduce the number of uncertain realizations for a model represented with <code>Particles</code> like above in a smart way. Say that we have a plant model <span>$P$</span></p><pre><code class="language-julia hljs">using RobustAndOptimalControl, ControlSystemsBase, MonteCarloMeasurements, Plots
ω = with_nominal(0.9 .. 1.1, 1)
ζ = with_nominal(0.5 ± 0.01, 0.5)
P = tf([ω^2], [1, 2*ζ*ω, ω^2]) |&gt; ss</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StateSpace{Continuous, MonteCarloMeasurements.Particles{Float64, 2000}}
A = 
 -1.0 ± 0.061  -1.0 ± 0.12
  1.0           0.0
B = 
 1.0
 0.0
C = 
 0.0  1.0 ± 0.12
D = 
 0.0

Continuous-time state-space model</code></pre><p>represented by 2000 samples (indicated by the displayed type <code>Particles{Float64, 2000}</code>). If we plot <span>$P$</span>, it looks something like this:</p><pre><code class="language-julia hljs">w = exp10.(LinRange(-1, 0.5, 150))
# nyquistplot(P, w, lab=&quot;Original P&quot;, xlims=(-1.1,1.1), ylims=(-1.5,0.7), points=true, format=:png, dpi=80)
bodeplot(P, w, lab=&quot;Original P&quot;, plotphase = false, format=:png, dpi=80, ri=false, c=1, legend=true)</code></pre><img src="25aaeacc.png" alt="Example block output"/><p>We can compute the <span>$\nu$</span>-gap metric between each realization in <span>$P$</span> and the nominal value (encoded using <code>with_nominal</code> above):</p><pre><code class="language-julia hljs">gap = nugap(P)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0605788 ± 0.0336 MonteCarloMeasurements.Particles{Float64, 2000}
</code></pre><p>The worst-case gap is:</p><pre><code class="language-julia hljs">pmaximum(gap) # p for &quot;particle&quot; maximum</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.12804692157112746</code></pre><p>That means that if we design a controller for the nominal <span>$P$</span> without any uncertainty, and make sure that it achieves an <a href="../api/#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a> of at least this value, it will stabilize all realizations in <span>$P$</span>.</p><p>We can also reduce the number of realizations in <span>$P$</span> by discarding those that are close in the <span>$\nu$</span>-gap sense to the nominal value:</p><pre><code class="language-julia hljs">Pr = nu_reduction(P, 0.1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StateSpace{Continuous, MonteCarloMeasurements.Particles{Float64, 319}}
A = 
 -0.978 ± 0.087  -0.97 ± 0.18
  1.0             0.0
B = 
 1.0
 0.0
C = 
 0.0  0.97 ± 0.18
D = 
 0.0

Continuous-time state-space model</code></pre><p>here, all realizations that were within a <span>$\nu$</span>-gap distance of 0.1 from the nominal value were discarded. <a href="../api/#RobustAndOptimalControl.nu_reduction"><code>nu_reduction</code></a> usually reduces the number of realizations substantially. The plot of <span>$P_r$</span> looks like</p><pre><code class="language-julia hljs"># nyquistplot(Pr, lab=&quot;Reduced P&quot;, xlims=(-1.1,1.1), ylims=(-1.5,0.7), points=true, format=:png, dpi=80)
bodeplot!(Pr, w, lab=&quot;Reduced P&quot;, plotphase = false, format=:png, dpi=80, ri=false, c=2, l=2)</code></pre><img src="1915e7d5.png" alt="Example block output"/><p>we see that the reduction kept the realizations that were furthest away from the nominal value.</p><p>We can reduce the number of realizations even further using <a href="../api/#RobustAndOptimalControl.nu_reduction_recursive"><code>nu_reduction_recursive</code></a>:</p><pre><code class="language-julia hljs">Prr = nu_reduction_recursive(P, 0.1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StateSpace{Continuous, MonteCarloMeasurements.Particles{Float64, 3}}
A = 
 -0.993 ± 0.04  -1.0 ± 0.19
  1.0            0.0
B = 
 1.0
 0.0
C = 
 0.0  1.0 ± 0.19
D = 
 0.0

Continuous-time state-space model</code></pre><pre><code class="language-julia hljs"># nyquistplot(Prr, lab=&quot;Recursively reduced P&quot;, xlims=(-1.1,1.1), ylims=(-1.5,0.7), points=true, format=:png, dpi=80)
bodeplot!(Prr, w, lab=&quot;Recursively reduced P&quot;, plotphase = false, format=:png, dpi=80, ri=false, c=3, l=3)</code></pre><img src="8aee8d1a.png" alt="Example block output"/><p>We now have only three realizations left, the nominal one and the two extreme cases (in the <span>$\nu$</span>-gap sense).</p><p>The algorithm used in <a href="../api/#RobustAndOptimalControl.nu_reduction_recursive"><code>nu_reduction_recursive</code></a> has a worst-case complexity of <span>$O(N^2)$</span> where <span>$N$</span> is the number of realizations (particles) in <span>$P$</span>, but this complexity is only problematic for small gaps and large number of realizations, say, <span>$\nu &lt; 0.02$</span> and <span>$N &gt; 50$</span>.</p><p>With the reduced model, we can more easily perform loop-shaping or other control design tasks, as long as we keep track of <a href="../api/#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}"><code>ncfmargin</code></a> staying above our <span>$\nu$</span>-gap.</p><div class="admonition is-category-warn" id="Stochastic-interpretation-1807110fdab93200"><header class="admonition-header">Stochastic interpretation<a class="admonition-anchor" href="#Stochastic-interpretation-1807110fdab93200" title="Permalink"></a></header><div class="admonition-body"><p>If <code>P</code> has a stochastic interpretation, i.e., the coefficients come from some distribution, this interpretation will be lost after reduction, mean values and standard deviations will not be preserved. The reduced system should instead be interpreted as preserving worst-case uncertainty.</p></div></div><p>For more background on the <span>$\nu$</span>-gap metric, see <a href="../similarity/#When-are-two-systems-similar?">When are two systems similar?</a> and the book by Skogestad and Postlethwaite or by Åström and Murray.</p><h3 id="Balanced-truncation"><a class="docs-heading-anchor" href="#Balanced-truncation">Balanced truncation</a><a id="Balanced-truncation-1"></a><a class="docs-heading-anchor-permalink" href="#Balanced-truncation" title="Permalink"></a></h3><p>Another option to reduce the complexity of an uncertain model is to reinterpret it has a deterministic model with expanded state and output dimensions. For example, an uncertain model with <span>$N$</span> particles and state and output dimensions <span>$n_x, `n_y$</span> can be converted into a deterministic model with state and output dimensions <span>$Nn_x$</span> and <span>$Nn_y$</span> respectively (the input dimension remains the same). The order of this model can then be reduced using standard balanced truncation (or any other model-reduction method). The conversion from a model with <code>Particles</code> coefficients to an expanded deterministic model is performed by <a href="../api/#RobustAndOptimalControl.mo_sys_from_particles-Tuple{AbstractStateSpace}"><code>mo_sys_from_particles</code></a>, and balanced truncation (and other model-reduction techniques) is documented at <a href="../#Model-reduction">Model reduction</a>.</p><p>Note, the reduced-order model cannot easily be converted back to a representation with <code>Particles</code> when this approach is taken. The model-order reduction will in this case only reduce the state dimension, but the output dimension will remain the same.</p><p>We demonstrate this procedure on the model from the section above:</p><pre><code class="language-julia hljs">Pmo = mo_sys_from_particles(P, sparse=false)
Pred, S = baltrunc(Pmo)
bodeplot(P, w, lab=&quot;Original P&quot;, plotphase = false, format=:png, dpi=80, ri=false, c=1, legend=true)
bodeplot!(Pred, w, lab=&quot;&quot;, plotphase = false, format=:png, dpi=80, c=2, l=1, sp=1, alpha=0.01)</code></pre><img src="38dc2f53.png" alt="Example block output"/><p>This time, we keep the same output dimension, but the state dimension is reduced significantly:</p><pre><code class="language-julia hljs">Pred.nx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6</code></pre><p>Note, <code>Pred</code> here represents the uncertain model with a single deterministic model of order <code>Pred.nx</code>, while the original uncertain model <code>P</code> was represented by 2000 internal models of state dimension 2.</p><h2 id="Using-the-M\\Delta-framework"><a class="docs-heading-anchor" href="#Using-the-M\\Delta-framework">Using the <span>$M\Delta$</span> framework</a><a id="Using-the-M\\Delta-framework-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-M\\Delta-framework" title="Permalink"></a></h2><p>The examples above never bothered with things like the &quot;structured singular value&quot;, <span>$\mu$</span> or linear-fractional transforms. We do, however, provide some elementary support for this modeling framework.</p><p>In robust control, we often find ourselves having to consider the feedback interconnections below.</p><pre><code class="nohighlight hljs">        ┌─────────┐
  zΔ◄───┤         │◄────wΔ
        │         │
   z◄───┤    P    │◄────w
        │         │
   y◄───┤         │◄────u
        └─────────┘</code></pre><pre><code class="nohighlight hljs">        ┌─────────┐
  zΔ◄───┤         │◄────wΔ
        │         │
   z◄───┤    P    │◄────w
        │         │
   y┌───┤         │◄───┐u
    │   └─────────┘    │
    │      ┌───┐       │
    └─────►│ K ├───────┘
           └───┘</code></pre><pre><code class="nohighlight hljs">           ┌───┐
    ┌─────►│ Δ ├───────┐
    │      └───┘       │
    │   ┌─────────┐    │
  zΔ└───┤         │◄───┘wΔ
        │         │
   z◄───┤    P    │◄────w
        │         │
   y┌───┤         │◄───┐u
    │   └─────────┘    │
    │      ┌───┐       │
    └─────►│ K ├───────┘
           └───┘</code></pre><p>The first block diagram denotes an open-loop system <span>$P$</span> with an uncertainty mapping <span>$w_\Delta = \Delta  z_\Delta$</span>, a <em>performance mapping</em> from <span>$w$</span> to <span>$z$</span> and a input-output mapping between <span>$u$</span> and <span>$y$</span>. Such a system <span>$P$</span> can be partitioned as</p><p class="math-container">\[P = \begin{bmatrix}
P_{11} &amp; P_{12} &amp; P_{13}\\
P_{21} &amp; P_{22} &amp; P_{23}\\
P_{31} &amp; P_{32} &amp; P_{33}\\
\end{bmatrix}\]</p><p>where each <span>$P(s)_{ij}$</span> is a transfer matrix. The type <a href="../api/#RobustAndOptimalControl.UncertainSS"><code>UncertainSS</code></a> with constructor <a href="../api/#RobustAndOptimalControl.uss"><code>uss</code></a> represents the block</p><p class="math-container">\[P = \begin{bmatrix}
P_{11} &amp; P_{12}\\
P_{21} &amp; P_{22}\\
\end{bmatrix}\]</p><p>while an <a href="../api/#RobustAndOptimalControl.ExtendedStateSpace"><code>ExtendedStateSpace</code></a> object represents the block</p><p class="math-container">\[P = \begin{bmatrix}
P_{22} &amp; P_{23}\\
P_{32} &amp; P_{33}\\
\end{bmatrix}\]</p><p>there is thus no type that represents the full system <span>$P$</span> above. However, we provide the function <a href="../api/#RobustAndOptimalControl.partition-Tuple{AbstractStateSpace, Int64, Int64}"><code>partition</code></a> which allows you to convert from a regular statespace system to an extended statespace object, and it is thus possible to represent <span>$P$</span> by placing the whole block </p><p class="math-container">\[P = \begin{bmatrix}
P_{22} &amp; P_{23}\\
P_{32} &amp; P_{33}\\
\end{bmatrix}\]</p><p>into <span>$P_{22}$</span> for the purposes of uncertainty analysis (use <code>ss</code> to convert it to a standard statespace object), and later use <a href="../api/#RobustAndOptimalControl.partition-Tuple{AbstractStateSpace, Int64, Int64}"><code>partition</code></a> to recover the internal block structure. </p><p>Given an <a href="../api/#RobustAndOptimalControl.UncertainSS"><code>UncertainSS</code></a> <span>$P$</span>, we can close the loop around <span>$\Delta$</span> by calling <code>lft(P, Δ, :u)</code>, and given an <a href="../api/#RobustAndOptimalControl.ExtendedStateSpace"><code>ExtendedStateSpace</code></a>, we can close the loop around <code>K</code> by calling <code>starprod(P, K)</code> or <code>lft(P, K)</code> (using positive feedback). This works even if <code>P</code> is a regular statespace object, in which case the convention is that the inputs and outputs are ordered as in the block diagrams above. The number of signals that will be connected by <a href="@ref"><code>lft</code></a> is determined by the input-output arity of <span>$K$</span> and <span>$\Delta$</span> respectively.</p><p>We have the following methods for <code>lft</code> (in addition to the standard ones in ControlSystemsBase.jl)</p><ul><li><code>lft(G::UncertainSS, K::LTISystem)</code> forms the lower LFT closing the loop around <span>$K$</span>.</li><li><code>lft(G::UncertainSS, Δ::AbstractArray=G.Δ)</code> forms the upper LFT closing the loop around <span>$\Delta$</span>.</li><li><code>lft(G::ExtendedStateSpace, K)</code> forms the lower LFT closing the loop around <span>$K$</span>.</li></ul><h3 id="Robust-stability-and-performance"><a class="docs-heading-anchor" href="#Robust-stability-and-performance">Robust stability and performance</a><a id="Robust-stability-and-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Robust-stability-and-performance" title="Permalink"></a></h3><p>To check robust stability of the system in the last block diagram (with or without <span>$z$</span> and <span>$w$</span>), we can use the functions <a href="../api/#RobustAndOptimalControl.structured_singular_value-Tuple{LTISystem, AbstractVector}"><code>structured_singular_value</code></a>, <a href="../api/#RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}"><code>robstab</code></a> and <a href="../api/#RobustAndOptimalControl.diskmargin"><code>diskmargin</code></a>.</p><p>Currently, <a href="../api/#RobustAndOptimalControl.structured_singular_value-Tuple{LTISystem, AbstractVector}"><code>structured_singular_value</code></a> is rather limited and supports diagonal complex blocks only. If <span>$\Delta$</span> is a single full complex block, <code>opnorm(P.M) &lt; 1</code> is the condition for stability.</p><p>Robust performance can be verified by introducing an additional fictitious &quot;performance perturbation&quot; <span>$\Delta_p$</span> which is a full complex block, around which we close the loop from <span>$z$</span> to <span>$w$</span> and check the <a href="../api/#RobustAndOptimalControl.structured_singular_value-Tuple{LTISystem, AbstractVector}"><code>structured_singular_value</code></a> with the augmented perturbation block</p><p class="math-container">\[\Delta_a = \begin{bmatrix}
\Delta &amp; 0\\
0      &amp; \Delta_p\\
\end{bmatrix}\]</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>We repeat the first example here, but using <span>$M\Delta$</span> formalism rather than direct Monte-Carlo modeling.</p><p>When we call <a href="../api/#RobustAndOptimalControl.δc"><code>δc</code></a> without any arguments, we get a symbolic (or structured) representation of the uncertainty rather than the sampled representation we got from calling <code>δc(100)</code>.</p><pre><code class="language-julia hljs">a = 10
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)
W0 = makeweight(0.2, (1,1), 2) |&gt; ss
W = I(2) + W0 .* uss([δc(), δc()]) # Create a diagonal complex uncertainty weighted in frequency by W0
Ps = P*W</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UncertainSS{Continuous}
A = 
   0.0  10.0  -1.590990257669732    0.0
 -10.0   0.0   0.0                 -1.590990257669732
   0.0   0.0  -1.7677669529663689   0.0
   0.0   0.0   0.0                 -1.7677669529663689
B = 
 2.0  0.0  1.0  0.0
 0.0  2.0  0.0  1.0
 2.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0
C = 
   0.0   0.0  0.0  0.0
   0.0   0.0  0.0  0.0
   1.0  10.0  0.0  0.0
 -10.0   1.0  0.0  0.0
D = 
 0.0  0.0  1.0  0.0
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

Continuous-time state-space model</code></pre><p><code>Ps</code> is now represented as a upper linear fractional transform (upper LFT).</p><p>We can draw samples from this uncertainty representation (sampling of <span>$\Delta$</span> and closing the loop <code>starprod(Δ, Ps)</code>) like so</p><pre><code class="language-julia hljs">Psamples = rand(Ps, 100)
sigmaplot(Psamples, w)</code></pre><img src="cbf50c91.png" alt="Example block output"/><p>We can extract the nominal model using</p><pre><code class="language-julia hljs">system_mapping(Ps)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StateSpace{Continuous, Float64}
A = 
   0.0  10.0
 -10.0   0.0
B = 
 1.0  0.0
 0.0  1.0
C = 
   1.0  10.0
 -10.0   1.0
D = 
 0.0  0.0
 0.0  0.0

Continuous-time state-space model</code></pre><p>And obtain <span>$M$</span> and <span>$\Delta$</span> when the loop is closed with <span>$K$</span> like this:</p><pre><code class="language-julia hljs">lft(Ps, K).M</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StateSpace{Continuous, Float64}
A = 
   1.0  20.0  -1.590990257669732    0.0
 -20.0   1.0   0.0                 -1.590990257669732
   0.0   0.0  -1.7677669529663689   0.0
   0.0   0.0   0.0                 -1.7677669529663689
B = 
 2.0  0.0
 0.0  2.0
 2.0  0.0
 0.0  2.0
C = 
   1.0  10.0  0.0  0.0
 -10.0   1.0  0.0  0.0
D = 
 0.0  0.0
 0.0  0.0

Continuous-time state-space model</code></pre><pre><code class="language-julia hljs">Ps.Δ # Ps.delta also works</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Any}:
 δ{ComplexF64, Float64}(0.0 + 0.0im, 1.0, Symbol(&quot;##δ#497&quot;))
 δ{ComplexF64, Float64}(0.0 + 0.0im, 1.0, Symbol(&quot;##δ#498&quot;))</code></pre><p>We can evaluate the frequency response of <span>$M$</span> and calculate the structured singular value <span>$\mu$</span></p><pre><code class="language-julia hljs">M = freqresp(lft(Ps, -K).M, w) # -K to get negative feedback
μ = structured_singular_value(M)
plot(w, μ, xscale=:log10, title=&quot;Structured singular value μ&quot;, xlabel=&quot;Frequency [rad/s]&quot;, ylabel=&quot;μ&quot;)</code></pre><img src="c5fb3b65.svg" alt="Example block output"/><p><span>$\mu$</span> is very high, whenever <span>$\mu &gt; 1$</span>, the system is not stable with respect to the modeled uncertainty. The tolerated uncertainty is only about <span>$\dfrac{1}{||\mu||_\infty}$</span></p><pre><code class="language-julia hljs">1/norm(μ, Inf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.13647901995727751</code></pre><p>of the modeled uncertainty. Another way of calculating this value is</p><pre><code class="language-julia hljs">robstab(lft(Ps, -K))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.136477575525228</code></pre><h3 id="Internals-of-the-M\\Delta-framework"><a class="docs-heading-anchor" href="#Internals-of-the-M\\Delta-framework">Internals of the <span>$M\Delta$</span> framework</a><a id="Internals-of-the-M\\Delta-framework-1"></a><a class="docs-heading-anchor-permalink" href="#Internals-of-the-M\\Delta-framework" title="Permalink"></a></h3><p>TODO</p><h2 id="Uncertain-time-delays"><a class="docs-heading-anchor" href="#Uncertain-time-delays">Uncertain time delays</a><a id="Uncertain-time-delays-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertain-time-delays" title="Permalink"></a></h2><p>Modeling uncertain time delays can be done in several ways, one approach is to make use of a multiplicative uncertainty weight created using <a href="../api/#RobustAndOptimalControl.neglected_delay-Tuple{Any}"><code>neglected_delay</code></a> multiplied by an uncertain element created using <a href="../api/#RobustAndOptimalControl.δc"><code>δc</code></a>, example:</p><pre><code class="language-julia hljs">using RobustAndOptimalControl, ControlSystemsBase, MonteCarloMeasurements, Plots, LinearAlgebra
a  = 10
P  = ss([0 a; -a 0], I(2), [1 a; -a 1], 0) # Plant
W0 = neglected_delay(0.005) |&gt; ss # Weight
W  = I(2) + W0 .* uss([δc(), δc()]) # Create a diagonal real uncertainty weighted in frequency by W0
Ps = P*W # Uncertain plant
Psamples = rand(Ps, 1000) # Sample the uncertain plant for plotting
w = exp10.(LinRange(-1, 3, 300)) # Frequency vector
bodeplot(Psamples, w, legend=false, N=0, quantile=0)
bodeplot!(P*[delay(0.005) tf(0); tf(0) delay(0.005)], w) # Compare to the plant with a model of the delay</code></pre><img src="bacf4bfa.png" alt="Example block output"/><p>We see that the uncertain model set includes the model with the delay. Note how this approximation approach imparts some uncertainty also in the gain.</p><p>More details on this approach can be found in Skogestad sec. 7.4.</p><p>The other alternative is to use use sampled uncertain delays. The next example shows how we can create a system with an uncertain delay, where we know that the delay is an integer number of milliseconds between 1ms and 4ms.</p><pre><code class="language-julia hljs">using RobustAndOptimalControl, ControlSystemsBase, MonteCarloMeasurements, Plots, LinearAlgebra
unsafe_comparisons(true)
L = Particles(collect((1:4) ./ 1000)) # Uncertain time delay, an integer number of milliseconds between 1ms and 4ms
P = delay(L)*tf(1, [0.01, 1])
C = pid(2, 1)
w = exp10.(-1:0.01:4)
plot(
     bodeplot(P, exp10.(-1:0.001:3), legend=false),
     # plot(step(feedback(P, C), 0:0.0001:0.05), lab=&quot;L = &quot; .* string.(P.Tau[].particles&#39;), title=&quot;Disturbance response&quot;), # This simulation requires using ControlSystems
     nyquistplot(P*C, w[1:10:end], points=true, xlims=(-3.5, 2.5), ylims=(-5, 1.5), Ms_circles=[1.5, 2], alpha=1) # Note, the nyquistplot with uncertain coefficients requires manual selection of plot limits
)</code></pre><img src="735c689b.png" alt="Example block output"/><p>Notice how the gain is completely certain, while the phase starts becoming very uncertain for high frequencies.</p><h2 id="Models-of-uncertain-dynamics"><a class="docs-heading-anchor" href="#Models-of-uncertain-dynamics">Models of uncertain dynamics</a><a id="Models-of-uncertain-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Models-of-uncertain-dynamics" title="Permalink"></a></h2><p>This section goes through a number of uncertainty descriptions in block-diagram form and shows the equivalent transfer function appearing in feedback with the uncertain element. A common approach is to model an uncertain element as <span>$W(s)\Delta$</span> where <span>$||\Delta|| \leq 1$</span> and <span>$W(s)$</span> is a frequency-dependent weighting function that is large for frequencies where the uncertainty is large. </p><h4 id="Additive-uncertainty"><a class="docs-heading-anchor" href="#Additive-uncertainty">Additive uncertainty</a><a id="Additive-uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Additive-uncertainty" title="Permalink"></a></h4><pre><code class="nohighlight hljs">          ┌────┐         ┌────┐
        ┌►│ WΔ ├─┐    ┌─►│ WΔ ├──┐
        │ └────┘ │    │  └────┘  │
        │        │    │          │
  ┌───┐ │  ┌───┐ ▼    │ ┌──────┐ │
┌►│ C ├─┴─►│ P ├─+    │ │  C   │ │
│ └───┘    └───┘ │    └─┤ ──── │◄┘
│                │      │ I+PC │
└────────────────┘      └──────┘</code></pre><p>The system is made robust with respect to this uncertainty by making</p><p class="math-container">\[W\dfrac{C}{I+PC} &lt; 1\]</p><p>for all frequencies.</p><h4 id="Multiplicative-uncertainty"><a class="docs-heading-anchor" href="#Multiplicative-uncertainty">Multiplicative uncertainty</a><a id="Multiplicative-uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Multiplicative-uncertainty" title="Permalink"></a></h4><p>At the process output</p><pre><code class="nohighlight hljs">                  ┌────┐          ┌────┐
                ┌►│ WΔ ├┐      ┌─►│ WΔ ├──┐
                │ └────┘│      │  └────┘  │
  ┌───┐   ┌───┐ │       ▼      │          │
┌►│ C ├──►│ P ├─┴───────+─►    │ ┌──────┐ │
│ └───┘   └───┘         │      │ │  PC  │ │
│                       │      └─┤ ──── │◄┘
└───────────────────────┘        │ I+PC │
                                 └──────┘</code></pre><p>The system is made robust with respect to this uncertainty by making the complimentary sensitivity function <span>$T$</span> satisfy</p><p class="math-container">\[W\dfrac{PC}{I+PC} = WT &lt; 1\]</p><p>for all frequencies.</p><p>This means that we must make the transfer function <span>$T$</span> small for frequencies where the relative uncertainty is large. The relative uncertainty is always &gt; 1 for sufficiently large frequencies, and this gives rise to the common adage of &quot;apply lowpass filtering to avoid exciting higher-order dynamics at high frequencies&quot;.</p><p>This uncertainty representation was used in the examples above where we spoke about <em>multiplicative uncertainty</em>. For MIMO systems, uncertainty appearing on the plant input may behave different than if it appears on the plant output. In general, the loop-transfer function <span>$L_o = PC$</span> denotes the <em>output loop-transfer function</em> (the loop is broken at the output of the plant) and <span>$L_i = CP$</span> denotes the <em>input loop-transfer function</em> (the loop is broken at the input of the plant). For multiplicative uncertainty at the plant input, the corresponding transfer function to be constrained is</p><p class="math-container">\[\dfrac{CP}{I+CP}W_i = TW_i &lt; 1\]</p><p>with corresponding diagram</p><pre><code class="nohighlight hljs">          ┌───┐                  ┌────┐
        ┌►│ ΔW├─┐             ┌─►│ ΔW ├───┐
        │ └───┘ │             │  └────┘   │
        │       │             │           │
  ┌───┐ │       ▼  ┌───┐      │ ┌──────┐  │
┌►│ C ├─┴─────────►│ P ├─┐    │ │  CP  │  │
│ └───┘            └───┘ │    └─┤ ──── │◄─┘
│                        │      │ I+CP │
└────────────────────────┘      └──────┘</code></pre><p>The input version represents uncertainty in the actuator, and is a particularly attractive object for analysis of SIMO systems, where this transfer function is SISO.</p><blockquote><p>Skogestad and Postlethwaite Sec. 7.5.1</p></blockquote><h5 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h5><p>See the example with <a href="#Uncertain-time-delays">Uncertain time delays</a> above.</p><h4 id="Additive-feedback-uncertainty"><a class="docs-heading-anchor" href="#Additive-feedback-uncertainty">Additive feedback uncertainty</a><a id="Additive-feedback-uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Additive-feedback-uncertainty" title="Permalink"></a></h4><pre><code class="nohighlight hljs">          ┌────┐        ┌────┐
        ┌─┤ WΔ │◄┐   ┌─►│ WΔ ├──┐
        │ └────┘ │   │  └────┘  │
        │        │   │          │
  ┌───┐ ▼  ┌───┐ │   │ ┌──────┐ │
┌►│ C ├─+─►│ P ├─┤   │ │  P   │ │
│ └───┘    └───┘ │   └─┤ ──── │◄┘
│                │     │ I+PC │
└────────────────┘     └──────┘</code></pre><p>The system is made robust with respect to this uncertainty by making</p><p class="math-container">\[W\dfrac{P}{I+PC} &lt; 1\]</p><p>for all frequencies.</p><p>This kind of uncertainty can represent uncertainty regarding presence of feedback loops, and uncertainty regarding the implementation of the controller (this uncertainty is equivalent to additive uncertainty in the controller).</p><h4 id="Multiplicative-feedback-uncertainty"><a class="docs-heading-anchor" href="#Multiplicative-feedback-uncertainty">Multiplicative feedback uncertainty</a><a id="Multiplicative-feedback-uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Multiplicative-feedback-uncertainty" title="Permalink"></a></h4><p>At the <strong>process output</strong></p><pre><code class="nohighlight hljs">                 ┌────┐           ┌────┐
                ┌┤ WΔ │◄┐      ┌─►│ WΔ ├──┐
                │└────┘ │      │  └────┘  │
  ┌───┐   ┌───┐ ▼       │      │          │
┌►│ C ├──►│ P ├─+───────┼─►    │ ┌──────┐ │
│ └───┘   └───┘         │      │ │  I   │ │
│                       │      └─┤ ──── │◄┘
└───────────────────────┘        │ I+PC │
                                 └──────┘</code></pre><p>The system is made robust with respect to this uncertainty by making the (output) sensitivity function <span>$S$</span> satisfy</p><p class="math-container">\[W\dfrac{I}{I+PC} = WS &lt; 1\]</p><p>for all frequencies.</p><p>This kind of uncertainty can represent uncertainty regarding which half plane poles are located. For frequencies where <span>$W$</span> is larger than 1, poles can move from the left to the right half plane, and we thus need to make <span>$S$</span> small (use lots of feedback) for those frequencies.</p><p>At the <strong>process input</strong>:</p><pre><code class="nohighlight hljs">          ┌────┐                  ┌───┐
        ┌─┤ WΔ │◄┐             ┌─►│ WΔ├───┐
        │ └────┘ │             │  └───┘   │
        │        │             │          │
  ┌───┐ ▼        │  ┌───┐      │ ┌──────┐ │
┌►│ C ├─+────────┴─►│ P ├┐     │ │  I   │ │
│ └───┘             └───┘│     └─┤ ──── │◄┘
│                        │       │ I+CP │
└────────────────────────┘       └──────┘</code></pre><p>The system is made robust with respect to this uncertainty by making the (input) sensitivity function <span>$S_i$</span> satisfy</p><p class="math-container">\[\dfrac{I}{I+CP} W = S_i W &lt; 1\]</p><p>for all frequencies.</p><blockquote><p>Skogestad and Postlethwaite Sec. 7.5.3</p></blockquote><h4 id="Uncertainty-through-disturbances"><a class="docs-heading-anchor" href="#Uncertainty-through-disturbances">Uncertainty through disturbances</a><a id="Uncertainty-through-disturbances-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-through-disturbances" title="Permalink"></a></h4><p>Uncertainty can of course also be modeled as disturbances acting on the system. Similar to above, we may model disturbances as a signal that has <span>$L_2$</span> norm less than 1, scaled by a weight <span>$W(s)$</span>. Additive, norm-bounded disturbances can never make a stable linear system unstable, the uncertainty does not appear *in the loop. The analysis of such disturbances can thus be focused on making the transfer function from the disturbance to the performance output small. </p><p>Some convenient facts when working with disturbances are that the <span>$H_\infty$</span> norm of a transfer function <span>$e = G_{ed}d$</span> is equal to the worst-case gain in <span>$L_2$</span> norm of signals</p><p class="math-container">\[\|G_{ed}\|_\infty = \sup_{d} \dfrac{||e||_2}{||d||_2}\]</p><p>and that the <span>$H_2$</span> norm is equal to the gain in variance</p><p class="math-container">\[\sigma_e^2 = \|G_{ed}\|_2 \sigma_d^2\]</p><h4 id="Visualizing-uncertainty"><a class="docs-heading-anchor" href="#Visualizing-uncertainty">Visualizing uncertainty</a><a id="Visualizing-uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-uncertainty" title="Permalink"></a></h4><p>For any of the uncertainty descriptions above, we may plot the total loop gain excluding the uncertain element <span>$\Delta$</span>, that is, the weight <span>$W(s)$</span> multiplied by the equivalent transfer function of the nominal part of the loop. For example, for multiplicative uncertainty at the plant output, we would plot <span>$WT$</span> in a <a href="@ref"><code>sigmaplot</code></a> and verify that all singular values are smaller than 1 for all frequencies. Alternatively, for SISO systems, we may plot <span>$T$</span> and <span>$W^{-1}$</span> in a Bode plot and verify that <span>$T &lt; W^{-1}$</span> for all frequencies. This latter visualization usually provides better intuition.</p><h5 id="Example:-Bode-plot"><a class="docs-heading-anchor" href="#Example:-Bode-plot">Example: Bode plot</a><a id="Example:-Bode-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Bode-plot" title="Permalink"></a></h5><p>Below, we perform this procedure for an multiplicative (relative) uncertainty model at the plant output. The uncertainty weight <span>$W(s)$</span> is chosen to give 10% uncertainty at low frequencies and 10x uncertainty at high frequencies, indicating that we are absolutely oblivious to the behavior of the plant at high frequencies. This is often the case, either because identification experiments did not contain excitation for high frequencies, or because the plant had nonlinear behavior at higher frequencies.</p><pre><code class="language-julia hljs">using ControlSystemsBase, RobustAndOptimalControl, Plots
P = tf(1, [1, 2, 1]) # Plant model
C = pid(19.5, 0)      # Controller
W = makeweight(0.1, 10, 10) # Low uncertainty (0.1) at low frequencies, large (10) at high frequencies.
bodeplot([comp_sensitivity(P, C), inv(W)], lab=[&quot;\$S\$&quot; &quot;\$W^{-1}\$&quot;], linestyle=[:solid :dash], plotphase=false)</code></pre><img src="512c6139.svg" alt="Example block output"/><p>As long as the complimentary sensitivity function <span>$T(s)$</span> stays below the inverse weight <span>$W^{-1}(s)$</span>, the closed-loop system is robust with respect to the modeled uncertainty.</p><h5 id="Example:-Nyquist-plot"><a class="docs-heading-anchor" href="#Example:-Nyquist-plot">Example: Nyquist plot</a><a id="Example:-Nyquist-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Nyquist-plot" title="Permalink"></a></h5><p>Continuing from the Bode-plot example above, we can translate the multiplicative weight <span>$W(s)$</span> to a set of circles we could plot in the Nyquist diagram, one for each frequency, that covers the true open-loop system. For sampled representations of uncertainty, this is done using <a href="../api/#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}"><code>fit_complex_perturbations</code></a>, but here, we do it manually. For a given frequency <span>$\omega$</span>, the radius of the circle for an additive uncertainty in the loop gain is given by <span>$|W(i\omega)|$</span>, and for a multiplicative (relative) uncertainty, it is scaled by the loop gain <span>$|W(i\omega) P(i\omega) C(i\omega)|$</span>.<sup class="footnote-reference"><a id="citeref-circ" href="#footnote-circ">[circ]</a></sup> The center of the circle is simply given by the nominal value of the loop-gain <span>$P(i\omega)C(i\omega)$</span>.</p><pre><code class="language-julia hljs">w = exp10.(LinRange(-2, 2, 200))
centers = freqrespv(P*C, w)
radii = abs.(freqrespv(W*P*C, w))
nyquistplot(P*C, w, xlims=(-4,0.1), ylims=(-4,0.1))
nyquistcircles!(w, centers, radii)</code></pre><img src="aed9e0d3.png" alt="Example block output"/><p>If the plots above are created using the <code>plotly()</code> backend, each circle is associated with hover information that is accessible by hovering the mouse over the plot. This indicates that the circle that touches the critical point is the one at <span>$\omega \approx 4.5$</span>, which coincides exactly with the point at thich the Bode plot above touches the inverse weight<span>$W^{-1}$</span>.</p><h4 id="Converting-between-uncertainty-descriptions"><a class="docs-heading-anchor" href="#Converting-between-uncertainty-descriptions">Converting between uncertainty descriptions</a><a id="Converting-between-uncertainty-descriptions-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-between-uncertainty-descriptions" title="Permalink"></a></h4><p>Any of the representations above, if modeled using uncertainty elements (<a href="../api/#RobustAndOptimalControl.UncertainSS"><code>UncertainSS</code></a>, <a href="../api/#RobustAndOptimalControl.δc"><code>δc</code></a>, <a href="../api/#RobustAndOptimalControl.δr"><code>δr</code></a>), may be converted to a sampled uncertainty representation using <code>rand(P_uncertain, 100)</code>. The sampled representation can be further converted using <a href="../api/#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}"><code>fit_complex_perturbations</code></a> which results in a set of circles, additive or multiplicative (relative), one for each frequency considered, that covers the true system. These can be plotted in a Nyquist diagram using <a href="../api/#RobustAndOptimalControl.nyquistcircles"><code>nyquistcircles</code></a> (see <a href="#Example:-Nyquist-plot">Example: Nyquist plot</a> above).</p><p>A sampled representation can also be converted to a nominal value and a maximum <span>$\nu$</span>-gap, see <a href="#Model-order-reduction-for-uncertain-models">Model-order reduction for uncertain models</a> for an example of this</p><h4 id="More-references"><a class="docs-heading-anchor" href="#More-references">More references</a><a id="More-references-1"></a><a class="docs-heading-anchor-permalink" href="#More-references" title="Permalink"></a></h4><p>Skogestad Sec. 8.5.3 contains result for moving uncertainty descriptions between input and output for MIMO systems as well as some additional forms of uncertainty descriptions, with robust stability conditions listed in Sec. 8.6.1.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Skogestad"><a class="tag is-link" href="#citeref-Skogestad">Skogestad</a>Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;</li><li class="footnote" id="footnote-Doyle91"><a class="tag is-link" href="#citeref-Doyle91">Doyle91</a>Doyle, Packard, Zhou, &quot;Review of LFTs, LMIs and μ&quot;. <a href="https://www.researchgate.net/publication/257200344_Review_of_LFTs_LMIs_and_mu"><code>https://www.researchgate.net/publication/257200344_Review_of_LFTs_LMIs_and_mu</code></a></li><li class="footnote" id="footnote-circ"><a class="tag is-link" href="#citeref-circ">circ</a>A relative uncertainty does not apply to <span>$P$</span> only, it appears after <span>$P$</span> and thus models the relative uncertainty in the entire loop gain <span>$PC$</span>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../hinf_DC/">Simple mixed-sensitivity <span>$H_\infty$</span> design »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 23 July 2025 10:08">Wednesday 23 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
