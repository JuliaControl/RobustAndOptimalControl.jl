var documenterSearchIndex = {"docs":
[{"location":"#RobustAndOptimalControl.jl","page":"Home","title":"RobustAndOptimalControl.jl","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add RobustAndOptimalControl","category":"page"},{"location":"#Named-systems","page":"Home","title":"Named systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See complicated-feedback example","category":"page"},{"location":"","page":"Home","title":"Home","text":"named_ss","category":"page"},{"location":"#Connecting-systems-together","page":"Home","title":"Connecting systems together","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See complicated-feedback example","category":"page"},{"location":"","page":"Home","title":"Home","text":"connect","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following complicated feedback interconnection","category":"page"},{"location":"","page":"Home","title":"Home","text":"                 yF\n              ┌────────────────────────────────┐\n              │                                │\n    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐\nuF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP\n────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►\n    │       │    │       │   ┌──►         │         │       │    │\n    └───────┘    └───────┘   │  └─────────┘         └───────┘    │\n                             │                                   │\n                             └───────────────────────────────────┘","category":"page"},{"location":"","page":"Home","title":"Home","text":"can be created by","category":"page"},{"location":"","page":"Home","title":"Home","text":"F = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)\nR = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)\nC = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)\nP = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)\n\naddP = sumblock(\"uP = yF + yC\") # Sum node before P\naddC = sumblock(\"uC = yR - yP\") # Sum node before C (drawn as two arrows into C in the diagram)\n\nconnections = [\n    :yP => :yP # Output to input\n    :uP => :uP # addP's output is called the same as P's input\n    :yC => :yC\n    :yF => :yF\n    :yF => :uR\n    :uC => :uC\n    :yR => :yR\n]\nw1 = [:uF] # External inputs\n\nG = connect([F, R, C, P, addP, addC], connections; w1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If an external input is to be connected to multiple points, use a splitter to split up the signal into a set of unique names which are then used in the connections.","category":"page"},{"location":"#Model-augmentation","page":"Home","title":"Model augmentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add disturbance and performance models to your system model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_disturbance\nadd_measurement_disturbance\nadd_input_differentiator\nadd_output_differentiator\nadd_input_integrator\nadd_output_integrator\nadd_low_frequency_disturbance\nadd_resonant_disturbance","category":"page"},{"location":"#H_\\infty-and-H_2-design","page":"Home","title":"H_infty and H_2 design","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO Examples are available in the example folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"hinfsynthesize\nh2synthesize\nglover_mcfarlane","category":"page"},{"location":"#LQG-design","page":"Home","title":"LQG design","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO","category":"page"},{"location":"","page":"Home","title":"Home","text":"LQGProblem","category":"page"},{"location":"#Structured-singular-value-and-diskmargin","page":"Home","title":"Structured singular value and diskmargin","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"structured_singular_value. Note, this only handles diagonal complex perturbations at the moment.\ndiskmargin\nloop_diskmargin\nsim_diskmargin","category":"page"},{"location":"#Closed-loop-analysis","page":"Home","title":"Closed-loop analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"output_sensitivity\noutput_comp_sensitivity\ninput_sensitivity\ninput_comp_sensitivity\nG_CS\nG_PS\ngangoffour","category":"page"},{"location":"#Exported-functions-and-types","page":"Home","title":"Exported functions and types","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RobustAndOptimalControl]\nPrivate = false","category":"page"},{"location":"#RobustAndOptimalControl.Disk","page":"Home","title":"RobustAndOptimalControl.Disk","text":"Disk\n\nRepresents a perturbation disc in the complex plane. Disk(0.5, 2) represents all perturbations in the circle centered at 1.25 with radius 0.75, or in other words, a gain margin of 2 and a pahse margin of 36.9 degrees.\n\nA disk can be converted to a Nyquist exclusion disk by nyquist(disk) and plotted using plot(disk).\n\nArguments:\n\nγmin: Lower intercept\nγmax: Upper intercept\nc: Center\nr: Radius\nϕm: Angle of tangent line through origin.\n\nIf γmax < γmin the disk is inverted. See diskmargin for disk margin computations. \n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.Diskmargin","page":"Home","title":"RobustAndOptimalControl.Diskmargin","text":"Diskmargin\n\nThe notation follows \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet\n\nFields:\n\nα: The disk margin ω0: The worst-case frequency f0: The destabilizing perturbation f0 is a complex number with simultaneous gain and phase variation. This critical perturbation causes an instability with closed-loop pole on the imaginary axis at the critical frequency ω0  δ0: The uncertain element generating f0. γmin: The lower real-axis intercept of the disk (analogous to classical lower gain margin). γmax: The upper real-axis intercept of the disk (analogous to classical upper gain margin). ϕm: is analogous to the classical phase margin. σ: The skew parameter that was used to calculate the margin\n\nNote, γmax and ϕm are in smaller than the classical gain and phase margins sicne the classical margins do not consider simultaneous perturbations in gain and phase. \n\nThe \"disk\" margin becomes a half plane for α = 2 and an inverted circle for α > 2. In this case, the upper gain margin is infinite. See the paper for more details, in particular figure 6.\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.LQGProblem","page":"Home","title":"RobustAndOptimalControl.LQGProblem","text":"G = LQG(sys::AbstractStateSpace, Q1, Q2, R1, R2; qQ=0, qR=0, M = I, N = I)\n\nReturn an LQG object that describes the closed control loop around the process sys=ss(A,B,C,D) where the controller is of LQG-type. The controller is specified by weight matrices Q1,Q2 that penalizes state deviations and control signal variance respectively, and covariance matrices R1,R2 which specify state drift and measurement covariance respectively.\n\nqQ and qR can be set to incorporate loop transfer recovery, i.e.,\n\nL = lqr(A, B, Q1+qQ*C'C, Q2)\nK = kalman(A, C, R1+qR*B*B', R2)\n\nIncreasing qQ will add more cost in output direction, e.g., encouraging the use of cheap control, while increasing qR adds fictious dynamics noise, makes the observer faster in the direction we control.\n\nM is a matrix that defines the controlled variables z, i.e., the variables for which you provide reference signals. If no M is provided, the default is to consider all state variables of the system as controlled. The definitions of z and y are given below\n\ny = C*x\nz = M*x\n\nsize(M, 1) determines the size of the Q1 matrix you need to supply.\n\nN is a matrix that defines how the dynamics noise v enters the system, i.e. If no N is provided, the default is to consider all state variables being affected by independent noise components. The definition of v is given below\n\nx′ = A*x + B*u + N*v\n\nsize(N, 2) determines the size of the R1 matrix you need to supply.\n\nExample\n\ns = tf(\"s\")\nP = [1/(s+1) 2/(s+2); 1/(s+3) 1/(s-1)]\nsys = ss(P)\neye(n) = Matrix{Float64}(I,n,n) # For convinience\n\nqQ = 1\nqR = 1\nQ1 = 10eye(4)\nQ2 = 1eye(2)\nR1 = 1eye(6)\nR2 = 1eye(2)\n\nG = LQG(sys, Q1, Q2, R1, R2, qQ=qQ, qR=qR)\n\nGcl = G.cl\nT = G.T\nS = G.S\nsigmaplot([S,T],exp10.(range(-3, stop=3, length=1000)))\nstepplot(Gcl)\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.LQGProblem","text":"LQGProblem(P::ExtendedStateSpace)\n\nIf only an ExtendedStateSpace system is provided, the system P is assumed to correspond to the H₂ optimal control problem with\n\nC1'C1    = Q1\nD12'D12  = Q2\n\nB1*B1'   = R1\nD21*D21' = R2\n\nand an LQGProblem with the above covariance matrices is returned. The system description in the returned LQGProblem will have B1 = C1 = I. See Ch. 13 in Robust and optimal control for reference. \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.NamedStateSpace","page":"Home","title":"RobustAndOptimalControl.NamedStateSpace","text":"See named_ss for a convenient constructor.\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.UncertainSS","page":"Home","title":"RobustAndOptimalControl.UncertainSS","text":"UncertainSS{TE} <: AbstractStateSpace{TE}\n\nRepresents LFT_u(M, Diagonal(Δ))\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.nyquistcircles","page":"Home","title":"RobustAndOptimalControl.nyquistcircles","text":"nyquistcircles(w, centers, radii)\n\nPlot the nyquist curve with circles. It only makes sense to call this function if the circles represent additive uncertainty, i.e., were calculated with relative=false.\n\nSee also fit_complex_perturbations\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.δ","page":"Home","title":"RobustAndOptimalControl.δ","text":"δ(N=32)\n\nCreate an uncertain element of N uniformly distributed samples ∈ [-1, 1]\n\n\n\n\n\n","category":"type"},{"location":"#ControlSystems.ss","page":"Home","title":"ControlSystems.ss","text":"ss(A, B1, B2, C1, C2, D11, D12, D21, D22 [, Ts])\nss(A, B1, B2, C1, C2; D11, D12, D21, D22 [, Ts])\n\nCreate ExtendedStateSpace\n\n\n\n\n\n","category":"function"},{"location":"#DescriptorSystems.dss-Tuple{ControlSystems.AbstractStateSpace}","page":"Home","title":"DescriptorSystems.dss","text":"DescriptorSystems.dss(sys::AbstractStateSpace)\n\nConvert sys to a descriptor statespace system from DescriptorSystems.jl\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}","page":"Home","title":"RobustAndOptimalControl.add_disturbance","text":"add_disturbance(sys::StateSpace, Ad::Matrix, Cd::Matrix)\n\nSee CCS pp. 144\n\nArguments:\n\nsys: System to augment\nAd: The dynamics of the disturbance\nCd: How the disturbance states affect the states of sys. This matrix has the shape (sys.nx, size(Ad, 1))\n\nSee also add_low_frequency_disturbance, add_resonant_disturbance\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_input_differentiator","page":"Home","title":"RobustAndOptimalControl.add_input_differentiator","text":"add_input_differentiator(sys::StateSpace, ui = 1:sys.nu; goodwin=false)\n\nAugment the output of sys with the difference u(k+1)-u(k)\n\nArguments:\n\nui: An index or vector of indices indicating which inputs to differentiate.\ngoodwin: If true, the difference operator will use the Goodwin δ operator, i.e., (u(k+1)-u(k)) / sys.Ts.\n\nThe augmented system will have the matrices\n\n[A 0; 0 0]  [B; I]  [C 0; 0 -I]  [D; I]\n\nwith length(ui) added states and outputs.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_input_integrator","page":"Home","title":"RobustAndOptimalControl.add_input_integrator","text":"add_input_integrator(sys::StateSpace, ui = 1, ϵ = 0)\n\nAugment the output of sys with the integral of input at index ui, i.e.,  y_aug = [y; ∫u[ui]] See also add_low_frequency_disturbance\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}","page":"Home","title":"RobustAndOptimalControl.add_low_frequency_disturbance","text":"add_low_frequency_disturbance(sys::StateSpace, Ai::Integer; ϵ = 0)\n\nA disturbance affecting only state Ai.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace}","page":"Home","title":"RobustAndOptimalControl.add_low_frequency_disturbance","text":"add_low_frequency_disturbance(sys::StateSpace; ϵ = 0, measurement = false)\n\nAugment sys with a low-frequency (integrating if ϵ=0) disturbance model. If an integrating input disturbance is used together with an observer, the controller will have integral action.\n\nArguments:\n\nϵ: Move the integrator pole ϵ into the stable region.\nmeasurement: If true, the disturbance is a measurement disturbance, otherwise it's an input diturbance. \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}","page":"Home","title":"RobustAndOptimalControl.add_measurement_disturbance","text":"add_measurement_disturbance(sys::StateSpace{Continuous}, Ad::Matrix, Cd::Matrix)\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_output_differentiator","page":"Home","title":"RobustAndOptimalControl.add_output_differentiator","text":"add_differentiator(sys::StateSpace{<:Discrete})\n\nAugment the output of sys with the numerical difference (discrete-time derivative) of output, i.e., y_aug = [y; (y-y_prev)/sys.Ts] To add both an integrator and a differentiator to a SISO system, use\n\nGd = add_output_integrator(add_output_differentiator(G), 1)\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_output_integrator","page":"Home","title":"RobustAndOptimalControl.add_output_integrator","text":"addoutputintegrator(sys::StateSpace{<:Discrete}, ind = 1; ϵ = 0)\n\nAugment the output of sys with the integral of output at index ind, i.e.,  y_aug = [y; ∫y[ind]] To add both an integrator and a differentiator to a SISO system, use\n\nGd = add_output_integrator(add_output_differentiator(G), 1)\n\nNote: numerical integration is subject to numerical drift. If the output of the system corresponds to, e.g., a velocity reference and the integral to position reference, consider methods for mitigating this drift.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}","page":"Home","title":"RobustAndOptimalControl.add_resonant_disturbance","text":"add_resonant_disturbance(sys::StateSpace{Continuous}, ω, ζ, Ai::Int; measurement = false)\n\nAugment sys with a resonant disturbance model.\n\nArguments:\n\nω: Frequency\nζ: Relative damping.\nAi: The affected state\nmeasurement: If true, the disturbace is acting on the output, this will cause the controller to have zeros at ω (roots of poly s² + 2ζωs + ω²). If false, the disturbance is acting on the input, this will cause the controller to have poles at ω (roots of poly s² + 2ζωs + ω²).\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.baltrunc2-Tuple{ControlSystems.LTISystem}","page":"Home","title":"RobustAndOptimalControl.baltrunc2","text":"baltrunc2(sys::LTISystem; residual=false, n=missing, kwargs...)\n\nCompute the a balanced truncation of order n and the hankel singular values\n\nFor keyword arguments, see the docstring of DescriptorSystems.gbalmr, reproduced below\n\ngbalmr(sys, balance = false, matchdc = false, ord = missing, atolhsv = 0, rtolhsv = nϵ, \n       atolmin = atolhsv, rtolmin = rtolhsv, \n       atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true) -> (sysr, hs)\n\nCompute for a proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a reduced order realization sysr = (Ar-λEr,Br,Cr,Dr) and the vector hs of decreasingly  ordered Hankel singular values of the system sys. If balance = true, a balancing-based approach is used to determine a reduced order minimal realization  of the form sysr = (Ar-λI,Br,Cr,Dr). For a continuous-time system sys, the resulting realization sysr is balanced, i.e., the controllability and observability grammians are equal and diagonal.  If additonally matchdc = true, the resulting sysr is computed using state rezidualization formulas  (also known as singular perturbation approximation) which additionally preserves the DC-gain of sys.  In this case, the resulting realization sysr is balanced (for both continuous- and discrete-time systems). If balance = false, an enhanced accuracy balancing-free approach is used to determine the  reduced order system sysr. \n\nIf ord = nr, the resulting order of sysr is min(nr,nrmin), where nrmin is the order of a minimal   realization of sys determined as the number of Hankel singular values exceeding max(atolmin,rtolmin*HN), with HN, the Hankel norm of G(λ). If ord = missing, the resulting order is chosen as the number of Hankel  singular values exceeding max(atolhsv,rtolhsv*HN). \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nIf E is singular, the uncontrollable infinite eigenvalues of the pair (A,E) and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. \n\nMethod:  For the order reduction of a standard system, the balancing-free method of [1] or  the balancing-based method of [2] are used. For a descriptor system the balancing related order reduction  methods of [3] are used. To preserve the DC-gain of the original system, the singular perturbation  approximation method of [4] is used in conjunction with the balancing-based or balancing-free approach of [5]. \n\nReferences\n\n[1] A. Varga.      Efficient minimal realization procedure based on balancing.     In A. El Moudni, P. Borne, and S.G. Tzafestas (Eds.),      Prepr. of the IMACS Symp. on Modelling and Control of Technological      Systems, Lille, France, vol. 2, pp.42-47, 1991.\n\n[2] M. S. Tombs and I. Postlethwaite.      Truncated balanced realization of a stable non-minimal state-space      system. Int. J. Control, vol. 46, pp. 1319–1330, 1987.\n\n[3] T. Stykel.      Gramian based model reduction for descriptor systems.      Mathematics of Control, Signals, and Systems, 16:297–319, 2004.\n\n[4] Y. Liu Y. and B.D.O. Anderson      Singular Perturbation Approximation of Balanced Systems,     Int. J. Control, Vol. 50, pp. 1379-1405, 1989.\n\n[5] Varga A.     Balancing-free square-root algorithm for computing singular perturbation approximations.     Proc. 30-th IEEE CDC,  Brighton, Dec. 11-13, 1991, Vol. 2, pp. 1062-1065.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}","page":"Home","title":"RobustAndOptimalControl.bilinearc2d","text":"bilinearc2d(Ac::AbstractArray, Bc::AbstractArray, Cc::AbstractArray, Dc::AbstractArray, Ts::Number; tolerance=1e-12)\n\nBalanced Bilinear transformation in State-Space. This method computes a discrete time equivalent of a continuous-time system, such that\n\nG_d(z) = s2z[G_c(s)]\n\nin a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||2=||C||2   (iii) Satisfies Gc(s) = z2s[s2z[Gc(s)]] for some map z2s[]\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilinearc2d-Tuple{ControlSystems.StateSpace{ControlSystems.Continuous}, Number}","page":"Home","title":"RobustAndOptimalControl.bilinearc2d","text":"bilinearc2d(sys::StateSpace, Ts::Number)\n\nApplies a Balanced Bilinear transformation to a discrete-time statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{ControlSystems.Continuous}, Number}","page":"Home","title":"RobustAndOptimalControl.bilinearc2d","text":"bilinearc2d(sys::ExtendedStateSpace, Ts::Number)\n\nApplies a Balanced Bilinear transformation to a discrete-time extended statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}","page":"Home","title":"RobustAndOptimalControl.bilineard2c","text":"bilineard2c(Ad::AbstractArray, Bd::AbstractArray, Cd::AbstractArray, Dd::AbstractArray, Ts::Number; tolerance=1e-12)\n\nBalanced Bilinear transformation in State-Space. This method computes a continuous time equivalent of a discrete time system, such that\n\nG_c(z) = z2s[G_d(z)]\n\nin a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||2=||C||2   (iii) Satisfies Gd(z) = s2z[z2s[Gd(z)]] for some map s2z[]\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilineard2c-Tuple{ControlSystems.StateSpace}","page":"Home","title":"RobustAndOptimalControl.bilineard2c","text":"bilineard2c(sys::StateSpace)\n\nApplies a Balanced Bilinear transformation to continuous-time statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.bilineard2c","text":"bilineard2c(sys::ExtendedStateSpace)\n\nApplies a Balanced Bilinear transformation to continuous-time extended statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.blocksort-Tuple{UncertainSS}","page":"Home","title":"RobustAndOptimalControl.blocksort","text":"blocks, M = blocksort(P::UncertainSS)\n\nReturns the block structure of P.Δ as well as P.M permuted according to the sorted block structure. blocks is a vector of vectors with the block structure of perturbation blocks as described by μ-tools, i.e.\n\n[-N, 0] denotes a repeated real block of size N\n[N, 0] denotes a repeated complex block of size N\n[ny, nu] denotes a full complex block of size ny × nu\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.broken_feedback-Tuple{ControlSystems.LTISystem, Any}","page":"Home","title":"RobustAndOptimalControl.broken_feedback","text":"broken_feedback(L, i)\n\nCloses all loops in square MIMO system L except for loops i. Forms L1 in fig 14. of \"An Introduction to Disk Margins\" https://arxiv.org/abs/2003.04771\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.closedloop","page":"Home","title":"RobustAndOptimalControl.closedloop","text":"closedloop(l::LQGProblem, L = lqr(l), K = kalman(l))\n\nClosed-loop system as defined in Glad and Ljung eq. 8.28\n\nThe return value will be the closed loop from reference only, other disturbance signals (B1) are ignored. See feedback for a more advanced option.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.comp_sensitivity-Tuple","page":"Home","title":"RobustAndOptimalControl.comp_sensitivity","text":"See output_comp_sensitivity\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.connect-Tuple{Any}","page":"Home","title":"RobustAndOptimalControl.connect","text":"connect(systems, connections; w1, z1 = (:), verbose = true, kwargs...)\n\nCreate complicated feedback interconnection. \n\nAddition and subtraction nodes are achieved by creating a linear combination node, i.e., a system with a D matrix only.\n\nArguments:\n\nsystems: A vector of named systems to be connected\nconnections: a vector of pairs indicating output => input mappings.\nu1: input mappings  (alternative input argument)\ny1: output mappings (alternative input argument)\nw1: external signals\nz1: outputs (can overlap with y1)\nverbose: Issue warnings for signals that have no connection\n\nExample: The following complicated feedback interconnection\n\n                 yF\n              ┌────────────────────────────────┐\n              │                                │\n    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐\nuF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP\n────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►\n    │       │    │       │   ┌──►         │         │       │    │\n    └───────┘    └───────┘   │  └─────────┘         └───────┘    │\n                             │                                   │\n                             └───────────────────────────────────┘\n\ncan be created by\n\nF = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)\nR = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)\nC = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)\nP = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)\n\naddP = sumblock(\"uP = yF + yC\") # Sum node before P\naddC = sumblock(\"uC = yR - yP\") # Sum node before C\n\nconnections = [\n    :yP => :yP # Output to input\n    :uP => :uP\n    :yC => :yC\n    :yF => :yF\n    :yF => :uR\n    :uC => :uC\n    :yR => :yR\n]\nw1 = [:uF] # External inputs\n\nG = connect([F, R, C, P, addP, addC], connections; w1)\n\nIf an external input is to be connected to multiple points, use a splitter to split up the signal into a set of unique names which are then used in the connections.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.diskmargin","page":"Home","title":"RobustAndOptimalControl.diskmargin","text":"diskmargin(L, σ = 0)\ndiskmargin(L, σ::Real, ω)\n\nCalculate the disk margin of LTI system L. L is supposed to be a loop-transfer function, i.e., it should be square. If L = PC the disk margin for output perturbations is computed, whereas if L = CP, input perturbations are considered. If the method diskmargin(P, C, args...) is used, both are computed.\n\nThe implementation and notation follows \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771\n\nThe margins are aviable as fields of the returned objects, see Diskmargin.\n\nArguments:\n\nL: A loop-transfer function.\nσ: If little is known about the distribution of gain variations then σ = 0 is a reasonable choice as it allows for a gain increase or decrease by the same relative amount. The choice σ < 0 is justified if the gain can decrease by a larger factor than it can increase. Similarly, the choice σ > 0 is justified when the gain can increase by a larger factor than it can decrease. If σ = −1 then the disk margin condition is αmax = inv(MT). This margin is related to the robust stability condition for models with multiplicative uncertainty of the form P (1 + δ). If σ = +1 then the disk margin condition is αmax = inv(MS)\nkwargs: Are sent to the hinfnorm calculation\nω: If a vector of frequencies is supplied, the frequency-dependent disk margin will be computed, see example below.\n\nExample:\n\nL = tf(25, [1,10,10,10])\ndm = diskmargin(L, 0)\nplot(dm) # Plot the disk margin to illustrate maximum allowed simultaneous gain and phase variations.\n\nnyquistplot(L)\nplot!(dm, nyquist=true) # plot a nyquist exclusion disk. The Nyquist curve will be tangent to this disk at `dm.ω0`\nnyquistplot!(dm.f0*L) # If we perturb the system with the worst-case perturbation `f0`, the curve will pass through the critical point -1.\n\n## Frequency-dependent margin\nw = exp10.(LinRange(-2, 2, 500))\ndms = diskmargin(L, 0, w)\nplot(w, dms)\n\nSee also ncfmargin.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Any, AbstractVector, Vararg{Any}}","page":"Home","title":"RobustAndOptimalControl.diskmargin","text":"diskmargin(P::LTISystem, C::LTISystem, σ, w::AbstractVector, args...; kwargs...)\n\nSimultaneuous diskmargin at outputs, inputs and input/output simultaneously of P.  Returns a named tuple with the fields input, output, simultaneous_input, simultaneous_output, simultaneous where input and output represent loop-at-a-time margins, simultaneous_input is the margin for simultaneous perturbations on all inputs and simultaneous is the margin for perturbations on all inputs and outputs simultaneously. See also ncfmargin.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractArray}","page":"Home","title":"RobustAndOptimalControl.diskmargin","text":"diskmargin(L::LTISystem, σ::Real, ω)\n\nCalculate the diskmargin at a particular frequency or vector of frequencies. If ω is a vector, you get a frequency-dependent diskmargin plot if you plot the returned value. See also ncfmargin.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}","page":"Home","title":"RobustAndOptimalControl.expand_symbol","text":"expand_symbol(s::Symbol, n::Int)\n\nTakes a symbol and an integer and returns a vector of symbols with increasing numbers appended to the end. E.g., (:x, 3) -> [:x1, :x2, :x3]\n\nThe short-hand syntax s^n is also available, e.g., :x^3 == expand_symbol(:x, 3).\n\nUseful to create signal names for named systems.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.extended_controller","page":"Home","title":"RobustAndOptimalControl.extended_controller","text":"extended_controller(l::LQGProblem, L = lqr(l), K = kalman(l))\n\nReturns an expression for the controller that is obtained when state-feedback u = -L(xᵣ-x̂) is combined with a Kalman filter with gain K that produces state estimates x̂. The controller is an instance of ExtendedStateSpace where C2 = -L, D21 = L and B2 = K.\n\nThe returned system has inputs [xᵣ; y] and outputs the control signal u. If a reference model R is used to generate state references xᵣ, the controller from e = ry - y -> u is given by\n\nCe = extended_controller(l)\nCe = named_ss(Ce; x = :xC, y = :u, u = [R.y; :y^l.ny]) # Name the inputs of Ce the same as the outputs of `R`.\nconnect([R, Ce]; u1 = R.y, y1 = R.y, w1 = [:ry^l.ny, :y^l.ny], z1=[:u])\n\nSince the negative part of the feedback is built into the returned system, we have\n\nC = observer_controller(l)\nCe = extended_controller(l)\nsystem_mapping(Ce) == -C\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.extended_controller-Tuple{ControlSystems.AbstractStateSpace}","page":"Home","title":"RobustAndOptimalControl.extended_controller","text":"extended_controller(K::AbstractStateSpace)\n\nTakes a controller and returns an ExtendedStateSpace version which has augmented input [r; y] and output y (z output is 0-dim).\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.extended_gangoffour-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.extended_gangoffour","text":"extended_gangoffour(P, C)\n\nReturns a single statespace system that maps \n\nw1 reference or measurement noise\nw2 load disturbance\n\nto\n\nz1 control error\nz2 control input\n\n      z1          z2\n      ▲  ┌─────┐  ▲      ┌─────┐\n      │  │     │  │      │     │\nw1──+─┴─►│  C  ├──┴───+─►│  P  ├─┐\n    │    │     │      │  │     │ │\n    │    └─────┘      │  └─────┘ │\n    │                 w2         │\n    └────────────────────────────┘\n\nThe returned system has the transfer-function matrix\n\nbeginbmatrix\nI  C\nendbmatrix (I + PC)^-1 beginbmatrix\nI  P\nendbmatrix\n\nThe gang of four can be plotted like so\n\nGcl = extended_gangoffour(G, C) # Form closed-loop system\nbodeplot(Gcl, lab=[\"S\" \"CS\" \"PS\" \"T\"], plotphase=false) |> display # Plot gang of four\n\nNote, the last output of Gcl is the negative of the CS and PS transfer functions from gangoffour2. See glover_mcfarlane for an extended example. See also ncfmargin.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{ControlSystems.StateSpace{<:Any, <:MonteCarloMeasurements.AbstractParticles{<:Any, N}}, Any}, Tuple{ControlSystems.StateSpace{<:Any, <:MonteCarloMeasurements.AbstractParticles{<:Any, N}}, Any, F}} where {N, F}","page":"Home","title":"RobustAndOptimalControl.find_lft","text":"l = find_lft(sys::StateSpace{<:Any, <:StaticParticles{<:Any, N}}, δ) where N\n\nGiven an systems sys with uncertain coefficients in the form of StaticParticles, find a lower linear fractional transformation M such that lft(M, δ) ≈ sys. \n\nδ can be either the source of uncertainty in sys, i.e., a vector of the unique uncertain parameters that were used to create sys. These should be constructed as uniform randomly distributed particles for most robust-control theory to be applicable.  δ can also be an integer, in which case a numer of δ sources of uncertainty are automatically created. This could be used for order reduction if the number of uncertainty sources in sys is large.\n\nNote, uncertainty in sys is only supported in A and B, C and D must be deterministic.\n\nReturns l::LFT that internaly contains all four blocks of M as well as δ. Call ss(l,sys) do obtain lft(M, δ) ≈ sys.\n\nCall Matrix(l) to obtain M = [M11 M12; M21 M22]\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.fit_complex_perturbations-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.fit_complex_perturbations","text":"centers, radii = fit_complex_perturbations(P, w; relative=true, nominal=:mean)\n\nFor each frequency in w, fit a circle in the complex plane that contains all models in the model set P, represented as an LTISystem with Particles coefficients. Note, the resulting radii can be quite unstable if the number of particles is small, in particular if the particles are normally distributed instead of uniformly.\n\nIf realtive = true, circles encompassing |(P - Pn)/Pn| will be returned (multiplicative/relative uncertainty). If realtive = false, circles encompassing |P - Pn| will be returned (additive uncertainty).\n\nIf nominal = :mean, the mean of P will be used as nominal model. If nominal = :first, the first particle will be used. See MonteCarloMeasurements.with_nominal to set the nominal value in the first particle. \n\nSee also nyquistcircles to plot circles (only if relative=false).\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.frequency_weighted_reduction","page":"Home","title":"RobustAndOptimalControl.frequency_weighted_reduction","text":"frequency_weighted_reduction(G, Wo, Wi; residual=true)\n\nFind Gr such that ||Wₒ(G-Gr)Wᵢ||∞ is minimized. For a realtive reduction, set Wo = inv(G) and Wi = I.\n\nIf residual = true, matched static gain is achieved through \"residualization\", i.e., setting\n\n0 = A_21x_1 + A_22x_2 + B_2u\n\nwhere indices 1/2 correspond to the remaining/truncated states respectively. This choice typically results in a better match in the low-frequency region and a smaller overall error.\n\nRef: Andras Varga and Brian D.O. Anderson, \"Accuracy enhancing methods for the frequency-weighted balancing related model reduction\" https://elib.dlr.de/11746/1/varga_cdc01p2.pdf\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.gain_and_delay_uncertainty-Tuple{Any, Any, Any}","page":"Home","title":"RobustAndOptimalControl.gain_and_delay_uncertainty","text":"gain_and_delay_uncertainty(kmin, kmax, Lmax)\n\nReturn a multiplicative weight to represent the uncertainty coming from neglecting the dynamics k*exp(-s*L) where k ∈ [kmin, kmax] and L ≤ Lmax. This weight is slightly optimistic, an expression for a more exact weight appears in eq (7.27), \"Multivariable Feedback Control: Analysis and Design\"\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.glover_mcfarlane","page":"Home","title":"RobustAndOptimalControl.glover_mcfarlane","text":"K, γ, info = glover_mcfarlane(G::AbstractStateSpace{Continuous}, γ = 1.1)\n\nDesign a controller for G that maximizes the stability margin ϵ = 1/γ with normalized coprime factor uncertainty using the method of Glover and McFarlane\n\nγ = 1/ϵ = ||[K;I] inv(I-G*K)*inv(M)||∞\nG = inv(M + ΔM)*(N + ΔN)\n\nγ is given as a relative factor above γmin and must be greater than 1, i.e., if γ = 1.1, the controller will be designed for γ = 1.1*γmin.\n\nWe want γmin (which is always ≥ 1) as small as possible, and we usually require that γmin is less than 4, corresponding to 25% allowed coprime uncertainty.\n\nPerformance modeling is incorporated in the design by calling glover_mcfarlane on the shaped system W2*G*W1 and then forming the controller as W1*K*W2. Using this formulation, traditional loop shaping can be done on W2*G*W1.\n\nExample:\n\nExample 9.3 from the reference below.\n\nusing RobustAndOptimalControl, ControlSystems, Plots, Test\nG = tf(200, [10, 1])*tf(1, [0.05, 1])^2     |> ss\nGd = tf(100, [10, 1])                       |> ss\nW1 = tf([1, 2], [1, 1e-6])                  |> ss\nK, γ, info = glover_mcfarlane(G, 1.1; W1)\n@test info.γmin ≈ 2.34 atol=0.005\nGcl = extended_gangoffour(G, K) # Form closed-loop system\n\nbodeplot([G, info.Gs, G*K], lab=[\"G\" \"\" \"G scaled\" \"\" \"Loop transfer\"]) |> display\nbodeplot(Gcl, lab=[\"S\" \"KS\" \"PS\" \"T\"], plotphase=false) |> display # Plot gang of four\n\nplot( step(Gd*feedback(1, info.Gs), 3), lab=\"Initial controller\")\nplot!(step(Gd*feedback(1, G*K), 3), lab=\"Robustified\") |> display\n\nnyquistplot([info.Gs, G*K], ylims=(-2,1), xlims=(-2, 1),\n    Ms_circles = 1.5,\n    lab = [\"Initial controller\" \"Robustified\"],\n    title = \"Loop transfers with and without robustified controller\"\n    ) |> display\n\nRef: Sec 9.4.1 of Skogestad, \"Multivariable Feedback Control: Analysis and Design\"\n\nExtended help\n\nSkogestad gives the following general advice:\n\nScale the plant outputs and inputs. This is very important for most design  procedures and is sometimes forgotten. In general, scaling improves the  conditioning of the design problem, it enables meaningful analysis to be made  of the robustness properties of the feedback system in the frequency domain,  and for loop-shaping it can simplify the selection of weights. There are a variety  of methods available including normalization with respect to the magnitude of  the maximum or average value of the signal in question. If one is to go straight to a design the following variation has  proved useful in practice:  (a) The outputs are scaled such that equal magnitudes of cross-coupling into each      of the outputs is equally undesirable.  (b) Each input is scaled by a given percentage (say 10%) of its expected range      of operation. That is, the inputs are scaled to reflect the relative actuator      capabilities. An example of this type of scaling is given in the aero-engine      case study of Chapter 12.\nOrder the inputs and outputs so that the plant is as diagonal as possible. The  relative gain array rga can be useful here. The purpose of this pseudo-diagonalization  is to ease the design of the pre- and post-compensators which, for simplicity, will  be chosen to be diagonal.\nNext, we discuss the selection of weights to obtain the shaped plant G_s = W_2 G W_1  where W_1 = W_p W_a W_g\nSelect the elements of diagonal pre- and post-compensators W_p and W_2 so that  the singular values of W_2 G W_p are desirable. This would normally mean high  gain at low frequencies, roll-off rates of approximately 20 dB/decade (a slope of  about 1) at the desired bandwidth(s), with higher rates at high frequencies. Some  trial and error is involved here. W_2 is usually chosen as a constant, reflecting the  relative importance of the outputs to be controlled and the other measurements  being fed back to the controller. For example, if there are feedback measurements  of two outputs to be controlled and a velocity signal, then W_2 might be chosen  to be diag([1, 1, 0.1]), where 0.1 is in the velocity signal channel. W_p contains the  dynamic shaping. Integral action, for low frequency performance; phase-advance  for reducing the roll-off rates at crossover, and phase-lag to increase the roll-off  rates at high frequencies should all be placed in W_p if desired. The weights should  be chosen so that no unstable hidden modes are created in G_s.\nOptional: Introduce an additional gain matrix W_g cascaded with W_a to provide  control over actuator usage. W_g is diagonal and is adjusted so that actuator rate  limits are not exceeded for reference demands and typical disturbances on the  scaled plant outputs. This requires some trial and error.\nRobustly stabilize the shaped plant G_s = W_2 G W_1 , where W_1 = W_p W_a W_g,  using glover_mcfarlane. First, the maximum stability  margin ϵ_max = 1γ_min is calculated. If the margin is too small, ϵmax  025, then go back and modify the weights. Otherwise, a γ-suboptimal controller is synthesized. There is usually no advantage to be gained by using the optimal controller. When ϵ_max > 0.25  (respectively γ_min < 4) the design is usually successful. In this case, at least  25% coprime factor uncertainty is allowed, and we also find that the shape of the  open-loop singular values will not have changed much after robust stabilization.  A small value of ϵmax indicates that the chosen singular value loop-shapes are  incompatible with robust stability requirements. That the loop-shapes do not  change much following robust stabilization if γ is small (ϵ large), is justified  theoretically in McFarlane and Glover (1990).\nAnalyze the design and if all the specifications are not met make further  modifications to the weights.\nImplement the controller. The configuration shown in below has been found  useful when compared with the conventional set up. This is because  the references do not directly excite the dynamics of K, which can result in large amounts of overshoot (classical derivative kick). The constant prefilter ensures a steady-state gain of 1 between r and y, assuming integral action in W_1 or G (note, the K returned by this function has opposite sign compared to that of Skogestad, so we use negative feedback here).\n\nAnti-windup can be added to W_1 but putting W_1 on Hanus form after the synthesis, see hanus.\n\n       ┌─────────┐      ┌────────┐      ┌────────┐\n    r  │         │    us│        │  u   │        │  y\n   ───►│(K*W2)(0)├──+──►│   W1   ├─────►│   G    ├────┬──►\n       │         │  │-  │        │      │        │    │\n       └─────────┘  │   └────────┘      └────────┘    │\n                    │                                 │\n                    │                                 │\n                    │   ┌────────┐      ┌────────┐    │\n                    │   │        │  ys  │        │    │\n                    └───┤   K    │◄─────┤   W2   │◄───┘\n                        │        │      │        │\n                        └────────┘      └────────┘\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.h2norm-Tuple{ControlSystems.LTISystem}","page":"Home","title":"RobustAndOptimalControl.h2norm","text":"n = h2norm(sys::LTISystem; kwargs...)\n\nA numerically robust version of norm using DescriptorSystems.jl\n\nFor keyword arguments, see the docstring of DescriptorSystems.gh2norm, reproduced below\n\ngh2norm(sys, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atolinf = atol, rtol = n*ϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) the H2 norm of its transfer function  matrix G(λ). The H2 norm is infinite, if sys has unstable poles, or, for a continuous-time, the system has nonzero gain at infinity. To check the stability, the eigenvalues of the pole pencil A-λE must have real parts less  than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system, where β is the stability domain boundary offset. The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The keyword argument atolinf is the absolute tolerance for the gain of G(λ) at λ = ∞.  The used default value is atolinf = 0.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol.  \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.h2synthesize","page":"Home","title":"RobustAndOptimalControl.h2synthesize","text":"K, Cl = h2synthesize(P::ExtendedStateSpace, γ = nothing)\n\nSynthesize H₂-optimal controller K and calculate the closed-loop transfer function from w to z. Ref: Cha. 14.5 in Robust and Optimal Control.\n\nIf γ = nothing, use the formulas for H₂ in Ch 14.5. If γ is a large value, the H∞ formulas are used. As γ → ∞, these two are equivalent. The h∞ formulas do a coordinate transfromation that handles slightly more general systems so if you run into an error, it might be worth trying setting γ to something large, e.g., 1000.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.hankelnorm-Tuple{ControlSystems.LTISystem}","page":"Home","title":"RobustAndOptimalControl.hankelnorm","text":"n, hsv = hankelnorm(sys::LTISystem; kwargs...)\n\nCompute the hankelnorm and the hankel singular values\n\nFor keyword arguments, see the docstring of DescriptorSystems.ghanorm, reproduced below\n\nghanorm(sys, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (hanorm, hs)\n\nCompute for a proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), the Hankel norm hanorm = small G(lambda)_H and the vector of Hankel singular values hs of the system.\n\nFor a proper system with E singular, the uncontrollable infinite eigenvalues of the pair (A,E) and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hanus-Tuple{Any}","page":"Home","title":"RobustAndOptimalControl.hanus","text":"Wh = hanus(W)\n\nReturn Wh on Hanus form. Wh has twice the number of inputs, where the second half of the inputs are \"actual inputs\", e.g., potentially saturated. This is used to endow W with anti-windup protection. W must have an invertable D matrix and be minimum phase.\n\nRef: Sec 9.4.5 of Skogestad, \"Multivariable Feedback Control: Analysis and Design\"\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.hinfassumptions","text":"flag = hinfassumptions(P::ExtendedStateSpace; verbose=true)\n\nCheck the assumptions for using the γ-iteration synthesis in Theorem 1.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfgrad-Tuple{Any, Any, Any}","page":"Home","title":"RobustAndOptimalControl.hinfgrad","text":"∇A, ∇B, ∇C, ∇D, hn, ω = hinfgrad(sys; rtolinf=1e-8, kwargs...)\n∇A, ∇B, ∇C, ∇D        = hinfgrad(sys, hn, ω)\n\nCompute the gradient of the H∞ norm w.r.t. the statespace matrices A,B,C,D. If only a system is provided, the norm hn and the peak frequency ω are automatically calculated. kwargs are sent to hinfnorm2. Note, the default tolerance to which the norm is calculated is set smaller than default for hinfnorm2, gradients will be discontinuous with any non-finite tolerance, and sensitive optimization algorithms may require even tighter tolerance.\n\nIn cases where the maximum singular value is reached at more than one frequency, a random frequency is used.\n\nIf the system is unstable, the gradients are NaN. Strategies to find an initial stabilizing controllers are outlined in Apkarian and D. Noll, \"Nonsmooth H∞ Synthesis\" in IEEE Transactions on Automatic Control.\n\nAn rrule for ChainRules is defined using this function, so hn is differentiable with any AD package that derives its rules from ChainRules (only applies to the hn return value, not ω).\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfnorm2-Tuple{ControlSystems.LTISystem}","page":"Home","title":"RobustAndOptimalControl.hinfnorm2","text":"n, ω = hinfnorm2(sys::LTISystem; kwargs...)\n\nA numerically robust version of hinfnorm using DescriptorSystems.jl\n\nFor keyword arguments, see the docstring of DescriptorSystems.ghinfnorm, reproduced below\n\nghinfnorm(sys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (hinfnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function  matrix G(λ)  the H∞ norm hinfnorm (i.e.,  the peak gain of G(λ)) and  the corresponding peak frequency fpeak, where the peak gain is achieved.  The H∞ norm is infinite if the pole pencil A-λE has unstable zeros (i.e., sys has unstable poles).  To check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system, where β is the stability domain boundary offset. The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword argument rtolinf specifies the relative accuracy for the computed infinity norm.  The  default value used for rtolinf is 0.001.\n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon   and n is the order of the system sys.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfpartition-NTuple{4, Any}","page":"Home","title":"RobustAndOptimalControl.hinfpartition","text":"P = hinfpartition(G, WS, WU, WT)\n\nTransform a SISO or MIMO system G, with weighting functions WS, WU, WT into an LFT with an isolated controller, and write the resulting system, P(s), on a state-space form. Valid inputs for G are transfer functions (with dynamics, can be both MIMO and SISO, both in tf and ss forms). Valid inputs for the weighting functions are empty arrays, numbers (static gains), and LTISystems.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, ControlSystems.LTISystem, ControlSystems.LTISystem}","page":"Home","title":"RobustAndOptimalControl.hinfsignals","text":"hinfsignals(P::ExtendedStateSpace, G::LTISystem, C::LTISystem)\n\nUse the extended state-space model, a plant and the found controller to extract the closed loop transfer functions.\n\nPcl : w → z : From input to the weighted functions\nS   : w → e : From input to error\nCS  : w → u : From input to control\nT   : w → y : From input to output\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.hinfsynthesize","text":"flag, K, γ, mats = hinfsynthesize(P::ExtendedStateSpace; maxIter = 20, interval = (2 / 3, 20), verbose = false, tolerance = 1.0e-10, γrel = 1.01)\n\nComputes an H-infinity optimal controller K for an extended plant P such that ||F_l(P, K)||∞ < γ for the smallest possible γ given P. The routine is known as the γ-iteration, and is based on the paper \"State-space formulae for all stabilizing controllers that satisfy an H∞-norm bound and relations to risk sensitivity\" by Glover and Doyle.\n\nArguments:\n\nmaxIter: Maximum number of γ iterations\ninterval: The starting interval for the bisection.\nverbose: Print progress?\ntolerance: Stop when the interval is this small.\nγrel: If γrel > 1, the optimal γ will be found by γ iteration after which a controller will be designed for γ = γopt * γrel. It is often a good idea to design a slightly suboptimal controller, both for numerical reasons, but also since the optimal controller may contain very fast dynamics. If γrel → ∞, the computed controller will approach the 𝑯₂ optimal controller. Getting a mix between 𝑯∞ and 𝑯₂ properties is another reason to choose γrel > 1.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hsvd-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}}","page":"Home","title":"RobustAndOptimalControl.hsvd","text":"hsvd(sys::AbstractStateSpace{Continuous})\n\nReturn the Hankel singular values of sys, computed as the eigenvalues of QP Where Q and P are the Gramians of sys.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.input_comp_sensitivity","text":"input_comp_sensitivity(P,C)\ninput_comp_sensitivity(l::LQGProblem)\n\nTransfer function from load disturbance to control signal.\n\n\"Input\" signifies that the transfer function is from the input of the plant.\n\"Complimentary\" signifies that the transfer function is to an output (in this case controller output)\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.input_sensitivity","text":"input_sensitivity(P, C)\ninput_sensitivity(l::LQGProblem)\n\nTransfer function from load disturbance to total plant input.\n\n\"Input\" signifies that the transfer function is from the input of the plant.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}","page":"Home","title":"RobustAndOptimalControl.loop_diskmargin","text":"loop_diskmargin(P, C, args...; kwargs...)\n\nCalculate the loop-at-a-time diskmargin for each output and input of P. See also diskmargin, sim_diskmargin. Ref: \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, Vararg{Any}}","page":"Home","title":"RobustAndOptimalControl.loop_diskmargin","text":"loop_diskmargin(L, args...; kwargs...)\n\nCalculate the loop-at-a-time diskmargin for each output of L.\n\nSee also diskmargin, sim_diskmargin. Ref: \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.loop_scale","page":"Home","title":"RobustAndOptimalControl.loop_scale","text":"loop_scale(L::LTISystem, w = 0)\n\nFind the optimal diagonal scaling matrix D such that D\\L(iw)*D has a minimized condition number at frequency w. Applicable to square L only. Use loop_scaling to obtain D.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.loop_scaling","page":"Home","title":"RobustAndOptimalControl.loop_scaling","text":"loop_scaling(M0::Matrix, tol = 0.0001)\n\nFind the optimal diagonal scaling matrix D such that D\\M0*D has a minimized condition number. Applicable to square M0 only. See also structured_singular_value with option dynamic=true. Use loop_scale to find and apply the scaling to a loop-transfer function.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.makeweight-Tuple{Any, Number, Any}","page":"Home","title":"RobustAndOptimalControl.makeweight","text":"makeweight(low, f_mid, high)\nmakeweight(low, (f_mid, gain_mid), high)\n\nCreate a weighting function that goes from gain low at zero frequency, through gain gain_mid to gain high at ∞\n\nArguments:\n\nlow: A number specifying the DC gain \nmid: A number specifying the frequency at which the gain is 1, or a tuple (freq, gain). If gain_mid is not specified, the geometric mean of high and low is used.\nhigh: A number specifying the gain at ∞\n\nusing ControlSystems, Plots\nW = makeweight(10, (5,2), 1/10)\nbodeplot(W)\nhline!([10, 2, 1/10], l=(:black, :dash), primary=false)\nvline!([5], l=(:black, :dash), primary=false)\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}","page":"Home","title":"RobustAndOptimalControl.measure","text":"measure(s::NamedStateSpace, names)\n\nReturn a system with specified states as measurement outputs.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.muplot","page":"Home","title":"RobustAndOptimalControl.muplot","text":"muplot(sys, args...; hz=false)\nmuplot(LTISystem[sys1, sys2...], args...; hz=false)\n\nPlot the structured singular values of the frequency response of the LTISystem(s). This plot is similar to sigmaplot, but scales the loop-transfer function to minimize the maximum singular value. Only applicable to square systems. A frequency vector w can be optionally provided.\n\nIf hz=true, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.\n\nkwargs is sent as argument to Plots.plot.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.mvnyquistplot","page":"Home","title":"RobustAndOptimalControl.mvnyquistplot","text":"fig = mvnyquistplot(sys, w;  unit_circle=true, hz = false, kwargs...)\n\nCreate a Nyquist plot of the LTISystem. A frequency vector w must be provided.\n\nunit_circle: if the unit circle should be displayed\n\nIf hz=true, the hover information will be displayed in Hertz, the input frequency vector is still treated as rad/s.\n\nkwargs is sent as argument to plot.\n\nExample\n\nw = 2π .* exp10.(LinRange(-2, 2, 500))\nW = makeweight(0.40, 15, 3) # frequency weight for uncertain dynamics\nPn = tf(1, [1/60, 1]) |> ss # nominal plant\nd = δss(1,1)                # Uncertain dynamics\n\nPd = Pn*(I(1) + W*d)        # weighted dynamic uncertainty on the input of Pn\nPp = rand(Pd, 200)          # sample the uncertain plant\nGcl = lft(Pd, ss(-1))       # closed loop system\nstructured_singular_value(Gcl) # larger than 1 => not robustly stable\nunsafe_comparisons(true)\nmvnyquistplot(Pp, w, points=true) # MV Nyquist plot encircles origin for some samples => not robustly stable\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T","page":"Home","title":"RobustAndOptimalControl.named_ss","text":"named_ss(sys::AbstractStateSpace{T}; x, u, y)\n\nCreate a NamedStateSpace system. This kind of system uses names rather than integer indices to refer to states, inputs and outputs\n\nArguments:\n\nsys: A system to add names to.\nx: A list of symbols with names of the states.\nu: A list of symbols with names of the inputs.\ny: A list of symbols with names of the outputs.\n\nDefault names of signals if none are provided are x,u,y.\n\nExample\n\nG1 = ss(1,1,1,0)\nG2 = ss(1,1,1,0)\ns1 = named_ss(G1, x = :x, u = :u1, y=:y1)\ns2 = named_ss(G2, x = :z, u = :u2, y=:y2)\n\ns1[:y1, :u1] # Index using symbols\n\nfb = feedback(s1, s2, r = :r) # \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.ncfmargin-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.ncfmargin","text":"m, ω = ncfmargin(P, K)\n\nNormalized coprime factor margin, defined has the inverse H∞ norm of\n\nbeginbmatrix\nI  K\nendbmatrix (I + PK)^-1 beginbmatrix\nI  P\nendbmatrix\n\nA margin ≥ 0.25-0.3 is a reasonable for robustness. \n\nIf controller K stabilizes P with margin m, then K will also stabilize P̃ if nugap(P, P̃) < m.\n\nSee also extended_gangoffour, diskmargin.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.neglected_delay-Tuple{Any}","page":"Home","title":"RobustAndOptimalControl.neglected_delay","text":"neglected_delay(Lmax)\n\nReturn a multiplicative weight to represent the uncertainty coming from neglecting the dynamics exp(-s*L) where L ≤ Lmax. \"Multivariable Feedback Control: Analysis and Design\" Ch 7.4.5\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.neglected_lag-Tuple{Any}","page":"Home","title":"RobustAndOptimalControl.neglected_lag","text":"neglected_lag(τmax)\n\nReturn a multiplicative weight to represent the uncertainty coming from neglecting the dynamics 1/(s*τ + 1) where τ ≤ τmax. \"Multivariable Feedback Control: Analysis and Design\" Ch 7.4.5\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.noise_mapping-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.noise_mapping","text":"noise_mapping(P::ExtendedStateSpace)\n\nReturn the system from w -> y\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.nugap-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem}","page":"Home","title":"RobustAndOptimalControl.nugap","text":"nugap(sys0::LTISystem, sys1::LTISystem; kwargs...)\n\nCompute the ν-gap metric between two systems. See also ncfmargin.\n\nFor keyword arguments, see the docstring of DescriptorSystems.gnugap, reproduced below\n\ngnugap(sys1, sys2; freq = ω, rtolinf = 0.00001, fast = true, offset = sqrt(ϵ), \n       atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (nugapdist, fpeak)\n\nCompute the ν-gap distance nugapdist between two descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) and the corresponding frequency fpeak (in rad/TimeUnit), where the ν-gap  distance achieves its peak value. \n\nIf freq = missing, the resulting nugapdist satisfies 0 <= nugapdist <= 1.  The value nugapdist = 1 results, if the winding number is different of zero in which case fpeak = []. \n\nIf freq = ω, where ω is a given vector of real frequency values, the resulting nugapdist is a vector  of pointwise ν-gap distances of the dimension of ω, whose components satisfies 0 <= maximum(nugapdist) <= 1.  In this case, fpeak is the frequency for which the pointwise distance achieves its peak value.  All components of nugapdist are set to 1 if the winding number is different of zero in which case fpeak = [].\n\nThe stability boundary offset, β, to be used to assess the finite zeros which belong to the boundary of the stability domain can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system, these are the finite zeros having  real parts within the interval [-β,β], while for a discrete-time system,  these are the finite zeros having moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nPencil reduction algorithms are employed to compute range and coimage spaces  which perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, A2, B1, B2, C1, C2, D1 and D2, the absolute tolerance for the nonzero elements of E1 and E2,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximum of the orders of the systems sys1 and sys2.  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol. \n\nThe keyword argument rtolinf specifies the relative accuracy to be used  to compute the ν-gap as the infinity norm of the relevant system according to [1].  The default value used for rtolinf is 0.00001.\n\nMethod: The evaluation of ν-gap uses the definition proposed in [1], extended to generalized LTI (descriptor) systems. The computation of winding number is based on enhancements covering zeros on the boundary of the  stability domain and infinite zeros.\n\nReferences:\n\n[1] G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.output_comp_sensitivity","text":"output_comp_sensitivity(P,C)\noutput_comp_sensitivity(l::LQGProblem)\n\nTransfer function from measurement noise / reference to plant output.\n\n\"output\" signifies that the transfer function is from the output of the plant.\n\"Complimentary\" signifies that the transfer function is to an output (in this case plant output)\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.output_sensitivity","text":"output_sensitivity(P, C)\noutput_sensitivity(l::LQGProblem)\n\nTransfer function from measurement noise / reference to control signal.\n\n\"output\" signifies that the transfer function is from the output of the plant.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace, Int64, Int64}","page":"Home","title":"RobustAndOptimalControl.partition","text":"partition(P::AbstractStateSpace, nw::Int, nz::Int)\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}","page":"Home","title":"RobustAndOptimalControl.partition","text":"partition(P::AbstractStateSpace; u, y, w=!u, z=!y)\n\nPartition P into an ExtendedStateSpace.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.performance_mapping-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.performance_mapping","text":"performance_mapping(P::ExtendedStateSpace)\n\nReturn the system from w -> z\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}","page":"Home","title":"RobustAndOptimalControl.robstab","text":"robstab(M0::UncertainSS, w=exp10.(LinRange(-3, 3, 1500)); kwargs...)\n\nReturn the robust stability margin of an uncertain model, defined as the inverse of the structured singular value. Currently, only diagonal complex perturbations supported.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.sensitivity-Tuple","page":"Home","title":"RobustAndOptimalControl.sensitivity","text":"See output_sensitivity\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.show_construction-Tuple{IO, ControlSystems.LTISystem}","page":"Home","title":"RobustAndOptimalControl.show_construction","text":"show_construction([io::IO,] sys::LTISystem; name = \"temp\", letb = true)\n\nPrint code to io that reconstructs sys.\n\nletb: If true, the code is surrounded by a let block.\n\njulia> sys = ss(tf(1, [1, 1]))\nStateSpace{Continuous, Float64}\nA = \n -1.0\nB = \n 1.0\nC = \n 1.0\nD = \n 0.0\n\nContinuous-time state-space model\n\njulia> show_construction(sys, name=\"Jörgen\")\nsys = let\n    JörgenA = [-1.0;;]\n    JörgenB = [1.0;;]\n    JörgenC = [1.0;;]\n    JörgenD = [0.0;;]\n    ss(JörgenA, JörgenB, JörgenC, JörgenD)\nend\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.sim_diskmargin","page":"Home","title":"RobustAndOptimalControl.sim_diskmargin","text":"sim_diskmargin(L, σ::Real = 0)\n\nReturn the smallest simultaneous diskmargin over the grid 1e-3:1e3 See also ncfmargin.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.sim_diskmargin-2","page":"Home","title":"RobustAndOptimalControl.sim_diskmargin","text":"sim_diskmargin(P::LTISystem, C::LTISystem, σ::Real = 0)\n\nSimultaneuous diskmargin at both outputs and inputs of P. Ref: \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771 See also ncfmargin.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.sim_diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractVector}","page":"Home","title":"RobustAndOptimalControl.sim_diskmargin","text":"sim_diskmargin(L, σ::Real, w::AbstractVector)\nsim_diskmargin(L, σ::Real = 0)\n\nSimultaneuous diskmargin at the outputs of L.  Uses should consider using diskmargin.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.specificationplot","page":"Home","title":"RobustAndOptimalControl.specificationplot","text":"specificationplot([S,CS,T], [WS,WU,WT])\n\nThis function visualizes the control synthesis using the hInf_synthesize with the three weighting functions {WS(jω), WU(jω), WT(jω)} inverted and scaled by γ, against the corresponding transfer fucntions {S(jω), C(jω)S(jω), T(jω)}, to verify visually that the specifications are met. This may be run using both MIMO and SISO systems.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.structured_singular_value-Tuple{ControlSystems.LTISystem, AbstractVector}","page":"Home","title":"RobustAndOptimalControl.structured_singular_value","text":"structured_singular_value(M0::UncertainSS, [w::AbstractVector]; kwargs...)\n\nw: Frequency vector, if none is provided, the maximum μ over a brid 1e-3 : 1e3 will be returned.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Home","title":"RobustAndOptimalControl.structured_singular_value","text":"μ = structured_singular_value(M; tol=1e-4, scalings=false, dynamic=false)\n\nCompute (an upper bound of) the structured singular value μ for diagonal Δ of complex perturbations (other structures of Δ are not yet supported). M is assumed to be an (n × n × N_freq) array or a matrix.\n\nWe currently don't have any methods to compute a lower bound, but if all perturbations are complex the spectral radius ρ(M) is always a lower bound (usually not a good one).\n\nIf scalings = true, return also a n × nf matrix Dm with the diagonal scalings D such that\n\nD = Diagonal(Dm[:, i])\nσ̄(D\\M[:,:,i]*D)\n\nis minimized.\n\nIf dynamic = true, the perturbations are assumed to be time-varying Δ(t). In this case, the same scaling is used for all frequencies and the returned D if scalings=true is a vector d such that D = Diagonal(d).\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.sumblock-Tuple{String}","page":"Home","title":"RobustAndOptimalControl.sumblock","text":"sumblock(ex::String; Ts = 0, n = 1)\n\nCreate a summation node that sums (or subtracts) vectors of length n.\n\nArguments:\n\nTs: Sample time\nn: The length of the input and output vectors. Set n=1 for scalars.\n\nExamples:\n\njulia> sumblock(\"uP = vf + yL\")\nNamedStateSpace{Continuous, Int64}\nD = \n 1  1\n\nWith state  names: \n     input  names: vf yL\n     output names: uP\n\n\njulia> sumblock(\"x_diff = xr - xh\"; n=3)\nNamedStateSpace{Continuous, Int64}\nD = \n 1  0  0  -1   0   0\n 0  1  0   0  -1   0\n 0  0  1   0   0  -1\n\nWith state  names: \n     input  names: xr1 xr2 xr3 xh1 xh2 xh3\n     output names: x_diff1 x_diff2 x_diff3\n     \n\njulia> sumblock(\"a = b + c - d\")\nNamedStateSpace{Continuous, Int64}\nD = \n 1  1  -1\n\nWith state  names: \n     input  names: b c d\n     output names: a\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.system_mapping-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.system_mapping","text":"system_mapping(P::ExtendedStateSpace)\n\nReturn the system from u -> y\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.uss","page":"Home","title":"RobustAndOptimalControl.uss","text":"uss(d::AbstractVector{<:δ}, Ts = nothing)\n\nCreate a diagonal uncertain statespace object with the uncertain elements d on the diagonal.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.uss-2","page":"Home","title":"RobustAndOptimalControl.uss","text":"uss(D::AbstractArray, Δ, Ts = nothing)\n\nIf only a single D matrix is provided, it's treated as D11 if Δ is given, and as D22 if no Δ is provided.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.uss-3","page":"Home","title":"RobustAndOptimalControl.uss","text":"uss(D11, D12, D21, D22, Δ, Ts = nothing)\n\nCreate an uncertain statespace object with only gin matrices.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}","page":"Home","title":"RobustAndOptimalControl.uss","text":"uss(d::δ{C, F}, Ts = nothing)\n\nConvert a δ object to an UncertainSS\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.vec2sys","page":"Home","title":"RobustAndOptimalControl.vec2sys","text":"vec2sys(v::AbstractArray, ny::Int, nu::Int, ts = nothing)\n\nCreate a statespace system from the parameters\n\nv = vec(sys) = [vec(sys.A); vec(sys.B); vec(sys.C); vec(sys.D)]\n\nUse vec(sys) to create v.\n\nThis can be useful in order to convert to and from vectors for, e.g., optimization.\n\njulia> sys  = ss(tf(1, [1, 1]))\nStateSpace{Continuous, Float64}\nA = \n -1.0\nB = \n 1.0\nC = \n 1.0\nD = \n 0.0\n\nContinuous-time state-space model\n\njulia> v    = vec(sys)\n4-element Vector{Float64}:\n -1.0\n  1.0\n  1.0\n  0.0\n\njulia> sys2 = vec2sys(v, sys.ny, sys.nu)\nStateSpace{Continuous, Float64}\nA = \n -1.0\nB = \n 1.0\nC = \n 1.0\nD = \n 0.0\n\nContinuous-time state-space model\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.δc","page":"Home","title":"RobustAndOptimalControl.δc","text":"δc(val::Complex = complex(0.0), radius::Real = 1.0, name)\n\nCreate a complex, uncertain parameter. If no name is given, a boring name will be generated automatically.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.δr","page":"Home","title":"RobustAndOptimalControl.δr","text":"δr(val::Real = 0.0, radius::Real = 1.0, name)\n\nCreate a real, uncertain parameter. If no name is given, a boring name will be generated automatically.\n\n\n\n\n\n","category":"function"},{"location":"uncertainty/#Uncertainty-modeling","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"See example uncertain.jl.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"δc Creates an uncertain complex parameter.\nδr Creates an uncertain real parameter.\nδss (Experimental) Creates an uncertain statespace model.\nneglected_delay\nneglected_lag\ngain_and_delay_uncertainty\nmakeweight\nfit_complex_perturbations","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We provide two general means of modeling uncertainty, the traditional MDelta framework [Skogestad][Doyle91], and a Monte-Carlo approach using MonteCarloMeasurements.jl","category":"page"},{"location":"uncertainty/#Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/MonteCarloMeasurements.jl)","page":"Uncertainty modeling","title":"Parametric uncertainty using MonteCarloMeasurements.jl","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The most straightforward way to model uncertainty is to use uncertain parameters, using tools such as IntervalArithmetic (strict, worst case guarantees) or MonteCarloMeasurements (less strict worst-case analysis or probabilistic). In the following, we show an example with MIMO systems with both parametric uncertainty and diagonal, complex uncertainty, adapted from 8.11.3 in Skogestad, \"Multivariable Feedback Control: Analysis and Design\". This example is also available as a julia script in uncertain.jl.","category":"page"},{"location":"uncertainty/#Example-in-section-3.7.1,-Spinning-satellite","page":"Uncertainty modeling","title":"Example in section 3.7.1, Spinning satellite","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"using RobustAndOptimalControl, ControlSystems, MonteCarloMeasurements, Plots, LinearAlgebra\ndefault(size=(640,480))\nunsafe_comparisons(true)\n\na = 10\nP = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)\nK = ss(1.0I(2))\n\nw = 2π .* exp10.(LinRange(-2, 2, 500))\nS, PS, CS, T = RobustAndOptimalControl.gangoffour2(P, K)\nsigmaplot(S, w, lab=\"S\")\nsigmaplot!(T, w, c=2, lab=\"T\", ylims=(0.01, 45))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Both sensitivity functions are very large, expect a non-robust system!","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Next, we add parametric uncertainty","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"a = 10*(1 + 0.1δr(100)) # Create an uncertain parameter with nominal value 10 and 10% uncertainty\nP = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)\n\nSp, PSp, CSp, Tp = RobustAndOptimalControl.gangoffour2(P, K)\nsigmaplot(Sp, w, lab=\"S\")\nsigmaplot!(Tp, w, c=2, lab=\"T\", ylims=(0.01, 100))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Not only are sensitivity functions large, they vary a lot under the considered uncertainty. We can also plot a step response of one of the sensitivity functions to check how the system behaves","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"plot(step(c2d(Tp, 0.01), 10))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"This kind of plot is quite useful, it immediately tells you that this transfer function appears stable, and that there is uncertainty in the static gain etc.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Next, we add complex diagonal multiplicative input uncertainty. With input uncertainty of magnitude ϵ  dfrac1σ(T) we are guaranteed robust stability (even for “full-block complex perturbations\")","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"a = 10\nP = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)\n\nW0 = makeweight(0.2, (20,1), 2)\nW = I(2) + W0 * diagm([δc(100), δc(100)]) # Create a diagonal complex uncertainty weighted in frequency by W0, use 100 samples\nPs = P*W\nSs, PSs, CSs, Ts = RobustAndOptimalControl.gangoffour2(Ps, K)\nsigmaplot(Ss, w, lab=\"S\")\nsigmaplot!(Ts, w, c=2, lab=\"T\", ylims=(0.01, 100))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Under this uncertainty, the sensitivity could potentially be sky high., note how some of the 100 realizations peak much higher than the others. This is an indication that the system might be unstable.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"With complex entries in the system model, we can't really plot the step response, but we can plot, e.g., the absolute value","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"res = step(c2d(Ts, 0.01), 10)\nplot(res.t, [abs.(res.y)[1,:,1] abs.(res.y)[2,:,2]]) # plot only the diagonal response","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Looks unstable to me. The analysis using MDelta methodology below will also reach this conclusion.","category":"page"},{"location":"uncertainty/#Example-in-section-3.7.2,-Distillation-Process","page":"Uncertainty modeling","title":"Example in section 3.7.2, Distillation Process","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"using RobustAndOptimalControl, ControlSystems, MonteCarloMeasurements, Plots, LinearAlgebra\ndefault(size=(640,480))\nunsafe_comparisons(true)\n\nM = [87.8 -86.4; 108.2 -109.6]\nG = ss(tf(1, [75, 1])) * M\nRGA = relative_gain_array(G, 0)\nsum(abs, RGA) # A good estimate of the true condition number, which is 141.7","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"large elements in the RGA indicate a process that is difficult to control","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We consider the following inverse-based controller, which may also be looked upon as a steady-state decoupler with a PI controller","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"k1 = 0.7\nKinv = ss(tf(k1*[75, 1], [1, 0])) * inv(M) \n\n# reference filter\nF = tf(1, [5, 1])\n\nw = 2π .* exp10.(LinRange(-2, 2, 500))\nsigmaplot(input_sensitivity(G, Kinv), w)\nsigmaplot!(output_sensitivity(G, Kinv), w, c=2)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Sensitivity looks nice, how about step response","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"plot(step(feedback(G*Kinv)*F, 20))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Looks excellent..","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We consider again the input gain uncertainty as in the previous example, and we manually select the perturbations to be ϵ_1 = 02 and ϵ_2 = 02. We then have","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"G′ = G * diagm([1 + 0.2, 1 - 0.2])\nplot!(step(feedback(G′*Kinv)*F, 20), l=:dash)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Looks very poor! The system was not robust to simultaneous input uncertainty!","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We can also do this with a real, diagonal input uncertainty that grows with frequency","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"W0 = makeweight(0.2, 1, 2.0) # uncertainty goes from 20% at low frequencies to 200% at high frequencies\nW = I(2) + W0 * diagm([δr(100), δr(100)])\nGs = G*W\n\nplot(step(feedback(G*Kinv)*F, 20))\nplot!(step(feedback(G′*Kinv)*F, 20), l=:dash)\nres = step(c2d(feedback(Gs*Kinv)*F, 0.01), 20)\nmcplot!(res.t, abs.(res.y[:, :, 1]'), alpha=0.3)\nmcplot!(res.t, abs.(res.y[:, :, 2]'), alpha=0.3)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The system is very sensitive to real input uncertainty!","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"With a complex, diagonal uncertainty, modeling both gain and phase variations, it looks slightly worse, but not much worse than with real uncertainty.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"W = I(2) + W0 * diagm([δc(100), δc(100)]) # note δc instead of δr above\nGs = G*W\nres = step(c2d(feedback(Gs*Kinv)*F, 0.01), 20)\nmcplot!(res.t, abs.(res.y[:, :, 1]'), alpha=0.3)\nmcplot!(res.t, abs.(res.y[:, :, 2]'), alpha=0.3)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"How about the sensitivity functions?","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Si = input_sensitivity(Gs, Kinv)\nsigmaplot(Si, w, c=1, lab=\"Si\")\nSo = output_sensitivity(Gs, Kinv)\nsigmaplot!(So, w, c=2, lab=\"So\")","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The sensitivity at the plant output is enormous. A low sensitivity with the nominal system does not guarantee robustness!","category":"page"},{"location":"uncertainty/#Using-the-M\\Delta-framework","page":"Uncertainty modeling","title":"Using the MDelta framework","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The examples above never bothered with things like structured singular value, mu or linear-fractional transforms. We do, however, provide some elementary support for this modeling framework.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"In robust control, we often find ourselves having to consider the feedback interconnections below.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"        ┌─────────┐\n  zΔ◄───┤         │◄────wΔ\n        │         │\n   z◄───┤    P    │◄────w\n        │         │\n   y◄───┤         │◄────u\n        └─────────┘","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"        ┌─────────┐\n  zΔ◄───┤         │◄────wΔ\n        │         │\n   z◄───┤    P    │◄────w\n        │         │\n   y┌───┤         │◄───┐u\n    │   └─────────┘    │\n    │                  │\n    │      ┌───┐       │\n    │      │   │       │\n    └─────►│ K ├───────┘\n           │   │\n           └───┘","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"           ┌───┐\n           │   │\n    ┌─────►│ Δ ├───────┐\n    │      │   │       │\n    │      └───┘       │\n    │                  │\n    │   ┌─────────┐    │\n  zΔ└───┤         │◄───┘wΔ\n        │         │\n   z◄───┤    P    │◄────w\n        │         │\n   y┌───┤         │◄───┐u\n    │   └─────────┘    │\n    │                  │\n    │      ┌───┐       │\n    │      │   │       │\n    └─────►│ K ├───────┘\n           │   │\n           └───┘","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The first block diagram denotes an open-loop system P with an uncertainty mapping w_Delta = Delta  z_Delta, a performance mapping from w to z and a input-output mapping between u and y. Such a system P can be partitioned as","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"P = beginbmatrix\nP_11  P_12  P_13\nP_21  P_22  P_23\nP_31  P_32  P_33\nendbmatrix","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"where each P(s)_ij is a transfer matrix. The type UncertainSS with constructor uss represents the block","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"P = beginbmatrix\nP_11  P_12\nP_21  P_22\nendbmatrix","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"while an ExtendedStateSpace object represents the block","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"P = beginbmatrix\nP_22  P_23\nP_32  P_33\nendbmatrix","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"there is thus no type that represents the full system P above. However, we provide the function partition which allows you to convert from a regular statespace system to an extended statespace object, and it is thus possible to represent P by placing the whole block ","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"P = beginbmatrix\nP_22  P_23\nP_32  P_33\nendbmatrix","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"into P_22 for the purposes of uncertainty analysis (use ss to convert it to a standard statespace object), and later use partition to recover the internal block structure. ","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Given an UncertainSS P, we can close the loop around Delta by calling lft(P, Δ, :u), and given an ExtendedStateSpace, we can close the loop around K by calling starprod(P, K) or lft(P, K) (using positive feedback). This works even if P is a regular statespace object, in which case the convention is that the inputs and outputs are ordered as in the block diagrams above. The number of signals that will be connected by lft is determined by the input-output arity of K and Delta respectively.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We have the following methods for lft (in addition to the standard ones in ControlSystems.jl)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"lft(G::UncertainSS, K::LTISystem) forms the lower LFT closing the loop around K.\nlft(G::UncertainSS, Δ::AbstractArray=G.Δ) forms the upper LFT closing the loop around Delta.\nlft(G::ExtendedStateSpace, K) forms the lower LFT closing the loop around K.","category":"page"},{"location":"uncertainty/#Robust-stability-and-performance","page":"Uncertainty modeling","title":"Robust stability and performance","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"To check robust stability of the system in the last block diagram (with or without z and w), we can use the functions structured_singular_value, robstab and diskmargin.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Currently, structured_singular_value is rather limited and supports diagonal complex blocks only. If Delta is a single full complex block, opnorm(P.M) < 1 is the condition for stability.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Robust performance can be verified by introducing an additional fictitious \"performance perturbation\" Delta_p which is a full complex block, around which we close the loop from z to w and check the structured_singular_value with the augmented perturbation block","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Delta_a = beginbmatrix\nDelta  0\n0       Delta_p\nendbmatrix","category":"page"},{"location":"uncertainty/#Examples","page":"Uncertainty modeling","title":"Examples","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We repeat the first example here, but using MDelta formalism rather than direct Monte-Carlo modeling.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"a = 10\nP = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)\nW0 = makeweight(0.2, (1,1), 2) |> ss\nW = I(2) + W0*I(2) * uss([δc(), δc()]) # Create a diagonal complex uncertainty weighted in frequency by W0\nPs = P*W","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Ps is now represented as a upper linear fractional transform (upper LFT).","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We can draw samples from this uncertainty representation (sampling of Delta and closing the loop starprod(Δ, Ps)) like so","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Psamples = rand(Ps, 100)\nsigmaplot(Psamples, w)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We can extract the nominal model using","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"system_mapping(Ps)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"And obtain M and Delta when the loop is closed with K has","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"lft(Ps, K).M","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Ps.Δ # Ps.delta also works","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We can evaluate the frequency response of M and calculate the structured singular value mu","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"M = freqresp(lft(Ps, -K).M, w) # -K to get negative feedback\nM = permutedims(M, (2,3,1))\nμ = structured_singular_value(M)\nplot(w, μ, xscale=:log10)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"mu","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"is very high, whenever mu  1, the system is not stable with respect to the modeled uncertainty. The tolerated uncertainty is only about dfrac1mu_infty","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"1/norm(μ, Inf)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"of the modeled uncertainty. Another way of calculating this value is","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"robstab(lft(Ps, -K))","category":"page"},{"location":"uncertainty/#Internals-of-the-M\\Delta-framework","page":"Uncertainty modeling","title":"Internals of the MDelta framework","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"TODO","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"[Skogestad]: Skogestad, \"Multivariable Feedback Control: Analysis and Design\"","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"[Doyle91]: Doyle, Packard, Zhou, \"Review of LFTs, LMIs and μ\". https://www.researchgate.net/publication/257200344_Review_of_LFTs_LMIs_and_mu","category":"page"}]
}
