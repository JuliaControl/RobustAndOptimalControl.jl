var documenterSearchIndex = {"docs":
[{"location":"#RobustAndOptimalControl.jl","page":"Home","title":"RobustAndOptimalControl.jl","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add RobustAndOptimalControl","category":"page"},{"location":"#Named-systems","page":"Home","title":"Named systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See complicated-feedback example","category":"page"},{"location":"","page":"Home","title":"Home","text":"named_ss","category":"page"},{"location":"#Connecting-systems-together","page":"Home","title":"Connecting systems together","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See complicated-feedback example","category":"page"},{"location":"","page":"Home","title":"Home","text":"connect","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following complicated feedback interconnection","category":"page"},{"location":"","page":"Home","title":"Home","text":"                 yF\n              ┌────────────────────────────────┐\n              │                                │\n    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐\nuF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP\n────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►\n    │       │    │       │   ┌──►         │         │       │    │\n    └───────┘    └───────┘   │  └─────────┘         └───────┘    │\n                             │                                   │\n                             └───────────────────────────────────┘","category":"page"},{"location":"","page":"Home","title":"Home","text":"can be created by","category":"page"},{"location":"","page":"Home","title":"Home","text":"F = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)\nR = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)\nC = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)\nP = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)\n\naddP = sumblock(\"uP = yF + yC\") # Sum node before P\naddC = sumblock(\"uC = yR - yP\") # Sum node before C (drawn as two arrows into C in the diagram)\n\nconnections = [\n    :yP => :yP # Output to input\n    :uP => :uP # addP's output is called the same as P's input\n    :yC => :yC\n    :yF => :yF\n    :yF => :uR\n    :uC => :uC\n    :yR => :yR\n]\nw1 = [:uF] # External inputs\n\nG = connect([F, R, C, P, addP, addC], connections; w1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If an external input is to be connected to multiple points, use a splitter to split up the signal into a set of unique names which are then used in the connections.","category":"page"},{"location":"#Model-augmentation","page":"Home","title":"Model augmentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add disturbance and performance models to your system model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_disturbance\nadd_measurement_disturbance\nadd_input_differentiator\nadd_output_differentiator\nadd_input_integrator\nadd_output_integrator\nadd_low_frequency_disturbance\nadd_resonant_disturbance","category":"page"},{"location":"#H_\\infty-and-H_2-design","page":"Home","title":"H_infty and H_2 design","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO Examples are available in the example folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"hinfsynthesize\nh2synthesize\nglover_mcfarlane","category":"page"},{"location":"#LQG-design","page":"Home","title":"LQG design","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO","category":"page"},{"location":"","page":"Home","title":"Home","text":"LQGProblem","category":"page"},{"location":"#Structured-singular-value-and-diskmargin","page":"Home","title":"Structured singular value and diskmargin","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"structured_singular_value. Note, this only handles diagonal complex perturbations at the moment.\ndiskmargin\nloop_diskmargin\nsim_diskmargin","category":"page"},{"location":"#Closed-loop-analysis","page":"Home","title":"Closed-loop analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"output_sensitivity\noutput_comp_sensitivity\ninput_sensitivity\ninput_comp_sensitivity\nG_CS\nG_PS\ngangoffour","category":"page"},{"location":"#Exported-functions-and-types","page":"Home","title":"Exported functions and types","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RobustAndOptimalControl]\nPrivate = false","category":"page"},{"location":"#RobustAndOptimalControl.Disk","page":"Home","title":"RobustAndOptimalControl.Disk","text":"Disk\n\nRepresents a perturbation disc in the complex plane. Disk(0.5, 2) represents all perturbations in the circle centered at 1.25 with radius 0.75, or in other words, a gain margin of 2 and a pahse margin of 36.9 degrees.\n\nA disk can be converted to a Nyquist exclusion disk by nyquist(disk) and plotted using plot(disk).\n\nArguments:\n\nγmin: Lower intercept\nγmax: Upper intercept\nc: Center\nr: Radius\nϕm: Angle of tangent line through origin.\n\nIf γmax < γmin the disk is inverted. See diskmargin for disk margin computations. \n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.Diskmargin","page":"Home","title":"RobustAndOptimalControl.Diskmargin","text":"Diskmargin\n\nThe notation follows \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet\n\nFields:\n\nα: The disk margin ω0: The worst-case frequency f0: The destabilizing perturbation f0 is a complex number with simultaneous gain and phase variation. This critical perturbation causes an instability with closed-loop pole on the imaginary axis at the critical frequency ω0  δ0: The uncertain element generating f0. γmin: The lower real-axis intercept of the disk (classical lower gain margin). γmax: The upper real-axis intercept of the disk (classical upper gain margin). ϕm: is the classical phase margin. σ: The skew parameter that was used to calculate the margin\n\nThe \"disk\" margin becomes a half plane for α = 2 and an inverted circle for α > 2. In this case, the upper gain margin is infinite. See the paper for more details, in particular figure 6.\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.LQGProblem","page":"Home","title":"RobustAndOptimalControl.LQGProblem","text":"G = LQG(sys::AbstractStateSpace, Q1, Q2, R1, R2; qQ=0, qR=0, M = I, N = I)\n\nReturn an LQG object that describes the closed control loop around the process sys=ss(A,B,C,D) where the controller is of LQG-type. The controller is specified by weight matrices Q1,Q2 that penalizes state deviations and control signal variance respectively, and covariance matrices R1,R2 which specify state drift and measurement covariance respectively.\n\nqQ and qR can be set to incorporate loop transfer recovery, i.e.,\n\nL = lqr(A, B, Q1+qQ*C'C, Q2)\nK = kalman(A, C, R1+qR*B*B', R2)\n\nIncreasing qQ will add more cost in output direction, e.g., encouraging the use of cheap control, while increasing qR adds fictious dynamics noise, makes the observer faster in the direction we control.\n\nM is a matrix that defines the controlled variables z, i.e., the variables for which you provide reference signals. If no M is provided, the default is to consider all state variables of the system as controlled. The definitions of z and y are given below\n\ny = C*x\nz = M*x\n\nsize(M, 1) determines the size of the Q1 matrix you need to supply.\n\nN is a matrix that defines how the dynamics noise v enters the system, i.e. If no N is provided, the default is to consider all state variables being affected by independent noise components. The definition of v is given below\n\nx′ = A*x + B*u + N*v\n\nsize(N, 2) determines the size of the R1 matrix you need to supply.\n\nExample\n\ns = tf(\"s\")\nP = [1/(s+1) 2/(s+2); 1/(s+3) 1/(s-1)]\nsys = ss(P)\neye(n) = Matrix{Float64}(I,n,n) # For convinience\n\nqQ = 1\nqR = 1\nQ1 = 10eye(4)\nQ2 = 1eye(2)\nR1 = 1eye(6)\nR2 = 1eye(2)\n\nG = LQG(sys, Q1, Q2, R1, R2, qQ=qQ, qR=qR)\n\nGcl = G.cl\nT = G.T\nS = G.S\nsigmaplot([S,T],exp10.(range(-3, stop=3, length=1000)))\nstepplot(Gcl)\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.LQGProblem","text":"LQGProblem(P::ExtendedStateSpace)\n\nIf only an ExtendedStateSpace system is provided, the system P is assumed to correspond to the H₂ optimal control problem with\n\nC1'C1    = Q1\nD12'D12  = Q2\n\nB1*B1'   = R1\nD21*D21' = R2\n\nand an LQGProblem with the above covariance matrices is returned. The system description in the returned LQGProblem will have B1 = C1 = I. See Ch. 13 in Robust and optimal control for reference. \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.NamedStateSpace","page":"Home","title":"RobustAndOptimalControl.NamedStateSpace","text":"See named_ss for a convenient constructor.\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.UncertainSS","page":"Home","title":"RobustAndOptimalControl.UncertainSS","text":"UncertainSS{TE} <: AbstractStateSpace{TE}\n\nRepresents LFT_u(M, Diagonal(Δ))\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.δ","page":"Home","title":"RobustAndOptimalControl.δ","text":"δ(N=32)\n\nCreate an uncertain element of N uniformly distributed samples ∈ [-1, 1]\n\n\n\n\n\n","category":"type"},{"location":"#ControlSystems.ss","page":"Home","title":"ControlSystems.ss","text":"ss(A, B1, B2, C1, C2, D11, D12, D21, D22 [, Ts])\nss(A, B1, B2, C1, C2; D11, D12, D21, D22 [, Ts])\n\nCreate ExtendedStateSpace\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix, AbstractMatrix}","page":"Home","title":"RobustAndOptimalControl.add_disturbance","text":"add_disturbance(sys::StateSpace, Ad::Matrix, Cd::Matrix)\n\nSee CCS pp. 144\n\nArguments:\n\nsys: System to augment\nAd: The dynamics of the disturbance\nCd: How the disturbance states affect the states of sys. This matrix has the shape (sys.nx, size(Ad, 1))\n\nSee also add_low_frequency_disturbance, add_resonant_disturbance\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_input_differentiator","page":"Home","title":"RobustAndOptimalControl.add_input_differentiator","text":"add_input_differentiator(sys::StateSpace, ui = 1:sys.nu; goodwin=false)\n\nAugment the output of sys with the difference u(k+1)-u(k)\n\nArguments:\n\nui: An index or vector of indices indicating which inputs to differentiate.\ngoodwin: If true, the difference operator will use the Goodwin δ operator, i.e., (u(k+1)-u(k)) / sys.Ts.\n\nThe augmented system will have the matrices\n\n[A 0; 0 0]  [B; I]  [C 0; 0 -I]  [D; I]\n\nwith length(ui) added states and outputs.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_input_integrator","page":"Home","title":"RobustAndOptimalControl.add_input_integrator","text":"add_input_integrator(sys::StateSpace, ui = 1, ϵ = 0)\n\nAugment the output of sys with the integral of input at index ui, i.e.,  y_aug = [y; ∫u[ui]] See also add_low_frequency_disturbance\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace, Integer}","page":"Home","title":"RobustAndOptimalControl.add_low_frequency_disturbance","text":"add_low_frequency_disturbance(sys::StateSpace, Ai::Integer; ϵ = 0)\n\nA disturbance affecting only state Ai.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_low_frequency_disturbance-Tuple{ControlSystems.AbstractStateSpace}","page":"Home","title":"RobustAndOptimalControl.add_low_frequency_disturbance","text":"add_low_frequency_disturbance(sys::StateSpace; ϵ = 0, measurement = false)\n\nAugment sys with a low-frequency (integrating if ϵ=0) disturbance model. If an integrating input disturbance is used together with an observer, the controller will have integral action.\n\nArguments:\n\nϵ: Move the integrator pole ϵ into the stable region.\nmeasurement: If true, the disturbance is a measurement disturbance, otherwise it's an input diturbance. \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_measurement_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, AbstractMatrix, AbstractMatrix}","page":"Home","title":"RobustAndOptimalControl.add_measurement_disturbance","text":"add_measurement_disturbance(sys::StateSpace{Continuous}, Ad::Matrix, Cd::Matrix)\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_output_differentiator","page":"Home","title":"RobustAndOptimalControl.add_output_differentiator","text":"add_differentiator(sys::StateSpace{<:Discrete})\n\nAugment the output of sys with the numerical difference (discrete-time derivative) of output, i.e., y_aug = [y; (y-y_prev)/sys.Ts] To add both an integrator and a differentiator to a SISO system, use\n\nGd = add_output_integrator(add_output_differentiator(G), 1)\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_output_integrator","page":"Home","title":"RobustAndOptimalControl.add_output_integrator","text":"addoutputintegrator(sys::StateSpace{<:Discrete}, ind = 1; ϵ = 0)\n\nAugment the output of sys with the integral of output at index ind, i.e.,  y_aug = [y; ∫y[ind]] To add both an integrator and a differentiator to a SISO system, use\n\nGd = add_output_integrator(add_output_differentiator(G), 1)\n\nNote: numerical integration is subject to numerical drift. If the output of the system corresponds to, e.g., a velocity reference and the integral to position reference, consider methods for mitigating this drift.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_resonant_disturbance-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}, Any, Any, Integer}","page":"Home","title":"RobustAndOptimalControl.add_resonant_disturbance","text":"add_resonant_disturbance(sys::StateSpace{Continuous}, ω, ζ, Ai::Int; measurement = false)\n\nAugment sys with a resonant disturbance model.\n\nArguments:\n\nω: Frequency\nζ: Relative damping.\nAi: The affected state\nmeasurement: If true, the disturbace is acting on the output, this will cause the controller to have zeros at ω (roots of poly s² + 2ζωs + ω²). If false, the disturbance is acting on the input, this will cause the controller to have poles at ω (roots of poly s² + 2ζωs + ω²).\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}","page":"Home","title":"RobustAndOptimalControl.bilinearc2d","text":"bilinearc2d(Ac::AbstractArray, Bc::AbstractArray, Cc::AbstractArray, Dc::AbstractArray, Ts::Number; tolerance=1e-12)\n\nBalanced Bilinear transformation in State-Space. This method computes a discrete time equivalent of a continuous-time system, such that\n\nG_d(z) = s2z[G_c(s)]\n\nin a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||2=||C||2   (iii) Satisfies Gc(s) = z2s[s2z[Gc(s)]] for some map z2s[]\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilinearc2d-Tuple{ControlSystems.StateSpace{ControlSystems.Continuous}, Number}","page":"Home","title":"RobustAndOptimalControl.bilinearc2d","text":"bilinearc2d(sys::StateSpace, Ts::Number)\n\nApplies a Balanced Bilinear transformation to a discrete-time statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{ControlSystems.Continuous}, Number}","page":"Home","title":"RobustAndOptimalControl.bilinearc2d","text":"bilinearc2d(sys::ExtendedStateSpace, Ts::Number)\n\nApplies a Balanced Bilinear transformation to a discrete-time extended statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}","page":"Home","title":"RobustAndOptimalControl.bilineard2c","text":"bilineard2c(Ad::AbstractArray, Bd::AbstractArray, Cd::AbstractArray, Dd::AbstractArray, Ts::Number; tolerance=1e-12)\n\nBalanced Bilinear transformation in State-Space. This method computes a continuous time equivalent of a discrete time system, such that\n\nG_c(z) = z2s[G_d(z)]\n\nin a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||2=||C||2   (iii) Satisfies Gd(z) = s2z[z2s[Gd(z)]] for some map s2z[]\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilineard2c-Tuple{ControlSystems.StateSpace}","page":"Home","title":"RobustAndOptimalControl.bilineard2c","text":"bilineard2c(sys::StateSpace)\n\nApplies a Balanced Bilinear transformation to continuous-time statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.bilineard2c","text":"bilineard2c(sys::ExtendedStateSpace)\n\nApplies a Balanced Bilinear transformation to continuous-time extended statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.broken_feedback-Tuple{ControlSystems.LTISystem, Any}","page":"Home","title":"RobustAndOptimalControl.broken_feedback","text":"broken_feedback(L, i)\n\nCloses all loops in square MIMO system L except for loops i. Forms L1 in fig 14. of \"An Introduction to Disk Margins\" https://arxiv.org/abs/2003.04771\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.closedloop","page":"Home","title":"RobustAndOptimalControl.closedloop","text":"closedloop(l::LQGProblem, L = lqr(l), K = kalman(l))\n\nClosed-loop system as defined in Glad and Ljung eq. 8.28\n\nThe return value will be the closed loop from reference only, other disturbance signals (B1) are ignored. See feedback for a more advanced option.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.comp_sensitivity-Tuple","page":"Home","title":"RobustAndOptimalControl.comp_sensitivity","text":"See output_comp_sensitivity\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.connect-Tuple{Any}","page":"Home","title":"RobustAndOptimalControl.connect","text":"connect(systems, connections; w1, z1 = (:), verbose = true, kwargs...)\n\nCreate complicated feedback interconnection. \n\nAddition and subtraction nodes are achieved by creating a linear combination node, i.e., a system with a D matrix only.\n\nArguments:\n\nsystems: A vector of named systems to be connected\nconnections: a vector of pairs indicating output => input mappings.\nu1: input mappings  (alternative input argument)\ny1: output mappings (alternative input argument)\nw1: external signals\nz1: outputs (can overlap with y1)\nverbose: Issue warnings for signals that have no connection\n\nExample: The following complicated feedback interconnection\n\n                 yF\n              ┌────────────────────────────────┐\n              │                                │\n    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐\nuF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP\n────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►\n    │       │    │       │   ┌──►         │         │       │    │\n    └───────┘    └───────┘   │  └─────────┘         └───────┘    │\n                             │                                   │\n                             └───────────────────────────────────┘\n\ncan be created by\n\nF = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)\nR = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)\nC = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)\nP = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)\n\naddP = sumblock(\"uP = yF + yC\") # Sum node before P\naddC = sumblock(\"uC = yR - yP\") # Sum node before C\n\nconnections = [\n    :yP => :yP # Output to input\n    :uP => :uP\n    :yC => :yC\n    :yF => :yF\n    :yF => :uR\n    :uC => :uC\n    :yR => :yR\n]\nw1 = [:uF] # External inputs\n\nG = connect([F, R, C, P, addP, addC], connections; w1)\n\nIf an external input is to be connected to multiple points, use a splitter to split up the signal into a set of unique names which are then used in the connections.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.controller_reduction","page":"Home","title":"RobustAndOptimalControl.controller_reduction","text":"controller_reduction(P, K, r, out=false)\n\nMinimize    ||(K-Kᵣ) W||∞ if out=false             ||W (K-Kᵣ)||∞ if out=true See Robust and Optimal Control Ch 19.1 out indicates if the weight will be applied as output or input weight.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.diskmargin","page":"Home","title":"RobustAndOptimalControl.diskmargin","text":"diskmargin(L, σ = 0)\ndiskmargin(L, σ::Real, ω)\n\nCalculate the disk margin of LTI system L. L is supposed to be a loop-transfer function, i.e., it should be square. If L = PC the disk margin for output perturbations is computed, whereas if L = CP, input perturbations are considered. If the method diskmargin(P, C, args...) is used, both are computed.\n\nThe implementation and notation follows \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771\n\nThe margins are aviable as fields of the returned objects, see Diskmargin.\n\nArguments:\n\nL: A loop-transfer function.\nσ: If little is known about the distribution of gain variations then σ = 0 is a reasonable choice as it allows for a gain increase or decrease by the same relative amount. The choice σ < 0 is justified if the gain can decrease by a larger factor than it can increase. Similarly, the choice σ > 0 is justified when the gain can increase by a larger factor than it can decrease. If σ = −1 then the disk margin condition is αmax = inv(MT). This margin is related to the robust stability condition for models with multiplicative uncertainty of the form P (1 + δ). If σ = +1 then the disk margin condition is αmax = inv(MS)\nkwargs: Are sent to the hinfnorm calculation\nω: If a vector of frequencies is supplied, the frequency-dependent disk margin will be computed, see example below.\n\nExample:\n\nL = tf(25, [1,10,10,10])\ndm = diskmargin(L, 0)\nplot(dm) # Plot the disk margin to illustrate maximum allowed simultaneous gain and phase variations.\n\nnyquistplot(L)\nplot!(dm, nyquist=true) # plot a nyquist exclusion disk. The Nyquist curve will be tangent to this disk at `dm.ω0`\nnyquistplot!(dm.f0*L) # If we perturb the system with the worst-case perturbation `f0`, the curve will pass through the critical point -1.\n\n## Frequency-dependent margin\nw = exp10.(LinRange(-2, 2, 500))\ndms = diskmargin(L, 0, w)\nplot(w, dms)\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Any, AbstractVector, Vararg{Any}}","page":"Home","title":"RobustAndOptimalControl.diskmargin","text":"diskmargin(P::LTISystem, C::LTISystem, σ, w::AbstractVector, args...; kwargs...)\n\nSimultaneuous diskmargin at outputs, inputs and input/output simultaneously of P.  Returns a named tuple with the fields input, output, simultaneous_input, simultaneous_output, simultaneous where input and output represent loop-at-a-time margins, simultaneous_input is the margin for simultaneous perturbations on all inputs and simultaneous is the margin for perturbations on all inputs and outputs simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractArray}","page":"Home","title":"RobustAndOptimalControl.diskmargin","text":"diskmargin(L::LTISystem, σ::Real, ω)\n\nCalculate the diskmargin at a particular frequency or vector of frequencies. If ω is a vector, you get a frequency-dependent diskmargin plot if you plot the returned value.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}","page":"Home","title":"RobustAndOptimalControl.expand_symbol","text":"expand_symbol(s::Symbol, n::Int)\n\nTakes a symbol and an integer and returns a vector of symbols with increasing numbers appended to the end. E.g., (:x, 3) -> [:x1, :x2, :x3]\n\nThe short-hand syntax s^n is also available, e.g., :x^3 == expand_symbol(:x, 3).\n\nUseful to create signal names for named systems.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.extended_controller","page":"Home","title":"RobustAndOptimalControl.extended_controller","text":"extended_controller(l::LQGProblem, L = lqr(l), K = kalman(l))\n\nReturns an expression for the controller that is obtained when state-feedback u = -L(xᵣ-x̂) is combined with a Kalman filter with gain K that produces state estimates x̂. The controller is an instance of ExtendedStateSpace where C2 = -L, D21 = L and B2 = K.\n\nThe returned system has inputs [xᵣ; y] and outputs the control signal u. If a reference model R is used to generate state references xᵣ, the controller from e = ry - y -> u is given by\n\nCe = extended_controller(l)\nCe = named_ss(Ce; x = :xC, y = :u, u = [R.y; :y^l.ny]) # Name the inputs of Ce the same as the outputs of `R`.\nconnect([R, Ce]; u1 = R.y, y1 = R.y, w1 = [:ry^l.ny, :y^l.ny], z1=[:u])\n\nSince the negative part of the feedback is built into the returned system, we have C = observer_controller(l) Ce = extended_controller(l) system_mapping(Ce) == -C`\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.extended_controller-Tuple{ControlSystems.AbstractStateSpace}","page":"Home","title":"RobustAndOptimalControl.extended_controller","text":"extended_controller(K::AbstractStateSpace)\n\nTakes a controller and returns an ExtendedStateSpace version which has augmented input [r; y] and output y (z output is 0-dim).\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{ControlSystems.StateSpace{<:Any, <:MonteCarloMeasurements.AbstractParticles{<:Any, N}}, Any}, Tuple{ControlSystems.StateSpace{<:Any, <:MonteCarloMeasurements.AbstractParticles{<:Any, N}}, Any, F}} where {N, F}","page":"Home","title":"RobustAndOptimalControl.find_lft","text":"l = find_lft(sys::StateSpace{<:Any, <:StaticParticles{<:Any, N}}, δ) where N\n\nGiven an systems sys with uncertain coefficients in the form of StaticParticles, find a lower linear fractional transformation M such that lft(M, δ) ≈ sys. \n\nδ can be either the source of uncertainty in sys, i.e., a vector of the unique uncertain parameters that were used to create sys. These should be constructed as uniform randomly distributed particles for most robust-control theory to be applicable.  δ can also be an integer, in which case a numer of δ sources of uncertainty are automatically created. This could be used for order reduction if the number of uncertainty sources in sys is large.\n\nNote, uncertainty in sys is only supported in A and B, C and D must be deterministic.\n\nReturns l::LFT that internaly contains all four blocks of M as well as δ. Call ss(l,sys) do obtain lft(M, δ) ≈ sys.\n\nCall Matrix(l) to obtain M = [M11 M12; M21 M22]\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.frequency_weighted_reduction-NTuple{4, Any}","page":"Home","title":"RobustAndOptimalControl.frequency_weighted_reduction","text":"frequency_weighted_reduction(G, Wo, Wi)\n\nFind Gr such that ||Wₒ(G-Gr)Wᵢ||∞ is minimized. For a realtive reduction, set Wo = inv(G) and Wi = I.\n\nRef: Robust and Optimal Control ch. 7.2\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.glover_mcfarlane","page":"Home","title":"RobustAndOptimalControl.glover_mcfarlane","text":"K, γmin = glover_mcfarlane(G::AbstractStateSpace{Continuous}, γ = 1.1)\n\nDesign a controller for G that maximizes the stability margin ϵ = 1/γ with normalized coprime factor uncertainty using the method of Glover and McFarlane\n\nγ = 1/ϵ = ||[K;I] inv(I-G*K)*inv(M)||∞\nG = inv(M + ΔM)*(N + ΔN)\n\nγ is given as a relative factor above γmin and must be greater than 1, i.e., if γ = 1.1, the controller will be designed for γ = 1.1*γmin.\n\nWe want γmin ≥ 1 as small as possible, and we usually require that min is less than 4, corresponding to 25% allowed coprime uncertainty.\n\nPerformance modeling is incorporated in the design by calling glover_mcfarlane on the shaped system W2*G*W1 and then forming the controller as W1*K*W2. Using this formulation, traditional loop shaping can be done on W2*G*W1.\n\nExample:\n\nExample 9.3 from the reference below.\n\nusing RobustAndOptimalControl, ControlSystems, Plots, Test\nG = tf(200, [10, 1])*tf(1, [0.05, 1])^2     |> ss\nGd = tf(100, [10, 1])                       |> ss\nW1 = tf([1, 2], [1, 1e-6])                  |> ss\nGs = G*W1\nKs, γmin = glover_mcfarlane(Gs, 1.1)\n@test γmin ≈ 2.34 atol=0.005\n\nbodeplot([G, Gs, Gs*Ks]) |> display\n\nplot( step(Gd*feedback(1, G*W1), 3))\nplot!(step(Gd*feedback(1, G*W1*Ks), 3)) |> display\n\nnyquistplot([G*W1, G*W1*Ks], ylims=(-2,1), xlims=(-2, 1), Ms_circles=1.5) |> display\n\nRef: Sec 9.4.1 of Skogestad, \"Multivariable Feedback Control: Analysis and Design\"\n\nExtended help\n\nSkogestad gives the following general advice:\n\nScale the plant outputs and inputs. This is very important for most design  procedures and is sometimes forgotten. In general, scaling improves the  conditioning of the design problem, it enables meaningful analysis to be made  of the robustness properties of the feedback system in the frequency domain,  and for loop-shaping it can simplify the selection of weights. There are a variety  of methods available including normalization with respect to the magnitude of  the maximum or average value of the signal in question. If one is to go straight to a design the following variation has  proved useful in practice:  (a) The outputs are scaled such that equal magnitudes of cross-coupling into each      of the outputs is equally undesirable.  (b) Each input is scaled by a given percentage (say 10%) of its expected range      of operation. That is, the inputs are scaled to reflect the relative actuator      capabilities. An example of this type of scaling is given in the aero-engine      case study of Chapter 12.\nOrder the inputs and outputs so that the plant is as diagonal as possible. The  relative gain array rga can be useful here. The purpose of this pseudo-diagonalization  is to ease the design of the pre- and post-compensators which, for simplicity, will  be chosen to be diagonal.\nNext, we discuss the selection of weights to obtain the shaped plant G_s = W_2 G W_1  where W_1 = W_p W_a W_g\nSelect the elements of diagonal pre- and post-compensators W_p and W_2 so that  the singular values of W_2 G W_p are desirable. This would normally mean high  gain at low frequencies, roll-off rates of approximately 20 dB/decade (a slope of  about 1) at the desired bandwidth(s), with higher rates at high frequencies. Some  trial and error is involved here. W_2 is usually chosen as a constant, reflecting the  relative importance of the outputs to be controlled and the other measurements  being fed back to the controller. For example, if there are feedback measurements  of two outputs to be controlled and a velocity signal, then W_2 might be chosen  to be diag([1, 1, 0.1]), where 0.1 is in the velocity signal channel. W_p contains the  dynamic shaping. Integral action, for low frequency performance; phase-advance  for reducing the roll-off rates at crossover, and phase-lag to increase the roll-off  rates at high frequencies should all be placed in W_p if desired. The weights should  be chosen so that no unstable hidden modes are created in G_s.\nOptional: Introduce an additional gain matrix W_g cascaded with W_a to provide  control over actuator usage. W_g is diagonal and is adjusted so that actuator rate  limits are not exceeded for reference demands and typical disturbances on the  scaled plant outputs. This requires some trial and error.\nRobustly stabilize the shaped plant G_s = W_2 G W_1 , where W_1 = W_p W_a W_g,  using glover_mcfarlane. First, the maximum stability  margin ϵ_max = 1γ_min is calculated. If the margin is too small, ϵmax  025, then go back and modify the weights. Otherwise, a γ-suboptimal controller is synthesized. There is usually no advantage to be gained by using the optimal controller. When ϵ_max > 0.25  (respectively γ_min < 4) the design is usually successful. In this case, at least  25% coprime factor uncertainty is allowed, and we also find that the shape of the  open-loop singular values will not have changed much after robust stabilization.  A small value of ϵmax indicates that the chosen singular value loop-shapes are  incompatible with robust stability requirements. That the loop-shapes do not  change much following robust stabilization if γ is small (ϵ large), is justified  theoretically in McFarlane and Glover (1990).\nAnalyze the design and if all the specifications are not met make further  modifications to the weights.\nImplement the controller. The configuration shown in below has been found  useful when compared with the conventional set up. This is because  the references do not directly excite the dynamics of K, which can result in large amounts of overshoot (classical derivative kick). The constant prefilter ensures a steady-state gain of 1 between r and y, assuming integral action in W_1 or G (note, the K returned by this function has opposite sign compared to that of Skogestad, so we use negative feedback here).\n\nAnti-windup can be added to W_1 but putting W_1 on Hanus form after the synthesis, see hanus.\n\n       ┌─────────┐      ┌────────┐      ┌────────┐\n    r  │         │    us│        │  u   │        │  y\n   ───►│(K*W2)(0)├──+──►│   W1   ├─────►│   G    ├────┬──►\n       │         │  │-  │        │      │        │    │\n       └─────────┘  │   └────────┘      └────────┘    │\n                    │                                 │\n                    │                                 │\n                    │   ┌────────┐      ┌────────┐    │\n                    │   │        │  ys  │        │    │\n                    └───┤   K    │◄─────┤   W2   │◄───┘\n                        │        │      │        │\n                        └────────┘      └────────┘\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.h2synthesize","page":"Home","title":"RobustAndOptimalControl.h2synthesize","text":"K, Cl = h2synthesize(P::ExtendedStateSpace, γ = nothing)\n\nSynthesize H₂-optimal controller K and calculate the closed-loop transfer function from w to z. Ref: Cha. 14.5 in Robust and Optimal Control.\n\nIf γ = nothing, use the formulas for H₂ in Ch 14.5. If γ is a large value, the H∞ formulas are used. As γ → ∞, these two are equivalent. The h∞ formulas do a coordinate transfromation that handles slightly more general systems so if you run into an error, it might be worth trying setting γ to something large, e.g., 1000.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.hanus-Tuple{Any}","page":"Home","title":"RobustAndOptimalControl.hanus","text":"`Wh` = hanus(W)\n\nReturn Wh on Hanus form. Wh has twice the number of inputs, where the second half of the inputs are \"actual inputs\", e.g., potentially saturated. This is used to endow W with anti-windup protection. W must have an invertable D matrix and be minimum phase.\n\nRef: Sec 9.4.5 of Skogestad, \"Multivariable Feedback Control: Analysis and Design\"\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.hinfassumptions","text":"flag = hinfassumptions(P::ExtendedStateSpace; verbose=true)\n\nCheck the assumptions for using the γ-iteration synthesis in Theorem 1.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfpartition-NTuple{4, Any}","page":"Home","title":"RobustAndOptimalControl.hinfpartition","text":"P = hinfpartition(G, WS, WU, WT)\n\nTransform a SISO or MIMO system G, with weighting functions WS, WU, WT into and LFT with an isolated controller, and write the resulting system, P(s), on a state-space form. Valid inputs for G are transfer functions (with dynamics, can be both MIMO and SISO, both in tf and ss forms). Valid inputs for the weighting functions are empty arrays, numbers (static gains), and LTISystems.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, ControlSystems.LTISystem, ControlSystems.LTISystem}","page":"Home","title":"RobustAndOptimalControl.hinfsignals","text":"hinfsignals(P::ExtendedStateSpace, G::LTISystem, C::LTISystem)\n\nUse the extended state-space model, a plant and the found controller to extract the closed loop transfer functions operating solely on the state-space.\n\nPcl : w → z : From input to the weighted functions\nS   : w → e : From input to error\nCS  : w → u : From input to control\nT   : w → y : From input to output\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.hinfsynthesize","text":"flag, K, γ, mats = hinfsynthesize(P::ExtendedStateSpace; maxIter=20, interval=(2/3,20), verbose=true)\n\nComputes an H-infinity optimal controller K for an extended plant P such that ||F_l(P, K)||∞ < γ for the largest possible γ given P. The routine is known as the γ-iteration, and is based on the paper \"State-space formulae for all stabilizing controllers that satisfy an H∞-norm bound and relations to risk sensitivity\" by Glover and Doyle. See the Bib-entry below [1] above.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hsvd-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}}","page":"Home","title":"RobustAndOptimalControl.hsvd","text":"hsvd(sys::AbstractStateSpace{Continuous})\n\nReturn the Hankel singular values of sys, computed as the eigenvalues of QP Where Q and P are the Gramians of sys.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.input_comp_sensitivity","text":"input_comp_sensitivity(P,C)\ninput_comp_sensitivity(l::LQGProblem)\n\nTransfer function from load disturbance to control signal.\n\n\"Input\" signifies that the transfer function is from the input of the plant.\n\"Complimentary\" signifies that the transfer function is to an output (in this case controller output)\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.input_sensitivity","text":"input_sensitivity(P, C)\ninput_sensitivity(l::LQGProblem)\n\nTransfer function from load disturbance to total plant input.\n\n\"Input\" signifies that the transfer function is from the input of the plant.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, ControlSystems.LTISystem, Vararg{Any}}","page":"Home","title":"RobustAndOptimalControl.loop_diskmargin","text":"loop_diskmargin(P, C, args...; kwargs...)\n\nCalculate the loop-at-a-time diskmargin for each output and input of P. See also diskmargin, sim_diskmargin. Ref: \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.loop_diskmargin-Tuple{ControlSystems.LTISystem, Vararg{Any}}","page":"Home","title":"RobustAndOptimalControl.loop_diskmargin","text":"loop_diskmargin(L, args...; kwargs...)\n\nCalculate the loop-at-a-time diskmargin for each output of L.\n\nSee also diskmargin, sim_diskmargin. Ref: \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}","page":"Home","title":"RobustAndOptimalControl.measure","text":"measure(s::NamedStateSpace, names)\n\nReturn a system with specified states as measurement outputs.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T","page":"Home","title":"RobustAndOptimalControl.named_ss","text":"named_ss(sys::AbstractStateSpace{T}; x, u, y)\n\nCreate a NamedStateSpace system. This kind of system uses names rather than integer indices to refer to states, inputs and outputs\n\nArguments:\n\nsys: A system to add names to.\nx: A list of symbols with names of the states.\nu: A list of symbols with names of the inputs.\ny: A list of symbols with names of the outputs.\n\nDefault names of signals if none are provided are x,u,y.\n\nExample\n\nG1 = ss(1,1,1,0)\nG2 = ss(1,1,1,0)\ns1 = named_ss(G1, x = :x, u = :u1, y=:y1)\ns2 = named_ss(G2, x = :z, u = :u2, y=:y2)\n\ns1[:y1, :u1] # Index using symbols\n\nfb = feedback(s1, s2, r = :r) # \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.noise_mapping-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.noise_mapping","text":"noise_mapping(P::ExtendedStateSpace)\n\nReturn the system from w -> y\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.output_comp_sensitivity","text":"output_comp_sensitivity(P,C)\noutput_comp_sensitivity(l::LQGProblem)\n\nTransfer function from measurement noise / reference to plant output.\n\n\"output\" signifies that the transfer function is from the output of the plant.\n\"Complimentary\" signifies that the transfer function is to an output (in this case plant output)\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.output_sensitivity","text":"output_sensitivity(P, C)\noutput_sensitivity(l::LQGProblem)\n\nTransfer function from measurement noise / reference to control signal.\n\n\"output\" signifies that the transfer function is from the output of the plant.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}","page":"Home","title":"RobustAndOptimalControl.partition","text":"partition(P::AbstractStateSpace; u, y, w=!u, z=!y)\n\nPartition P into an ExtendedStateSpace.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.performance_mapping-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.performance_mapping","text":"performance_mapping(P::ExtendedStateSpace)\n\nReturn the system from w -> z\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.robstab-Tuple{UncertainSS, Vararg{Any}}","page":"Home","title":"RobustAndOptimalControl.robstab","text":"robstab(M0::UncertainSS, w=exp10.(LinRange(-3, 3, 1500)); kwargs...)\n\nReturn the robust stability margin of an uncertain model, defined as the inverse of the structured singular value.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.sensitivity-Tuple","page":"Home","title":"RobustAndOptimalControl.sensitivity","text":"See output_sensitivity\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.sim_diskmargin","page":"Home","title":"RobustAndOptimalControl.sim_diskmargin","text":"sim_diskmargin(L, σ::Real = 0)\n\nReturn the smallest simultaneous diskmargin over the grid 1e-3:1e3\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.sim_diskmargin-2","page":"Home","title":"RobustAndOptimalControl.sim_diskmargin","text":"sim_diskmargin(P::LTISystem, C::LTISystem, σ::Real = 0)\n\nSimultaneuous diskmargin at both outputs and inputs of P. Ref: \"An Introduction to Disk Margins\", Peter Seiler, Andrew Packard, and Pascal Gahinet https://arxiv.org/abs/2003.04771\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.sim_diskmargin-Tuple{ControlSystems.LTISystem, Real, AbstractVector}","page":"Home","title":"RobustAndOptimalControl.sim_diskmargin","text":"sim_diskmargin(L, σ::Real, w::AbstractVector)\nsim_diskmargin(L, σ::Real = 0)\n\nSimultaneuous diskmargin at the outputs of L.  Uses should consider using diskmargin.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.specificationplot","page":"Home","title":"RobustAndOptimalControl.specificationplot","text":"specificationplot([S,CS,T], [WS,WU,WT])\n\nThis function visualizes the control synthesis using the hInf_synthesize with the three weighting functions {WS(jω), WU(jω), WT(jω)} inverted and scaled by γ, against the corresponding transfer fucntions {S(jω), C(jω)S(jω), T(jω)}, to verify visually that the specifications are met. This may be run using both MIMO and SISO systems.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.structured_singular_value-Tuple{UncertainSS, AbstractVector}","page":"Home","title":"RobustAndOptimalControl.structured_singular_value","text":"structured_singular_value(M0::UncertainSS, [w::AbstractVector]; kwargs...)\n\nw: Frequency vector, if none is provided, the maximum μ over a brid 1e-3 : 1e3 will be returned.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.structured_singular_value-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Home","title":"RobustAndOptimalControl.structured_singular_value","text":"μ = structured_singular_value(M; tol=1e-4)\n\nCompute (an upper bound of) the structured singular value μ for diagonal Δ of complex perturbations (other structures of Δ are not yet supported). M is assumed to be an (n × n × N_freq) array or a matrix.\n\nWe currently don't have any methods to compute a lower bound, but if all perturbations are complex the spectral radius ρ(M) is always a lower bound (usually not a good one).\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.sumblock-Tuple{String}","page":"Home","title":"RobustAndOptimalControl.sumblock","text":"sumblock(ex::String; Ts = 0, n = 1)\n\nCreate a summation node that sums (or subtracts) vectors of length n.\n\nArguments:\n\nTs: Sample time\nn: The length of the input and output vectors. Set n=1 for scalars.\n\nExamples:\n\njulia> sumblock(\"uP = vf + yL\")\nNamedStateSpace{Continuous, Int64}\nD = \n 1  1\n\nWith state  names: \n     input  names: vf yL\n     output names: uP\n\n\njulia> sumblock(\"x_diff = xr - xh\"; n=3)\nNamedStateSpace{Continuous, Int64}\nD = \n 1  0  0  -1   0   0\n 0  1  0   0  -1   0\n 0  0  1   0   0  -1\n\nWith state  names: \n     input  names: xr1 xr2 xr3 xh1 xh2 xh3\n     output names: x_diff1 x_diff2 x_diff3\n     \n\njulia> sumblock(\"a = b + c - d\")\nNamedStateSpace{Continuous, Int64}\nD = \n 1  1  -1\n\nWith state  names: \n     input  names: b c d\n     output names: a\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.system_mapping-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.system_mapping","text":"system_mapping(P::ExtendedStateSpace)\n\nReturn the system from u -> y\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.uss","page":"Home","title":"RobustAndOptimalControl.uss","text":"uss(d::AbstractVector{<:δ}, Ts = nothing)\n\nCreate a diagonal uncertain statespace object with the uncertain elements d on the diagonal.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.uss-2","page":"Home","title":"RobustAndOptimalControl.uss","text":"uss(D::AbstractArray, Δ, Ts = nothing)\n\nIf only a single D matrix is provided, it's treated as D11.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.uss-3","page":"Home","title":"RobustAndOptimalControl.uss","text":"uss(D11, D12, D21, D22, Δ, Ts = nothing)\n\nCreate an uncertain statespace object with only gin matrices.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.uss-Union{Tuple{δ{C, F}}, Tuple{F}, Tuple{C}, Tuple{δ{C, F}, Any}} where {C, F}","page":"Home","title":"RobustAndOptimalControl.uss","text":"uss(d::δ{C, F}, Ts = nothing)\n\nConvert a δ object to an UncertainSS\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.δc","page":"Home","title":"RobustAndOptimalControl.δc","text":"δr(val::Real = 0.0, radius::Real = 1.0, name)\n\nCreate a complex, uncertain parameter. If no name is given, a boring name will be generated automatically.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.δr","page":"Home","title":"RobustAndOptimalControl.δr","text":"δr(val::Real = 0.0, radius::Real = 1.0, name)\n\nCreate a real, uncertain parameter. If no name is given, a boring name will be generated automatically.\n\n\n\n\n\n","category":"function"},{"location":"uncertainty/#Uncertainty-modeling","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"See example uncertain.jl.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"δc Creates an uncertain complex parameter.\nδr Creates an uncertain real parameter.\nδss (Experimental) Creates an uncertain statespace model.\nneglected_delay\nneglected_lag\ngain_and_delay_uncertainty\nmakeweight\nfit_complex_perturbations","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We provide two general means of modeling uncertainty, the traditional MDelta framework [Skogestad][Doyle91], and a Monte-Carlo approach using MonteCarloMeasurements.jl","category":"page"},{"location":"uncertainty/#Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/.MonteCarloMeasurements.jl)","page":"Uncertainty modeling","title":"Parametric uncertainty using MonteCarloMeasurements.jl","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The most straightforward way to model uncertainty is to use uncertain parameters, using tools such as IntervalArithmetic (strict, worst case guarantees) or MonteCarloMeasurements (less strict worst-case analysis or probabilistic). In the following, we show an example with MIMO systems with both parametric uncertainty and diagonal, complex uncertainty, adapted from 8.11.3 in Skogestad, \"Multivariable Feedback Control: Analysis and Design\". This example is also available as a julia script in uncertain.jl.","category":"page"},{"location":"uncertainty/#Example-in-section-3.7.1,-Spinning-satellite","page":"Uncertainty modeling","title":"Example in section 3.7.1, Spinning satellite","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"using RobustAndOptimalControl, ControlSystems, MonteCarloMeasurements, Plots, LinearAlgebra\ndefault(size=(640,480))\nunsafe_comparisons(true)\n\na = 10\nP = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)\nK = ss(1.0I(2))\n\nw = 2π .* exp10.(LinRange(-2, 2, 500))\nS, PS, CS, T = RobustAndOptimalControl.gangoffour2(P, K)\nsigmaplot(S, w, lab=\"S\")\nsigmaplot!(T, w, c=2, lab=\"T\", ylims=(0.01, 45))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Both sensitivity functions are very large, expect a non-robust system!","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Next, we add parametric uncertainty","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"a = 10*(1 + 0.1δr(100)) # Create an uncertain parameter with nominal value 10 and 10% uncertainty\nP = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)\n\nSp, PSp, CSp, Tp = RobustAndOptimalControl.gangoffour2(P, K)\nsigmaplot(Sp, w, lab=\"S\")\nsigmaplot!(Tp, w, c=2, lab=\"T\", ylims=(0.01, 100))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Not only are sensitivity functions large, they vary a lot under the considered uncertainty. We can also plot a step response of one of the sensitivity functions to check how the system behaves","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"plot(step(c2d(Tp, 0.01), 10))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"This kind of plot is quite useful, it immediately tells you that this transfer function appears stable, and that there is uncertainty in the static gain etc.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Next, we add complex diagonal multiplicative input uncertainty. With input uncertainty of magnitude ϵ  dfrac1σ(T) we are guaranteed robust stability (even for “full-block complex perturbations\")","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"a = 10\nP = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)\n\nW0 = makeweight(0.2, (20,1), 2)\nW = I(2) + W0 * diagm([δc(100), δc(100)]) # Create a diagonal complex uncertainty weighted in frequency by W0, use 100 samples\nPs = P*W\nSs, PSs, CSs, Ts = RobustAndOptimalControl.gangoffour2(Ps, K)\nsigmaplot(Ss, w, lab=\"S\")\nsigmaplot!(Ts, w, c=2, lab=\"T\", ylims=(0.01, 100))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Under this uncertainty, the sensitivity could potentially be sky high., note how some of the 100 realizations peak much higher than the others. This is an indication that the system might be unstable.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"With complex entries in the system model, we can't really plot the step response, but we can plot, e.g., the absolute value","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"res = step(c2d(Ts, 0.01), 10)\nplot(res.t, [abs.(res.y)[1,:,1] abs.(res.y)[2,:,2]]) # plot only the diagonal response","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Looks unstable to me. The analysis using MDelta methodology below will also reach this conclusion.","category":"page"},{"location":"uncertainty/#Example-in-section-3.7.2,-Distillation-Process","page":"Uncertainty modeling","title":"Example in section 3.7.2, Distillation Process","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"using RobustAndOptimalControl, ControlSystems, MonteCarloMeasurements, Plots, LinearAlgebra\ndefault(size=(640,480))\nunsafe_comparisons(true)\n\nM = [87.8 -86.4; 108.2 -109.6]\nG = ss(tf(1, [75, 1])) * M\nRGA = relative_gain_array(G, 0)\nsum(abs, RGA) # A good estimate of the true condition number, which is 141.7","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"large elements in the RGA indicate a process that is difficult to control","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We consider the following inverse-based controller, which may also be looked upon as a steady-state decoupler with a PI controller","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"k1 = 0.7\nKinv = ss(tf(k1*[75, 1], [1, 0])) * inv(M) \n\n# reference filter\nF = tf(1, [5, 1])\n\nw = 2π .* exp10.(LinRange(-2, 2, 500))\nsigmaplot(input_sensitivity(G, Kinv), w)\nsigmaplot!(output_sensitivity(G, Kinv), w, c=2)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Sensitivity looks nice, how about step response","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"plot(step(feedback(G*Kinv)*F, 20))","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Looks excellent..","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We consider again the input gain uncertainty as in the previous example, and we manually select the perturbations to be ϵ_1 = 02 and ϵ_2 = 02. We then have","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"G′ = G * diagm([1 + 0.2, 1 - 0.2])\nplot!(step(feedback(G′*Kinv)*F, 20), l=:dash)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Looks very poor! The system was not robust to simultaneous input uncertainty!","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We can also do this with a real, diagonal input uncertainty that grows with frequency","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"W0 = Weights.makeweight(0.2, 1, 2.0) # uncertainty goes from 20% at low frequencies to 200% at high frequencies\nW = I(2) + W0 * diagm([δr(100), δr(100)])\nGs = G*W\n\nplot(step(feedback(G*Kinv)*F, 20))\nplot!(step(feedback(G′*Kinv)*F, 20), l=:dash)\nres = step(c2d(feedback(Gs*Kinv)*F, 0.01), 20)\nmcplot!(res.t, abs.(res.y[:, :, 1]'), alpha=0.3)\nmcplot!(res.t, abs.(res.y[:, :, 2]'), alpha=0.3)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The system is very sensitive to real input uncertainty!","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"With a complex, diagonal uncertainty, modeling both gain and phase variations, it looks slightly worse, but not much worse than with real uncertainty.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"W = I(2) + W0 * diagm([δc(100), δc(100)]) # note δc instead of δr above\nGs = G*W\nres = step(c2d(feedback(Gs*Kinv)*F, 0.01), 20)\nmcplot!(res.t, abs.(res.y[:, :, 1]'), alpha=0.3)\nmcplot!(res.t, abs.(res.y[:, :, 2]'), alpha=0.3)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"How about the sensitivity functions?","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Si = input_sensitivity(Gs, Kinv)\nsigmaplot(Si, w, c=1, lab=\"Si\")\nSo = output_sensitivity(Gs, Kinv)\nsigmaplot!(So, w, c=2, lab=\"So\")","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The sensitivity at the plant output is enormous. A low sensitivity with the nominal system does not guarantee robustness!","category":"page"},{"location":"uncertainty/#Using-the-M\\Delta-framework","page":"Uncertainty modeling","title":"Using the MDelta framework","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The examples above never bothered with things like structured singular value, mu or linear-fractional transforms. We do, however, provide some elementary support for this modeling framework.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"In robust control, we often find ourselves having to consider the feedback interconnections below.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"        ┌─────────┐\n  zΔ◄───┤         │◄────wΔ\n        │         │\n   z◄───┤    P    │◄────w\n        │         │\n   y◄───┤         │◄────u\n        └─────────┘","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"        ┌─────────┐\n  zΔ◄───┤         │◄────wΔ\n        │         │\n   z◄───┤    P    │◄────w\n        │         │\n   y┌───┤         │◄───┐u\n    │   └─────────┘    │\n    │                  │\n    │      ┌───┐       │\n    │      │   │       │\n    └─────►│ K ├───────┘\n           │   │\n           └───┘","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"           ┌───┐\n           │   │\n    ┌─────►│ Δ ├───────┐\n    │      │   │       │\n    │      └───┘       │\n    │                  │\n    │   ┌─────────┐    │\n  zΔ└───┤         │◄───┘wΔ\n        │         │\n   z◄───┤    P    │◄────w\n        │         │\n   y┌───┤         │◄───┐u\n    │   └─────────┘    │\n    │                  │\n    │      ┌───┐       │\n    │      │   │       │\n    └─────►│ K ├───────┘\n           │   │\n           └───┘","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"The first block diagram denotes an open-loop system P with an uncertainty mapping w_Delta = Delta  z_Delta, a performance mapping from w to z and a input-output mapping between u and y. Such a system P can be partitioned as","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"P = beginbmatrix\nP_11  P_12  P_13\nP_21  P_22  P_23\nP_31  P_32  P_33\nendbmatrix","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"where each P(s)_ij is a transfer matrix. The type UncertainSS with constructor uss represents the block","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"P = beginbmatrix\nP_11  P_12\nP_21  P_22\nendbmatrix","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"while an ExtendedStateSpace object represents the block","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"P = beginbmatrix\nP_22  P_23\nP_32  P_33\nendbmatrix","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"there is thus no type that represents the full system P above. However, we provide the function partition which allows you to convert from a regular statespace system to an extended statespace object, and it is thus possible to represent P by placing the whole block ","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"P = beginbmatrix\nP_22  P_23\nP_32  P_33\nendbmatrix","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"into P_22 for the purposes of uncertainty analysis (use ss to convert it to a standard statespace object), and later use partition to recover the internal block structure. ","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Given an UncertainSS P, we can close the loop around Delta by calling starprod(Δ, P) or lft(P, Δ, :u) (note the different order of the arguments), and given an ExtendedStateSpace, we can close the loop around K by calling starprod(P, K) or lft(P, K) (using positive feedback). This works even if P is a regular statespace object, in which case the convention is that the inputs and outputs are ordered as in the block diagrams above. The number of signals that will be connected by lft is determined by the input-output arity of K and Delta respectively.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We have the following methods for lft (in addition to the standard ones in ControlSystems.jl)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"lft(G::UncertainSS, K::LTISystem) forms the lower LFT closing the loop around K.\nlft(G::UncertainSS, Δ::AbstractArray=G.Δ) forms the upper LFT closing the loop around Delta.\nlft(G::ExtendedStateSpace, K) forms the lower LFT closing the loop around K.","category":"page"},{"location":"uncertainty/#Examples","page":"Uncertainty modeling","title":"Examples","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We repeat the first example here, but using MDelta formalism rather than direct Monte-Carlo modeling.","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"a = 10\nP = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)\nW0 = Weights.makeweight(0.2, (1,1), 2)\nW = ss(1.0I(2)) + (ss(W0)*I(2)) * uss([δc(), δc()]) # Create a diagonal complex uncertainty weighted in frequency by W0\n# note how considerably more verbose the line above is compared to when sampled uncertainties were used, this is an indication of the experimental state of the MΔ tools\nPs = P*W","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Ps is now represented as a upper linear fractional transform (upper LFT).","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We can draw samples from this uncertainty representation (sampling of Delta and closing the loop starprod(Δ, Ps)) like so","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Psamples = rand(Ps, 100)\nsigmaplot(Psamples, w)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We can extract the nominal model using","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"system_mapping(Ps)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"And obtain M and Delta when the loop is closed with K has","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"lft(Ps, K).M","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"Ps.Δ # Ps.delta also works","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"We can evaluate the frequency response of M and calculate the structured singular value mu","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"M = freqresp(lft(Ps, -K).M, w) # -K to get negative feedback\nM = permutedims(M, (2,3,1))\nμ = structured_singular_value(M)\nplot(w, μ, xscale=:log10)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"mu","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"is very high, whenever mu  1, the system is not stable with respect to the modeled uncertainty. The tolerated uncertainty is only about dfrac1mu_infty","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"1/norm(μ, Inf)","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"of the modeled uncertainty. Another way of calculating this value is","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"robstab(lft(Ps, -K))","category":"page"},{"location":"uncertainty/#Internals-of-the-M\\Delta-framework","page":"Uncertainty modeling","title":"Internals of the MDelta framework","text":"","category":"section"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"[Skogestad]: Skogestad, \"Multivariable Feedback Control: Analysis and Design\"","category":"page"},{"location":"uncertainty/","page":"Uncertainty modeling","title":"Uncertainty modeling","text":"[Doyle91]: Doyle, Packard, Zhou, \"Review of LFTs, LMIs and μ\". https://www.researchgate.net/publication/257200344_Review_of_LFTs_LMIs_and_mu","category":"page"}]
}
